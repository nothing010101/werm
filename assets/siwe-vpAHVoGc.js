var $l = Object.defineProperty;
var mo = e => {
    throw TypeError(e)
}
;
var ql = (e, t, s) => t in e ? $l(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : e[t] = s;
var ue = (e, t, s) => ql(e, typeof t != "symbol" ? t + "" : t, s)
  , $s = (e, t, s) => t.has(e) || mo("Cannot " + s);
var j = (e, t, s) => ($s(e, t, "read from private field"),
s ? s.call(e) : t.get(e))
  , he = (e, t, s) => t.has(e) ? mo("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, s)
  , Q = (e, t, s, r) => ($s(e, t, "write to private field"),
r ? r.call(e, s) : t.set(e, s),
s)
  , we = (e, t, s) => ($s(e, t, "access private method"),
s);
var Br = (e, t, s, r) => ({
    set _(n) {
        Q(e, t, n, s)
    },
    get _() {
        return j(e, t, r)
    }
});
import {a3 as ou, a1 as He, $ as zl, V as Kl} from "./farcaster-C92qEBt4.js";
import {u as Vl, s as Jl} from "./sha3-B-UYh5th.js";
import {a as Ql, r as Wl} from "./___vite-browser-external_commonjs-proxy-6ZTq1dOW.js";
function Yl(e, t) {
    for (var s = 0; s < t.length; s++) {
        const r = t[s];
        if (typeof r != "string" && !Array.isArray(r)) {
            for (const n in r)
                if (n !== "default" && !(n in e)) {
                    const d = Object.getOwnPropertyDescriptor(r, n);
                    d && Object.defineProperty(e, n, d.get ? d : {
                        enumerable: !0,
                        get: () => r[n]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
    }))
}
var Di = {}
  , Ps = {}
  , au = {}
  , kr = {}
  , ks = {};
Object.defineProperty(ks, "__esModule", {
    value: !0
});
ks.grammar = void 0;
function Zl() {
    this.grammarObject = "grammarObject",
    this.rules = [],
    this.rules[0] = {
        name: "sign-in-with-ethereum",
        lower: "sign-in-with-ethereum",
        index: 0,
        isBkr: !1
    },
    this.rules[1] = {
        name: "ex-title",
        lower: "ex-title",
        index: 1,
        isBkr: !1
    },
    this.rules[2] = {
        name: "nb-title",
        lower: "nb-title",
        index: 2,
        isBkr: !1
    },
    this.rules[3] = {
        name: "ri-title",
        lower: "ri-title",
        index: 3,
        isBkr: !1
    },
    this.rules[4] = {
        name: "re-title",
        lower: "re-title",
        index: 4,
        isBkr: !1
    },
    this.rules[5] = {
        name: "oscheme",
        lower: "oscheme",
        index: 5,
        isBkr: !1
    },
    this.rules[6] = {
        name: "domain",
        lower: "domain",
        index: 6,
        isBkr: !1
    },
    this.rules[7] = {
        name: "address",
        lower: "address",
        index: 7,
        isBkr: !1
    },
    this.rules[8] = {
        name: "statement",
        lower: "statement",
        index: 8,
        isBkr: !1
    },
    this.rules[9] = {
        name: "empty-statement",
        lower: "empty-statement",
        index: 9,
        isBkr: !1
    },
    this.rules[10] = {
        name: "version",
        lower: "version",
        index: 10,
        isBkr: !1
    },
    this.rules[11] = {
        name: "nonce",
        lower: "nonce",
        index: 11,
        isBkr: !1
    },
    this.rules[12] = {
        name: "issued-at",
        lower: "issued-at",
        index: 12,
        isBkr: !1
    },
    this.rules[13] = {
        name: "expiration-time",
        lower: "expiration-time",
        index: 13,
        isBkr: !1
    },
    this.rules[14] = {
        name: "not-before",
        lower: "not-before",
        index: 14,
        isBkr: !1
    },
    this.rules[15] = {
        name: "request-id",
        lower: "request-id",
        index: 15,
        isBkr: !1
    },
    this.rules[16] = {
        name: "chain-id",
        lower: "chain-id",
        index: 16,
        isBkr: !1
    },
    this.rules[17] = {
        name: "resources",
        lower: "resources",
        index: 17,
        isBkr: !1
    },
    this.rules[18] = {
        name: "resource",
        lower: "resource",
        index: 18,
        isBkr: !1
    },
    this.rules[19] = {
        name: "URI",
        lower: "uri",
        index: 19,
        isBkr: !1
    },
    this.rules[20] = {
        name: "hier-part",
        lower: "hier-part",
        index: 20,
        isBkr: !1
    },
    this.rules[21] = {
        name: "scheme",
        lower: "scheme",
        index: 21,
        isBkr: !1
    },
    this.rules[22] = {
        name: "authority",
        lower: "authority",
        index: 22,
        isBkr: !1
    },
    this.rules[23] = {
        name: "path-abempty",
        lower: "path-abempty",
        index: 23,
        isBkr: !1
    },
    this.rules[24] = {
        name: "path-absolute",
        lower: "path-absolute",
        index: 24,
        isBkr: !1
    },
    this.rules[25] = {
        name: "path-rootless",
        lower: "path-rootless",
        index: 25,
        isBkr: !1
    },
    this.rules[26] = {
        name: "path-empty",
        lower: "path-empty",
        index: 26,
        isBkr: !1
    },
    this.rules[27] = {
        name: "userinfo-at",
        lower: "userinfo-at",
        index: 27,
        isBkr: !1
    },
    this.rules[28] = {
        name: "userinfo",
        lower: "userinfo",
        index: 28,
        isBkr: !1
    },
    this.rules[29] = {
        name: "host",
        lower: "host",
        index: 29,
        isBkr: !1
    },
    this.rules[30] = {
        name: "IP-literal",
        lower: "ip-literal",
        index: 30,
        isBkr: !1
    },
    this.rules[31] = {
        name: "IPvFuture",
        lower: "ipvfuture",
        index: 31,
        isBkr: !1
    },
    this.rules[32] = {
        name: "IPv6address",
        lower: "ipv6address",
        index: 32,
        isBkr: !1
    },
    this.rules[33] = {
        name: "nodcolon",
        lower: "nodcolon",
        index: 33,
        isBkr: !1
    },
    this.rules[34] = {
        name: "dcolon",
        lower: "dcolon",
        index: 34,
        isBkr: !1
    },
    this.rules[35] = {
        name: "h16",
        lower: "h16",
        index: 35,
        isBkr: !1
    },
    this.rules[36] = {
        name: "h16c",
        lower: "h16c",
        index: 36,
        isBkr: !1
    },
    this.rules[37] = {
        name: "h16n",
        lower: "h16n",
        index: 37,
        isBkr: !1
    },
    this.rules[38] = {
        name: "h16cn",
        lower: "h16cn",
        index: 38,
        isBkr: !1
    },
    this.rules[39] = {
        name: "IPv4address",
        lower: "ipv4address",
        index: 39,
        isBkr: !1
    },
    this.rules[40] = {
        name: "dec-octet",
        lower: "dec-octet",
        index: 40,
        isBkr: !1
    },
    this.rules[41] = {
        name: "dec-digit",
        lower: "dec-digit",
        index: 41,
        isBkr: !1
    },
    this.rules[42] = {
        name: "reg-name",
        lower: "reg-name",
        index: 42,
        isBkr: !1
    },
    this.rules[43] = {
        name: "reg-name-char",
        lower: "reg-name-char",
        index: 43,
        isBkr: !1
    },
    this.rules[44] = {
        name: "port",
        lower: "port",
        index: 44,
        isBkr: !1
    },
    this.rules[45] = {
        name: "query",
        lower: "query",
        index: 45,
        isBkr: !1
    },
    this.rules[46] = {
        name: "fragment",
        lower: "fragment",
        index: 46,
        isBkr: !1
    },
    this.rules[47] = {
        name: "URI-r",
        lower: "uri-r",
        index: 47,
        isBkr: !1
    },
    this.rules[48] = {
        name: "hier-part-r",
        lower: "hier-part-r",
        index: 48,
        isBkr: !1
    },
    this.rules[49] = {
        name: "scheme-r",
        lower: "scheme-r",
        index: 49,
        isBkr: !1
    },
    this.rules[50] = {
        name: "query-r",
        lower: "query-r",
        index: 50,
        isBkr: !1
    },
    this.rules[51] = {
        name: "fragment-r",
        lower: "fragment-r",
        index: 51,
        isBkr: !1
    },
    this.rules[52] = {
        name: "authority-d",
        lower: "authority-d",
        index: 52,
        isBkr: !1
    },
    this.rules[53] = {
        name: "userinfo-d",
        lower: "userinfo-d",
        index: 53,
        isBkr: !1
    },
    this.rules[54] = {
        name: "host-d",
        lower: "host-d",
        index: 54,
        isBkr: !1
    },
    this.rules[55] = {
        name: "port-d",
        lower: "port-d",
        index: 55,
        isBkr: !1
    },
    this.rules[56] = {
        name: "path-abempty-r",
        lower: "path-abempty-r",
        index: 56,
        isBkr: !1
    },
    this.rules[57] = {
        name: "path-absolute-r",
        lower: "path-absolute-r",
        index: 57,
        isBkr: !1
    },
    this.rules[58] = {
        name: "path-rootless-r",
        lower: "path-rootless-r",
        index: 58,
        isBkr: !1
    },
    this.rules[59] = {
        name: "path-empty-r",
        lower: "path-empty-r",
        index: 59,
        isBkr: !1
    },
    this.rules[60] = {
        name: "segment",
        lower: "segment",
        index: 60,
        isBkr: !1
    },
    this.rules[61] = {
        name: "segment-nz",
        lower: "segment-nz",
        index: 61,
        isBkr: !1
    },
    this.rules[62] = {
        name: "pchar",
        lower: "pchar",
        index: 62,
        isBkr: !1
    },
    this.rules[63] = {
        name: "pct-encoded",
        lower: "pct-encoded",
        index: 63,
        isBkr: !1
    },
    this.rules[64] = {
        name: "date-fullyear",
        lower: "date-fullyear",
        index: 64,
        isBkr: !1
    },
    this.rules[65] = {
        name: "date-month",
        lower: "date-month",
        index: 65,
        isBkr: !1
    },
    this.rules[66] = {
        name: "date-mday",
        lower: "date-mday",
        index: 66,
        isBkr: !1
    },
    this.rules[67] = {
        name: "time-hour",
        lower: "time-hour",
        index: 67,
        isBkr: !1
    },
    this.rules[68] = {
        name: "time-minute",
        lower: "time-minute",
        index: 68,
        isBkr: !1
    },
    this.rules[69] = {
        name: "time-second",
        lower: "time-second",
        index: 69,
        isBkr: !1
    },
    this.rules[70] = {
        name: "time-secfrac",
        lower: "time-secfrac",
        index: 70,
        isBkr: !1
    },
    this.rules[71] = {
        name: "time-numoffset",
        lower: "time-numoffset",
        index: 71,
        isBkr: !1
    },
    this.rules[72] = {
        name: "time-offset",
        lower: "time-offset",
        index: 72,
        isBkr: !1
    },
    this.rules[73] = {
        name: "partial-time",
        lower: "partial-time",
        index: 73,
        isBkr: !1
    },
    this.rules[74] = {
        name: "full-date",
        lower: "full-date",
        index: 74,
        isBkr: !1
    },
    this.rules[75] = {
        name: "full-time",
        lower: "full-time",
        index: 75,
        isBkr: !1
    },
    this.rules[76] = {
        name: "date-time",
        lower: "date-time",
        index: 76,
        isBkr: !1
    },
    this.rules[77] = {
        name: "ALPHA",
        lower: "alpha",
        index: 77,
        isBkr: !1
    },
    this.rules[78] = {
        name: "LF",
        lower: "lf",
        index: 78,
        isBkr: !1
    },
    this.rules[79] = {
        name: "DIGIT",
        lower: "digit",
        index: 79,
        isBkr: !1
    },
    this.rules[80] = {
        name: "HEXDIG",
        lower: "hexdig",
        index: 80,
        isBkr: !1
    },
    this.udts = [],
    this.rules[0].opcodes = [],
    this.rules[0].opcodes[0] = {
        type: 2,
        children: [1, 2, 3, 4, 5, 6, 7, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 36, 41, 46]
    },
    this.rules[0].opcodes[1] = {
        type: 4,
        index: 5
    },
    this.rules[0].opcodes[2] = {
        type: 4,
        index: 6
    },
    this.rules[0].opcodes[3] = {
        type: 6,
        string: [32, 119, 97, 110, 116, 115, 32, 121, 111, 117, 32, 116, 111, 32, 115, 105, 103, 110, 32, 105, 110, 32, 119, 105, 116, 104, 32, 121, 111, 117, 114, 32, 69, 116, 104, 101, 114, 101, 117, 109, 32, 97, 99, 99, 111, 117, 110, 116, 58]
    },
    this.rules[0].opcodes[4] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[5] = {
        type: 4,
        index: 7
    },
    this.rules[0].opcodes[6] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[7] = {
        type: 1,
        children: [8, 13, 14]
    },
    this.rules[0].opcodes[8] = {
        type: 2,
        children: [9, 10, 11, 12]
    },
    this.rules[0].opcodes[9] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[10] = {
        type: 4,
        index: 8
    },
    this.rules[0].opcodes[11] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[12] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[13] = {
        type: 4,
        index: 9
    },
    this.rules[0].opcodes[14] = {
        type: 2,
        children: [15, 16]
    },
    this.rules[0].opcodes[15] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[16] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[17] = {
        type: 6,
        string: [85, 82, 73, 58, 32]
    },
    this.rules[0].opcodes[18] = {
        type: 4,
        index: 19
    },
    this.rules[0].opcodes[19] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[20] = {
        type: 6,
        string: [86, 101, 114, 115, 105, 111, 110, 58, 32]
    },
    this.rules[0].opcodes[21] = {
        type: 4,
        index: 10
    },
    this.rules[0].opcodes[22] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[23] = {
        type: 6,
        string: [67, 104, 97, 105, 110, 32, 73, 68, 58, 32]
    },
    this.rules[0].opcodes[24] = {
        type: 4,
        index: 16
    },
    this.rules[0].opcodes[25] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[26] = {
        type: 6,
        string: [78, 111, 110, 99, 101, 58, 32]
    },
    this.rules[0].opcodes[27] = {
        type: 4,
        index: 11
    },
    this.rules[0].opcodes[28] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[29] = {
        type: 6,
        string: [73, 115, 115, 117, 101, 100, 32, 65, 116, 58, 32]
    },
    this.rules[0].opcodes[30] = {
        type: 4,
        index: 12
    },
    this.rules[0].opcodes[31] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[0].opcodes[32] = {
        type: 2,
        children: [33, 34, 35]
    },
    this.rules[0].opcodes[33] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[34] = {
        type: 4,
        index: 1
    },
    this.rules[0].opcodes[35] = {
        type: 4,
        index: 13
    },
    this.rules[0].opcodes[36] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[0].opcodes[37] = {
        type: 2,
        children: [38, 39, 40]
    },
    this.rules[0].opcodes[38] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[39] = {
        type: 4,
        index: 2
    },
    this.rules[0].opcodes[40] = {
        type: 4,
        index: 14
    },
    this.rules[0].opcodes[41] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[0].opcodes[42] = {
        type: 2,
        children: [43, 44, 45]
    },
    this.rules[0].opcodes[43] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[44] = {
        type: 4,
        index: 3
    },
    this.rules[0].opcodes[45] = {
        type: 4,
        index: 15
    },
    this.rules[0].opcodes[46] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[0].opcodes[47] = {
        type: 2,
        children: [48, 49, 50]
    },
    this.rules[0].opcodes[48] = {
        type: 4,
        index: 78
    },
    this.rules[0].opcodes[49] = {
        type: 4,
        index: 4
    },
    this.rules[0].opcodes[50] = {
        type: 4,
        index: 17
    },
    this.rules[1].opcodes = [],
    this.rules[1].opcodes[0] = {
        type: 6,
        string: [69, 120, 112, 105, 114, 97, 116, 105, 111, 110, 32, 84, 105, 109, 101, 58, 32]
    },
    this.rules[2].opcodes = [],
    this.rules[2].opcodes[0] = {
        type: 6,
        string: [78, 111, 116, 32, 66, 101, 102, 111, 114, 101, 58, 32]
    },
    this.rules[3].opcodes = [],
    this.rules[3].opcodes[0] = {
        type: 6,
        string: [82, 101, 113, 117, 101, 115, 116, 32, 73, 68, 58, 32]
    },
    this.rules[4].opcodes = [],
    this.rules[4].opcodes[0] = {
        type: 6,
        string: [82, 101, 115, 111, 117, 114, 99, 101, 115, 58]
    },
    this.rules[5].opcodes = [],
    this.rules[5].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[5].opcodes[1] = {
        type: 2,
        children: [2, 3, 9]
    },
    this.rules[5].opcodes[2] = {
        type: 4,
        index: 77
    },
    this.rules[5].opcodes[3] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[5].opcodes[4] = {
        type: 1,
        children: [5, 6, 7, 8]
    },
    this.rules[5].opcodes[5] = {
        type: 4,
        index: 77
    },
    this.rules[5].opcodes[6] = {
        type: 4,
        index: 79
    },
    this.rules[5].opcodes[7] = {
        type: 6,
        string: [43]
    },
    this.rules[5].opcodes[8] = {
        type: 5,
        min: 45,
        max: 46
    },
    this.rules[5].opcodes[9] = {
        type: 7,
        string: [58, 47, 47]
    },
    this.rules[6].opcodes = [],
    this.rules[6].opcodes[0] = {
        type: 4,
        index: 52
    },
    this.rules[7].opcodes = [],
    this.rules[7].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[7].opcodes[1] = {
        type: 7,
        string: [48, 120]
    },
    this.rules[7].opcodes[2] = {
        type: 3,
        min: 40,
        max: 40
    },
    this.rules[7].opcodes[3] = {
        type: 4,
        index: 80
    },
    this.rules[8].opcodes = [],
    this.rules[8].opcodes[0] = {
        type: 3,
        min: 1,
        max: 1 / 0
    },
    this.rules[8].opcodes[1] = {
        type: 1,
        children: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]
    },
    this.rules[8].opcodes[2] = {
        type: 5,
        min: 97,
        max: 122
    },
    this.rules[8].opcodes[3] = {
        type: 5,
        min: 65,
        max: 90
    },
    this.rules[8].opcodes[4] = {
        type: 5,
        min: 48,
        max: 57
    },
    this.rules[8].opcodes[5] = {
        type: 5,
        min: 32,
        max: 33
    },
    this.rules[8].opcodes[6] = {
        type: 5,
        min: 35,
        max: 36
    },
    this.rules[8].opcodes[7] = {
        type: 5,
        min: 38,
        max: 59
    },
    this.rules[8].opcodes[8] = {
        type: 6,
        string: [61]
    },
    this.rules[8].opcodes[9] = {
        type: 5,
        min: 63,
        max: 64
    },
    this.rules[8].opcodes[10] = {
        type: 6,
        string: [91]
    },
    this.rules[8].opcodes[11] = {
        type: 6,
        string: [93]
    },
    this.rules[8].opcodes[12] = {
        type: 6,
        string: [95]
    },
    this.rules[8].opcodes[13] = {
        type: 6,
        string: [126]
    },
    this.rules[9].opcodes = [],
    this.rules[9].opcodes[0] = {
        type: 2,
        children: [1, 2, 3]
    },
    this.rules[9].opcodes[1] = {
        type: 4,
        index: 78
    },
    this.rules[9].opcodes[2] = {
        type: 4,
        index: 78
    },
    this.rules[9].opcodes[3] = {
        type: 4,
        index: 78
    },
    this.rules[10].opcodes = [],
    this.rules[10].opcodes[0] = {
        type: 7,
        string: [49]
    },
    this.rules[11].opcodes = [],
    this.rules[11].opcodes[0] = {
        type: 3,
        min: 8,
        max: 1 / 0
    },
    this.rules[11].opcodes[1] = {
        type: 1,
        children: [2, 3]
    },
    this.rules[11].opcodes[2] = {
        type: 4,
        index: 77
    },
    this.rules[11].opcodes[3] = {
        type: 4,
        index: 79
    },
    this.rules[12].opcodes = [],
    this.rules[12].opcodes[0] = {
        type: 4,
        index: 76
    },
    this.rules[13].opcodes = [],
    this.rules[13].opcodes[0] = {
        type: 4,
        index: 76
    },
    this.rules[14].opcodes = [],
    this.rules[14].opcodes[0] = {
        type: 4,
        index: 76
    },
    this.rules[15].opcodes = [],
    this.rules[15].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[15].opcodes[1] = {
        type: 4,
        index: 62
    },
    this.rules[16].opcodes = [],
    this.rules[16].opcodes[0] = {
        type: 3,
        min: 1,
        max: 1 / 0
    },
    this.rules[16].opcodes[1] = {
        type: 4,
        index: 79
    },
    this.rules[17].opcodes = [],
    this.rules[17].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[17].opcodes[1] = {
        type: 2,
        children: [2, 3]
    },
    this.rules[17].opcodes[2] = {
        type: 4,
        index: 78
    },
    this.rules[17].opcodes[3] = {
        type: 4,
        index: 18
    },
    this.rules[18].opcodes = [],
    this.rules[18].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[18].opcodes[1] = {
        type: 7,
        string: [45, 32]
    },
    this.rules[18].opcodes[2] = {
        type: 4,
        index: 47
    },
    this.rules[19].opcodes = [],
    this.rules[19].opcodes[0] = {
        type: 2,
        children: [1, 2, 3, 4, 8]
    },
    this.rules[19].opcodes[1] = {
        type: 4,
        index: 21
    },
    this.rules[19].opcodes[2] = {
        type: 7,
        string: [58]
    },
    this.rules[19].opcodes[3] = {
        type: 4,
        index: 20
    },
    this.rules[19].opcodes[4] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[19].opcodes[5] = {
        type: 2,
        children: [6, 7]
    },
    this.rules[19].opcodes[6] = {
        type: 7,
        string: [63]
    },
    this.rules[19].opcodes[7] = {
        type: 4,
        index: 45
    },
    this.rules[19].opcodes[8] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[19].opcodes[9] = {
        type: 2,
        children: [10, 11]
    },
    this.rules[19].opcodes[10] = {
        type: 7,
        string: [35]
    },
    this.rules[19].opcodes[11] = {
        type: 4,
        index: 46
    },
    this.rules[20].opcodes = [],
    this.rules[20].opcodes[0] = {
        type: 1,
        children: [1, 5, 6, 7]
    },
    this.rules[20].opcodes[1] = {
        type: 2,
        children: [2, 3, 4]
    },
    this.rules[20].opcodes[2] = {
        type: 7,
        string: [47, 47]
    },
    this.rules[20].opcodes[3] = {
        type: 4,
        index: 22
    },
    this.rules[20].opcodes[4] = {
        type: 4,
        index: 23
    },
    this.rules[20].opcodes[5] = {
        type: 4,
        index: 24
    },
    this.rules[20].opcodes[6] = {
        type: 4,
        index: 25
    },
    this.rules[20].opcodes[7] = {
        type: 4,
        index: 26
    },
    this.rules[21].opcodes = [],
    this.rules[21].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[21].opcodes[1] = {
        type: 4,
        index: 77
    },
    this.rules[21].opcodes[2] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[21].opcodes[3] = {
        type: 1,
        children: [4, 5, 6, 7]
    },
    this.rules[21].opcodes[4] = {
        type: 4,
        index: 77
    },
    this.rules[21].opcodes[5] = {
        type: 4,
        index: 79
    },
    this.rules[21].opcodes[6] = {
        type: 6,
        string: [43]
    },
    this.rules[21].opcodes[7] = {
        type: 5,
        min: 45,
        max: 46
    },
    this.rules[22].opcodes = [],
    this.rules[22].opcodes[0] = {
        type: 2,
        children: [1, 3, 4]
    },
    this.rules[22].opcodes[1] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[22].opcodes[2] = {
        type: 4,
        index: 27
    },
    this.rules[22].opcodes[3] = {
        type: 4,
        index: 29
    },
    this.rules[22].opcodes[4] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[22].opcodes[5] = {
        type: 2,
        children: [6, 7]
},
    this.rules[22].opcodes[6] = {
        type: 7,
        string: [58]
    },
    this.rules[22].opcodes[7] = {
        type: 4,
        index: 44
    },
    this.rules[23].opcodes = [],
    this.rules[23].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[23].opcodes[1] = {
        type: 2,
        children: [2, 3]
    },
    this.rules[23].opcodes[2] = {
        type: 7,
        string: [47]
    },
    this.rules[23].opcodes[3] = {
        type: 4,
        index: 60
    },
    this.rules[24].opcodes = [],
    this.rules[24].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[24].opcodes[1] = {
        type: 7,
        string: [47]
    },
    this.rules[24].opcodes[2] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[24].opcodes[3] = {
        type: 2,
        children: [4, 5]
    },
    this.rules[24].opcodes[4] = {
        type: 4,
        index: 61
    },
    this.rules[24].opcodes[5] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[24].opcodes[6] = {
        type: 2,
        children: [7, 8]
    },
    this.rules[24].opcodes[7] = {
        type: 7,
        string: [47]
    },
    this.rules[24].opcodes[8] = {
        type: 4,
        index: 60
    },
    this.rules[25].opcodes = [],
    this.rules[25].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[25].opcodes[1] = {
        type: 4,
        index: 61
    },
    this.rules[25].opcodes[2] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[25].opcodes[3] = {
        type: 2,
        children: [4, 5]
    },
    this.rules[25].opcodes[4] = {
        type: 7,
        string: [47]
    },
    this.rules[25].opcodes[5] = {
        type: 4,
        index: 60
    },
    this.rules[26].opcodes = [],
    this.rules[26].opcodes[0] = {
        type: 7,
        string: []
    },
    this.rules[27].opcodes = [],
    this.rules[27].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[27].opcodes[1] = {
        type: 4,
        index: 28
    },
    this.rules[27].opcodes[2] = {
        type: 6,
        string: [64]
    },
    this.rules[28].opcodes = [],
    this.rules[28].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[28].opcodes[1] = {
        type: 1,
        children: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
    },
    this.rules[28].opcodes[2] = {
        type: 5,
        min: 97,
        max: 122
    },
    this.rules[28].opcodes[3] = {
        type: 5,
        min: 65,
        max: 90
    },
    this.rules[28].opcodes[4] = {
        type: 5,
        min: 48,
        max: 57
    },
    this.rules[28].opcodes[5] = {
        type: 4,
        index: 63
    },
    this.rules[28].opcodes[6] = {
        type: 6,
        string: [33]
    },
    this.rules[28].opcodes[7] = {
        type: 6,
        string: [36]
    },
    this.rules[28].opcodes[8] = {
        type: 5,
        min: 38,
        max: 46
    },
    this.rules[28].opcodes[9] = {
        type: 5,
        min: 58,
        max: 59
    },
    this.rules[28].opcodes[10] = {
        type: 6,
        string: [61]
    },
    this.rules[28].opcodes[11] = {
        type: 6,
        string: [95]
    },
    this.rules[28].opcodes[12] = {
        type: 6,
        string: [126]
    },
    this.rules[29].opcodes = [],
    this.rules[29].opcodes[0] = {
        type: 1,
        children: [1, 2, 6]
    },
    this.rules[29].opcodes[1] = {
        type: 4,
        index: 30
    },
    this.rules[29].opcodes[2] = {
        type: 2,
        children: [3, 4]
    },
    this.rules[29].opcodes[3] = {
        type: 4,
        index: 39
    },
    this.rules[29].opcodes[4] = {
        type: 13
    },
    this.rules[29].opcodes[5] = {
        type: 4,
        index: 43
    },
    this.rules[29].opcodes[6] = {
        type: 4,
        index: 42
    },
    this.rules[30].opcodes = [],
    this.rules[30].opcodes[0] = {
        type: 2,
        children: [1, 2, 5]
    },
    this.rules[30].opcodes[1] = {
        type: 7,
        string: [91]
    },
    this.rules[30].opcodes[2] = {
        type: 1,
        children: [3, 4]
    },
    this.rules[30].opcodes[3] = {
        type: 4,
        index: 32
    },
    this.rules[30].opcodes[4] = {
        type: 4,
        index: 31
    },
    this.rules[30].opcodes[5] = {
        type: 7,
        string: [93]
    },
    this.rules[31].opcodes = [],
    this.rules[31].opcodes[0] = {
        type: 2,
        children: [1, 2, 4, 5]
    },
    this.rules[31].opcodes[1] = {
        type: 7,
        string: [118]
    },
    this.rules[31].opcodes[2] = {
        type: 3,
        min: 1,
        max: 1 / 0
    },
    this.rules[31].opcodes[3] = {
        type: 4,
        index: 80
    },
    this.rules[31].opcodes[4] = {
        type: 7,
        string: [46]
    },
    this.rules[31].opcodes[5] = {
        type: 3,
        min: 1,
        max: 1 / 0
    },
    this.rules[31].opcodes[6] = {
        type: 1,
        children: [7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
    },
    this.rules[31].opcodes[7] = {
        type: 5,
        min: 97,
        max: 122
    },
    this.rules[31].opcodes[8] = {
        type: 5,
        min: 65,
        max: 90
    },
    this.rules[31].opcodes[9] = {
        type: 5,
        min: 48,
        max: 57
    },
    this.rules[31].opcodes[10] = {
        type: 6,
        string: [33]
    },
    this.rules[31].opcodes[11] = {
        type: 6,
        string: [36]
    },
    this.rules[31].opcodes[12] = {
        type: 5,
        min: 38,
        max: 46
    },
    this.rules[31].opcodes[13] = {
        type: 5,
        min: 58,
        max: 59
    },
    this.rules[31].opcodes[14] = {
        type: 6,
        string: [61]
    },
    this.rules[31].opcodes[15] = {
        type: 6,
        string: [95]
    },
    this.rules[31].opcodes[16] = {
        type: 6,
        string: [126]
    },
    this.rules[32].opcodes = [],
    this.rules[32].opcodes[0] = {
        type: 1,
        children: [1, 2]
    },
    this.rules[32].opcodes[1] = {
        type: 4,
        index: 33
    },
    this.rules[32].opcodes[2] = {
        type: 4,
        index: 34
    },
    this.rules[33].opcodes = [],
    this.rules[33].opcodes[0] = {
        type: 2,
        children: [1, 5]
    },
    this.rules[33].opcodes[1] = {
        type: 2,
        children: [2, 3]
    },
    this.rules[33].opcodes[2] = {
        type: 4,
        index: 37
    },
    this.rules[33].opcodes[3] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[33].opcodes[4] = {
        type: 4,
        index: 38
    },
    this.rules[33].opcodes[5] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[33].opcodes[6] = {
        type: 2,
        children: [7, 8]
    },
    this.rules[33].opcodes[7] = {
        type: 6,
        string: [58]
    },
    this.rules[33].opcodes[8] = {
        type: 4,
        index: 39
    },
    this.rules[34].opcodes = [],
    this.rules[34].opcodes[0] = {
        type: 2,
        children: [1, 6, 7]
    },
    this.rules[34].opcodes[1] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[34].opcodes[2] = {
        type: 2,
        children: [3, 4]
    },
    this.rules[34].opcodes[3] = {
        type: 4,
        index: 35
    },
    this.rules[34].opcodes[4] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[34].opcodes[5] = {
        type: 4,
        index: 36
    },
    this.rules[34].opcodes[6] = {
        type: 6,
        string: [58, 58]
    },
    this.rules[34].opcodes[7] = {
        type: 1,
        children: [8, 17]
    },
    this.rules[34].opcodes[8] = {
        type: 2,
        children: [9, 13]
    },
    this.rules[34].opcodes[9] = {
        type: 2,
        children: [10, 11]
    },
    this.rules[34].opcodes[10] = {
        type: 4,
        index: 37
    },
    this.rules[34].opcodes[11] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[34].opcodes[12] = {
        type: 4,
        index: 38
    },
    this.rules[34].opcodes[13] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[34].opcodes[14] = {
        type: 2,
        children: [15, 16]
    },
    this.rules[34].opcodes[15] = {
        type: 6,
        string: [58]
    },
    this.rules[34].opcodes[16] = {
        type: 4,
        index: 39
    },
    this.rules[34].opcodes[17] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[34].opcodes[18] = {
        type: 4,
        index: 39
    },
    this.rules[35].opcodes = [],
    this.rules[35].opcodes[0] = {
        type: 3,
        min: 1,
        max: 4
    },
    this.rules[35].opcodes[1] = {
        type: 4,
        index: 80
    },
    this.rules[36].opcodes = [],
    this.rules[36].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[36].opcodes[1] = {
        type: 6,
        string: [58]
    },
    this.rules[36].opcodes[2] = {
        type: 3,
        min: 1,
        max: 4
    },
    this.rules[36].opcodes[3] = {
        type: 4,
        index: 80
    },
    this.rules[37].opcodes = [],
    this.rules[37].opcodes[0] = {
        type: 2,
        children: [1, 3]
    },
    this.rules[37].opcodes[1] = {
        type: 3,
        min: 1,
        max: 4
    },
    this.rules[37].opcodes[2] = {
        type: 4,
        index: 80
    },
    this.rules[37].opcodes[3] = {
        type: 13
    },
    this.rules[37].opcodes[4] = {
        type: 6,
        string: [46]
    },
    this.rules[38].opcodes = [],
    this.rules[38].opcodes[0] = {
        type: 2,
        children: [1, 2, 4]
    },
    this.rules[38].opcodes[1] = {
        type: 6,
        string: [58]
    },
    this.rules[38].opcodes[2] = {
        type: 3,
        min: 1,
        max: 4
    },
    this.rules[38].opcodes[3] = {
        type: 4,
        index: 80
    },
    this.rules[38].opcodes[4] = {
        type: 13
    },
    this.rules[38].opcodes[5] = {
        type: 6,
        string: [46]
    },
    this.rules[39].opcodes = [],
    this.rules[39].opcodes[0] = {
        type: 2,
        children: [1, 2, 3, 4, 5, 6, 7]
    },
    this.rules[39].opcodes[1] = {
        type: 4,
        index: 40
    },
    this.rules[39].opcodes[2] = {
        type: 7,
        string: [46]
    },
    this.rules[39].opcodes[3] = {
        type: 4,
        index: 40
    },
    this.rules[39].opcodes[4] = {
        type: 7,
        string: [46]
    },
    this.rules[39].opcodes[5] = {
        type: 4,
        index: 40
    },
    this.rules[39].opcodes[6] = {
        type: 7,
        string: [46]
    },
    this.rules[39].opcodes[7] = {
        type: 4,
        index: 40
    },
    this.rules[40].opcodes = [],
    this.rules[40].opcodes[0] = {
        type: 3,
        min: 0,
        max: 3
    },
    this.rules[40].opcodes[1] = {
        type: 4,
        index: 41
    },
    this.rules[41].opcodes = [],
    this.rules[41].opcodes[0] = {
        type: 5,
        min: 48,
        max: 57
    },
    this.rules[42].opcodes = [],
    this.rules[42].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[42].opcodes[1] = {
        type: 4,
        index: 43
    },
    this.rules[43].opcodes = [],
    this.rules[43].opcodes[0] = {
        type: 1,
        children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
    },
    this.rules[43].opcodes[1] = {
        type: 5,
        min: 97,
        max: 122
    },
    this.rules[43].opcodes[2] = {
        type: 5,
        min: 65,
        max: 90
    },
    this.rules[43].opcodes[3] = {
        type: 5,
        min: 48,
        max: 57
    },
    this.rules[43].opcodes[4] = {
        type: 4,
        index: 63
    },
    this.rules[43].opcodes[5] = {
        type: 6,
        string: [33]
    },
    this.rules[43].opcodes[6] = {
        type: 6,
        string: [36]
    },
    this.rules[43].opcodes[7] = {
        type: 5,
        min: 38,
        max: 46
    },
    this.rules[43].opcodes[8] = {
        type: 6,
        string: [59]
    },
    this.rules[43].opcodes[9] = {
        type: 6,
        string: [61]
    },
    this.rules[43].opcodes[10] = {
        type: 6,
        string: [95]
    },
    this.rules[43].opcodes[11] = {
        type: 6,
        string: [126]
    },
    this.rules[44].opcodes = [],
    this.rules[44].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[44].opcodes[1] = {
        type: 4,
        index: 79
    },
    this.rules[45].opcodes = [],
    this.rules[45].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[45].opcodes[1] = {
        type: 1,
        children: [2, 3, 4]
    },
    this.rules[45].opcodes[2] = {
        type: 4,
        index: 62
    },
    this.rules[45].opcodes[3] = {
        type: 6,
        string: [47]
    },
    this.rules[45].opcodes[4] = {
        type: 6,
        string: [63]
    },
    this.rules[46].opcodes = [],
    this.rules[46].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[46].opcodes[1] = {
        type: 1,
        children: [2, 3, 4]
    },
    this.rules[46].opcodes[2] = {
        type: 4,
        index: 62
    },
    this.rules[46].opcodes[3] = {
        type: 6,
        string: [47]
    },
    this.rules[46].opcodes[4] = {
        type: 6,
        string: [63]
    },
    this.rules[47].opcodes = [],
    this.rules[47].opcodes[0] = {
        type: 2,
        children: [1, 2, 3, 4, 8]
    },
    this.rules[47].opcodes[1] = {
        type: 4,
        index: 49
    },
    this.rules[47].opcodes[2] = {
        type: 7,
        string: [58]
    },
    this.rules[47].opcodes[3] = {
        type: 4,
        index: 48
    },
    this.rules[47].opcodes[4] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[47].opcodes[5] = {
        type: 2,
        children: [6, 7]
    },
    this.rules[47].opcodes[6] = {
        type: 7,
        string: [63]
    },
    this.rules[47].opcodes[7] = {
        type: 4,
        index: 50
    },
    this.rules[47].opcodes[8] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[47].opcodes[9] = {
        type: 2,
        children: [10, 11]
    },
    this.rules[47].opcodes[10] = {
        type: 7,
        string: [35]
    },
    this.rules[47].opcodes[11] = {
        type: 4,
        index: 51
    },
    this.rules[48].opcodes = [],
    this.rules[48].opcodes[0] = {
        type: 1,
        children: [1, 5, 6, 7]
    },
    this.rules[48].opcodes[1] = {
        type: 2,
        children: [2, 3, 4]
    },
    this.rules[48].opcodes[2] = {
        type: 7,
        string: [47, 47]
    },
    this.rules[48].opcodes[3] = {
        type: 4,
        index: 52
    },
    this.rules[48].opcodes[4] = {
        type: 4,
        index: 56
    },
    this.rules[48].opcodes[5] = {
        type: 4,
        index: 57
    },
    this.rules[48].opcodes[6] = {
        type: 4,
        index: 58
    },
    this.rules[48].opcodes[7] = {
        type: 4,
        index: 59
    },
    this.rules[49].opcodes = [],
    this.rules[49].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[49].opcodes[1] = {
        type: 4,
        index: 77
    },
    this.rules[49].opcodes[2] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[49].opcodes[3] = {
        type: 1,
        children: [4, 5, 6, 7]
    },
    this.rules[49].opcodes[4] = {
        type: 4,
        index: 77
    },
    this.rules[49].opcodes[5] = {
        type: 4,
        index: 79
    },
    this.rules[49].opcodes[6] = {
        type: 6,
        string: [43]
    },
    this.rules[49].opcodes[7] = {
        type: 5,
        min: 45,
        max: 46
    },
    this.rules[50].opcodes = [],
    this.rules[50].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[50].opcodes[1] = {
        type: 1,
        children: [2, 3, 4]
    },
    this.rules[50].opcodes[2] = {
        type: 4,
        index: 62
    },
    this.rules[50].opcodes[3] = {
        type: 6,
        string: [47]
    },
    this.rules[50].opcodes[4] = {
        type: 6,
        string: [63]
    },
    this.rules[51].opcodes = [],
    this.rules[51].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[51].opcodes[1] = {
        type: 1,
        children: [2, 3, 4]
    },
    this.rules[51].opcodes[2] = {
        type: 4,
        index: 62
    },
    this.rules[51].opcodes[3] = {
        type: 6,
        string: [47]
    },
    this.rules[51].opcodes[4] = {
        type: 6,
        string: [63]
    },
    this.rules[52].opcodes = [],
    this.rules[52].opcodes[0] = {
        type: 2,
        children: [1, 5, 6]
    },
    this.rules[52].opcodes[1] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[52].opcodes[2] = {
        type: 2,
        children: [3, 4]
    },
    this.rules[52].opcodes[3] = {
        type: 4,
        index: 53
    },
    this.rules[52].opcodes[4] = {
        type: 6,
        string: [64]
    },
    this.rules[52].opcodes[5] = {
        type: 4,
        index: 54
    },
    this.rules[52].opcodes[6] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[52].opcodes[7] = {
        type: 2,
        children: [8, 9]
    },
    this.rules[52].opcodes[8] = {
        type: 7,
        string: [58]
    },
    this.rules[52].opcodes[9] = {
        type: 4,
        index: 55
    },
    this.rules[53].opcodes = [],
    this.rules[53].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[53].opcodes[1] = {
        type: 1,
        children: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
    },
    this.rules[53].opcodes[2] = {
        type: 5,
        min: 97,
        max: 122
    },
    this.rules[53].opcodes[3] = {
        type: 5,
        min: 65,
        max: 90
    },
    this.rules[53].opcodes[4] = {
        type: 5,
        min: 48,
        max: 57
    },
    this.rules[53].opcodes[5] = {
        type: 4,
        index: 63
    },
    this.rules[53].opcodes[6] = {
        type: 6,
        string: [33]
    },
    this.rules[53].opcodes[7] = {
        type: 6,
        string: [36]
    },
    this.rules[53].opcodes[8] = {
        type: 5,
        min: 38,
        max: 46
    },
    this.rules[53].opcodes[9] = {
        type: 5,
        min: 58,
        max: 59
    },
    this.rules[53].opcodes[10] = {
        type: 6,
        string: [61]
    },
    this.rules[53].opcodes[11] = {
        type: 6,
        string: [95]
    },
    this.rules[53].opcodes[12] = {
        type: 6,
        string: [126]
    },
    this.rules[54].opcodes = [],
    this.rules[54].opcodes[0] = {
        type: 1,
        children: [1, 2, 6]
    },
    this.rules[54].opcodes[1] = {
        type: 4,
        index: 30
    },
    this.rules[54].opcodes[2] = {
        type: 2,
        children: [3, 4]
    },
    this.rules[54].opcodes[3] = {
        type: 4,
        index: 39
    },
    this.rules[54].opcodes[4] = {
        type: 13
    },
    this.rules[54].opcodes[5] = {
        type: 4,
        index: 43
    },
    this.rules[54].opcodes[6] = {
        type: 4,
        index: 42
    },
    this.rules[55].opcodes = [],
    this.rules[55].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[55].opcodes[1] = {
        type: 4,
        index: 79
    },
    this.rules[56].opcodes = [],
    this.rules[56].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[56].opcodes[1] = {
        type: 2,
        children: [2, 3]
    },
    this.rules[56].opcodes[2] = {
        type: 7,
        string: [47]
    },
    this.rules[56].opcodes[3] = {
        type: 4,
        index: 60
    },
    this.rules[57].opcodes = [],
    this.rules[57].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[57].opcodes[1] = {
        type: 7,
        string: [47]
    },
    this.rules[57].opcodes[2] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[57].opcodes[3] = {
        type: 2,
        children: [4, 5]
    },
    this.rules[57].opcodes[4] = {
        type: 4,
        index: 61
    },
    this.rules[57].opcodes[5] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[57].opcodes[6] = {
        type: 2,
        children: [7, 8]
    },
    this.rules[57].opcodes[7] = {
        type: 7,
        string: [47]
    },
    this.rules[57].opcodes[8] = {
        type: 4,
        index: 60
    },
    this.rules[58].opcodes = [],
    this.rules[58].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[58].opcodes[1] = {
        type: 4,
        index: 61
    },
    this.rules[58].opcodes[2] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[58].opcodes[3] = {
        type: 2,
        children: [4, 5]
    },
    this.rules[58].opcodes[4] = {
        type: 7,
        string: [47]
    },
    this.rules[58].opcodes[5] = {
        type: 4,
        index: 60
    },
    this.rules[59].opcodes = [],
    this.rules[59].opcodes[0] = {
        type: 7,
        string: []
    },
    this.rules[60].opcodes = [],
    this.rules[60].opcodes[0] = {
        type: 3,
        min: 0,
        max: 1 / 0
    },
    this.rules[60].opcodes[1] = {
        type: 4,
        index: 62
    },
    this.rules[61].opcodes = [],
    this.rules[61].opcodes[0] = {
        type: 3,
        min: 1,
        max: 1 / 0
    },
    this.rules[61].opcodes[1] = {
        type: 4,
        index: 62
    },
    this.rules[62].opcodes = [],
    this.rules[62].opcodes[0] = {
        type: 1,
        children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
    },
    this.rules[62].opcodes[1] = {
        type: 5,
        min: 97,
        max: 122
    },
    this.rules[62].opcodes[2] = {
        type: 5,
        min: 65,
        max: 90
    },
    this.rules[62].opcodes[3] = {
        type: 5,
        min: 48,
        max: 57
    },
    this.rules[62].opcodes[4] = {
        type: 4,
        index: 63
    },
    this.rules[62].opcodes[5] = {
        type: 6,
        string: [33]
    },
    this.rules[62].opcodes[6] = {
        type: 6,
        string: [36]
    },
    this.rules[62].opcodes[7] = {
        type: 5,
        min: 38,
        max: 46
    },
    this.rules[62].opcodes[8] = {
        type: 5,
        min: 58,
        max: 59
    },
    this.rules[62].opcodes[9] = {
        type: 6,
        string: [61]
    },
    this.rules[62].opcodes[10] = {
        type: 6,
        string: [64]
    },
    this.rules[62].opcodes[11] = {
        type: 6,
        string: [95]
    },
    this.rules[62].opcodes[12] = {
        type: 6,
        string: [126]
    },
    this.rules[63].opcodes = [],
    this.rules[63].opcodes[0] = {
        type: 2,
        children: [1, 2, 3]
    },
    this.rules[63].opcodes[1] = {
        type: 6,
        string: [37]
    },
    this.rules[63].opcodes[2] = {
        type: 4,
        index: 80
    },
    this.rules[63].opcodes[3] = {
        type: 4,
        index: 80
    },
    this.rules[64].opcodes = [],
    this.rules[64].opcodes[0] = {
        type: 3,
        min: 4,
        max: 4
    },
    this.rules[64].opcodes[1] = {
        type: 4,
        index: 79
    },
    this.rules[65].opcodes = [],
    this.rules[65].opcodes[0] = {
        type: 3,
        min: 2,
        max: 2
    },
    this.rules[65].opcodes[1] = {
        type: 4,
        index: 79
    },
    this.rules[66].opcodes = [],
    this.rules[66].opcodes[0] = {
        type: 3,
        min: 2,
        max: 2
    },
    this.rules[66].opcodes[1] = {
        type: 4,
        index: 79
    },
    this.rules[67].opcodes = [],
    this.rules[67].opcodes[0] = {
        type: 3,
        min: 2,
        max: 2
    },
    this.rules[67].opcodes[1] = {
        type: 4,
        index: 79
    },
    this.rules[68].opcodes = [],
    this.rules[68].opcodes[0] = {
        type: 3,
        min: 2,
        max: 2
    },
    this.rules[68].opcodes[1] = {
        type: 4,
        index: 79
    },
    this.rules[69].opcodes = [],
    this.rules[69].opcodes[0] = {
        type: 3,
        min: 2,
        max: 2
    },
    this.rules[69].opcodes[1] = {
        type: 4,
        index: 79
    },
    this.rules[70].opcodes = [],
    this.rules[70].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[70].opcodes[1] = {
        type: 7,
        string: [46]
    },
    this.rules[70].opcodes[2] = {
        type: 3,
        min: 1,
        max: 1 / 0
    },
    this.rules[70].opcodes[3] = {
        type: 4,
        index: 79
    },
    this.rules[71].opcodes = [],
    this.rules[71].opcodes[0] = {
        type: 2,
        children: [1, 4, 5, 6]
    },
    this.rules[71].opcodes[1] = {
        type: 1,
        children: [2, 3]
    },
    this.rules[71].opcodes[2] = {
        type: 7,
        string: [43]
    },
    this.rules[71].opcodes[3] = {
        type: 7,
        string: [45]
    },
    this.rules[71].opcodes[4] = {
        type: 4,
        index: 67
    },
    this.rules[71].opcodes[5] = {
        type: 7,
        string: [58]
    },
    this.rules[71].opcodes[6] = {
        type: 4,
        index: 68
    },
    this.rules[72].opcodes = [],
    this.rules[72].opcodes[0] = {
        type: 1,
        children: [1, 2]
    },
    this.rules[72].opcodes[1] = {
        type: 7,
        string: [122]
    },
    this.rules[72].opcodes[2] = {
        type: 4,
        index: 71
    },
    this.rules[73].opcodes = [],
    this.rules[73].opcodes[0] = {
        type: 2,
        children: [1, 2, 3, 4, 5, 6]
    },
    this.rules[73].opcodes[1] = {
        type: 4,
        index: 67
    },
    this.rules[73].opcodes[2] = {
        type: 7,
        string: [58]
    },
    this.rules[73].opcodes[3] = {
        type: 4,
        index: 68
    },
    this.rules[73].opcodes[4] = {
        type: 7,
        string: [58]
    },
    this.rules[73].opcodes[5] = {
        type: 4,
        index: 69
    },
    this.rules[73].opcodes[6] = {
        type: 3,
        min: 0,
        max: 1
    },
    this.rules[73].opcodes[7] = {
        type: 4,
        index: 70
    },
    this.rules[74].opcodes = [],
    this.rules[74].opcodes[0] = {
        type: 2,
        children: [1, 2, 3, 4, 5]
    },
    this.rules[74].opcodes[1] = {
        type: 4,
        index: 64
    },
    this.rules[74].opcodes[2] = {
        type: 7,
        string: [45]
    },
    this.rules[74].opcodes[3] = {
        type: 4,
        index: 65
    },
    this.rules[74].opcodes[4] = {
        type: 7,
        string: [45]
    },
    this.rules[74].opcodes[5] = {
        type: 4,
        index: 66
    },
    this.rules[75].opcodes = [],
    this.rules[75].opcodes[0] = {
        type: 2,
        children: [1, 2]
    },
    this.rules[75].opcodes[1] = {
        type: 4,
        index: 73
    },
    this.rules[75].opcodes[2] = {
        type: 4,
        index: 72
    },
    this.rules[76].opcodes = [],
    this.rules[76].opcodes[0] = {
        type: 2,
        children: [1, 2, 3]
    },
    this.rules[76].opcodes[1] = {
        type: 4,
        index: 74
    },
    this.rules[76].opcodes[2] = {
        type: 7,
        string: [116]
    },
    this.rules[76].opcodes[3] = {
        type: 4,
        index: 75
    },
    this.rules[77].opcodes = [],
    this.rules[77].opcodes[0] = {
        type: 1,
        children: [1, 2]
    },
    this.rules[77].opcodes[1] = {
        type: 5,
        min: 65,
        max: 90
    },
    this.rules[77].opcodes[2] = {
        type: 5,
        min: 97,
        max: 122
    },
    this.rules[78].opcodes = [],
    this.rules[78].opcodes[0] = {
        type: 6,
        string: [10]
    },
    this.rules[79].opcodes = [],
    this.rules[79].opcodes[0] = {
        type: 5,
        min: 48,
        max: 57
    },
    this.rules[80].opcodes = [],
    this.rules[80].opcodes[0] = {
        type: 1,
        children: [1, 2, 3]
    },
    this.rules[80].opcodes[1] = {
        type: 5,
        min: 48,
        max: 57
    },
    this.rules[80].opcodes[2] = {
        type: 5,
        min: 65,
        max: 70
    },
    this.rules[80].opcodes[3] = {
        type: 5,
        min: 97,
        max: 102
    },
    this.toString = function() {
        let t = "";
        return t += `; LDT 05/06/2024 
`,
        t += `; modified in several significant ways
`,
        t += `; 1) Literal strings are replaced with numbers and ranges (%d32 & %d32-126, etc.) when possible.
`,
        t += `;    TRB and especially TRG operators are much more efficient than TLS operators.
`,
        t += `; 2) Two rules, authority and URI, are used multiple times in different contexts. These rules will be reproduced and renamed
`,
        t += `;    in order to a) recognize the context and b) remove unneccary callback functions for certain contexts.
`,
        t += `;    This will simiplify recognizing contexts AND remove unneccesary callbacks
`,
        t += `; 2.a) domain is defined as authority-d which is identical to authority except that there will be no
`,
        t += `;      callback functions defined on authority-d or any of its *-d components.
`,
        t += `; 2.b) The resource URI is defined as URI-r and its components defined as *-r.
`,
        t += `;      In this way, callback functions can be defined on URI and is components while
`,
        t += `;      leaving URI-r to be parsed identically with no unnecessary callback functions to slow it down.
`,
        t += `; 3) IPv6address does not work because of APG's "first-success disambiguation" and "greedy" repetitions.
`,
        t += `;    IPv6address redefined and validations moved to callback functions (semantic vs syntactic validation)
`,
        t += `;    Redefinition requires negative look-ahead operators, https://en.wikipedia.org/wiki/Syntactic_predicate
`,
        t += `;    That is SABNF instead of simple ABNF.
`,
        t += `; 4) IPv4address fails because of "first-success disambiguation".
`,
        t += `;    This could be fixed with rearrangement of the alternative terms. However, it would still not
`,
        t += `;    accept zero-padded (leading zeros) decimal octets.
`,
        t += `;    Therefore, IPv4address is also done with callback functions and semantic validation.
`,
        t += `; 5) The negative look-ahead operator is also needed in the definition of host to
`,
        t += `;    prevent failure with a reg-name that begins with an IPv4 address.
`,
        t += `; 6) NOTE: host = 1.1.1.256 is a valid host name even though it is an invalid IPv4address.
`,
        t += `;          The IPv4address alternative fails but the reg-name alternative succeeds.
`,
        t += `; 7) The Ethereum spec (https://eips.ethereum.org/EIPS/eip-4361) message format ABNF
`,
        t += `;    allows for empty statements. Because of the "first success disambiguation" of APG
`,
        t += `;    the an explicit "empty-statement" rule is required to match the spec's intent.
`,
        t += `
`,
        t += `
`,
        t += `sign-in-with-ethereum =
`,
        t += `    oscheme domain %s" wants you to sign in with your Ethereum account:" LF
`,
        t += `    address LF
`,
        t += `    ((LF statement LF LF) / empty-statement / (LF LF))
`,
        t += `    %s"URI: " URI LF
`,
        t += `    %s"Version: " version LF
`,
        t += `    %s"Chain ID: " chain-id LF
`,
        t += `    %s"Nonce: " nonce LF
`,
        t += `    %s"Issued At: " issued-at
`,
        t += `    [ LF ex-title expiration-time ]
`,
        t += `    [ LF nb-title not-before ]
`,
        t += `    [ LF ri-title request-id ]
`,
        t += `    [ LF re-title resources ]
`,
        t += `ex-title        = %s"Expiration Time: "
`,
        t += `nb-title        = %s"Not Before: "
`,
        t += `ri-title        = %s"Request ID: "
`,
        t += `re-title        = %s"Resources:"
`,
        t += `oscheme         = [ ALPHA *( ALPHA / DIGIT / %d43 / %d45-46 ) "://" ]
`,
        t += `domain          = authority-d
`,
        t += `address         = "0x" 40*40HEXDIG
`,
        t += `    ; Must also conform to captilization
`,
        t += `    ; checksum encoding specified in EIP-55
`,
        t += `    ; where applicable (EOAs).
`,
        t += `
`,
        t += `statement       = 1*( %d97-122 / %d65-90 / %d48-57 / %d32-33 / %d35-36 / %d38-59 / %d61 / %d63-64 / %d91 / %d93 / %d95 / %d126)
`,
        t += `    ; The purpose is to exclude LF (line breaks).
`,
        t += `    ; LDT 10/04/2023: Do you mean %d32-126? All printing characters
`,
        t += `empty-statement = LF LF LF
`,
        t += `version         = "1"
`,
        t += `nonce           = 8*( ALPHA / DIGIT )
`,
        t += `issued-at       = date-time
`,
        t += `expiration-time = date-time
`,
        t += `not-before      = date-time
`,
        t += `request-id      = *pchar
`,
        t += `chain-id        = 1*DIGIT
`,
        t += `    ; See EIP-155 for valid CHAIN_IDs.
`,
        t += `resources       = *( LF resource )
`,
        t += `resource        = "- " URI-r
`,
        t += `
`,
        t += `; ------------------------------------------------------------------------------
`,
        t += `; RFC 3986
`,
        t += `
`,
        t += `URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
`,
        t += `hier-part     = "//" authority path-abempty
`,
        t += `              / path-absolute
`,
        t += `              / path-rootless
`,
        t += `              / path-empty
`,
        t += `scheme        = ALPHA *( ALPHA / DIGIT / %d43 / %d45-46 )
`,
        t += `authority     = [ userinfo-at ] host [ ":" port ]
`,
        t += `path-abempty  = *( "/" segment )
`,
        t += `path-absolute = "/" [ segment-nz *( "/" segment ) ]
`,
        t += `path-rootless = segment-nz *( "/" segment )
`,
        t += `path-empty    = ""
`,
        t += `userinfo-at   = userinfo %d64
`,
        t += `                ; userinfo redefined to include the "@" so that it will fail without it
`,
        t += `                ; otherwise userinfo can match host and then the parser will backtrack
`,
        t += `                ; incorrectly keeping the captured userinfo phrase
`,
        t += `userinfo      = *(%d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 / %d58-59 / %d61 / %d95 / %d126)
`,
        t += `host          = IP-literal / (IPv4address !reg-name-char) / reg-name
`,
        t += `                ; negative look-ahead required to prevent IPv4address from being recognized as first part of reg-name
`,
        t += `                ; same fix as https://github.com/garycourt/uri-js/issues/4
`,
        t += `IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"
`,
        t += `IPvFuture     = "v" 1*HEXDIG "." 1*( %d97-122 / %d65-90 / %d48-57 / %d33 / %d36 /%d38-46 / %d58-59 /%d61 /%d95 / %d126 )
`,
        t += `IPv6address   = nodcolon / dcolon
`,
        t += `nodcolon      = (h16n *h16cn) [%d58 IPv4address]
`,
        t += `dcolon        = [h16 *h16c] %d58.58 (((h16n *h16cn) [%d58 IPv4address]) / [IPv4address])
`,
        t += `h16           = 1*4HEXDIG
`,
        t += `h16c          = %d58 1*4HEXDIG
`,
        t += `h16n          = 1*4HEXDIG !%d46
`,
        t += `h16cn         = %d58 1*4HEXDIG !%d46
`,
        t += `IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
`,
        t += `; Here we will will use callback functions to evaluate and validate the (possibly zero-padded) dec-octet.
`,
        t += `dec-octet     =  *3dec-digit
`,
        t += `dec-digit     = %d48-57
`,
        t += `reg-name      = *reg-name-char
`,
        t += `reg-name-char = %d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 / %d59 / %d61 /%d95 / %d126
`,
        t += `port          = *DIGIT
`,
        t += `query         = *(pchar / %d47 / %d63)
`,
        t += `fragment      = *(pchar / %d47 / %d63)
`,
        t += `
`,
        t += `; URI-r is a redefiniton of URI but without the callback functions attached to it
`,
        t += `; it reuses athority-d from domain 
`,
        t += `URI-r         = scheme-r ":" hier-part-r [ "?" query-r ] [ "#" fragment-r ]
`,
        t += `hier-part-r   = "//" authority-d path-abempty-r
`,
        t += `              / path-absolute-r
`,
        t += `              / path-rootless-r
`,
        t += `              / path-empty-r
`,
        t += `scheme-r      = ALPHA *( ALPHA / DIGIT / %d43 / %d45-46 )
`,
        t += `query-r       = *(pchar / %d47 / %d63)
`,
        t += `fragment-r    = *(pchar / %d47 / %d63)
`,
        t += `
`,
        t += `; authority-d is a redefinition of authority for capturing the domian phrase
`,
        t += `; but without callback functions 
`,
        t += `; it is reused for URI- for the same reason               
`,
        t += `authority-d   = [ userinfo-d %d64 ] host-d [ ":" port-d ]
`,
        t += `userinfo-d    = *(%d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 / %d58-59 / %d61 / %d95 / %d126)
`,
        t += `host-d        = IP-literal / (IPv4address !reg-name-char) / reg-name
`,
        t += `port-d        = *DIGIT
`,
        t += `
`,
        t += `; for use with URI-r
`,
        t += `path-abempty-r  = *( "/" segment )
`,
        t += `path-absolute-r = "/" [ segment-nz *( "/" segment ) ]
`,
        t += `path-rootless-r = segment-nz *( "/" segment )
`,
        t += `path-empty-r    = ""
`,
        t += `segment       = *pchar
`,
        t += `segment-nz    = 1*pchar
`,
        t += `pchar         = (%d97-122 / %d65-90 / %d48-57 / pct-encoded / %d33 / %d36 / %d38-46 /%d58-59 / %d61 / %d64 / %d95 / %d126)
`,
        t += `pct-encoded   = %d37 HEXDIG HEXDIG
`,
        t += `
`,
        t += `; no longer needed - expanded for all usage for fewer branches in the parse there
`,
        t += `; and more efficient use of the TBS & TRG operators in place of TLS and rule names
`,
        t += `; does not work with APG probably because of "first-success disambiguation" and greedy repetitions.
`,
        t += `; will replace with semantic checking of valid number of h16s
`,
        t += `;IPv6address   =                            6( h16 ":" ) ls32
`,
        t += `;              /                       "::" 5( h16 ":" ) ls32
`,
        t += `;              / [               h16 ] "::" 4( h16 ":" ) ls32
`,
        t += `;              / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
`,
        t += `;              / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
`,
        t += `;              / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
`,
        t += `;              / [ *4( h16 ":" ) h16 ] "::"              ls32
`,
        t += `;              / [ *5( h16 ":" ) h16 ] "::"              h16
`,
        t += `;              / [ *6( h16 ":" ) h16 ] "::"
`,
        t += `;ls32          = ( h16 ":" h16 ) / IPv4address
`,
        t += `; dec-octet does not work because of "first-success disambiguation".
`,
        t += `; Must have the longest (3-digit) numbers first.
`,
        t += `; Even so, this form does not accept leading zeros.
`,
        t += `; There does not seem to be a clear standard for this (https://en.wikipedia.org/wiki/Dot-decimal_notation)
`,
        t += `; however and early RFC 790 did show leading-zero padding of the three digits.
`,
        t += `;dec-octet     = DIGIT                 ; 0-9
`,
        t += `;                 / %x31-39 DIGIT         ; 10-99
`,
        t += `;                 / "1" 2DIGIT            ; 100-199
`,
        t += `;                 / "2" %x30-34 DIGIT     ; 200-249
`,
        t += `;                 / "25" %x30-35          ; 250-255
`,
        t += `;statement = 1*( reserved / unreserved / " " )
`,
        t += `;scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
`,
        t += `;authority     = [ userinfo "@" ] host [ ":" port ]
`,
        t += `;userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
`,
        t += `;query         = *( pchar / "/" / "?" )
`,
        t += `;fragment      = *( pchar / "/" / "?" )
`,
        t += `;IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
`,
        t += `;reg-name      = *( unreserved / pct-encoded / sub-delims )
`,
        t += `;pct-encoded   = "%" HEXDIG HEXDIG
`,
        t += `;pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
`,
        t += `;path-empty    = 0pchar; deprecated - empty literal string, "", is more efficient 
`,
        t += `;unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
`,
        t += `;reserved      = gen-delims / sub-delims
`,
        t += `;gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
`,
        t += `;sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
`,
        t += `;              / "*" / "+" / "," / ";" / "="
`,
        t += `;HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
`,
        t += `
`,
        t += `; ------------------------------------------------------------------------------
`,
        t += `; RFC 3339
`,
        t += `
`,
        t += `date-fullyear   = 4DIGIT
`,
        t += `date-month      = 2DIGIT  ; 01-12
`,
        t += `date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
`,
        t += `                          ; month/year
`,
        t += `time-hour       = 2DIGIT  ; 00-23
`,
        t += `time-minute     = 2DIGIT  ; 00-59
`,
        t += `time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
`,
        t += `                          ; rules
`,
        t += `time-secfrac    = "." 1*DIGIT
`,
        t += `time-numoffset  = ("+" / "-") time-hour ":" time-minute
`,
        t += `time-offset     = "Z" / time-numoffset
`,
        t += `
`,
        t += `partial-time    = time-hour ":" time-minute ":" time-second
`,
        t += `                  [time-secfrac]
`,
        t += `full-date       = date-fullyear "-" date-month "-" date-mday
`,
        t += `full-time       = partial-time time-offset
`,
        t += `
`,
        t += `date-time       = full-date "T" full-time
`,
        t += `
`,
        t += `; ------------------------------------------------------------------------------
`,
        t += `; RFC 5234
`,
        t += `
`,
        t += `ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
`,
        t += `LF             =  %x0A
`,
        t += `                  ; linefeed
`,
        t += `DIGIT          =  %x30-39
`,
        t += `                  ; 0-9
`,
        t += `HEXDIG         = %d48-57 / %d65-70 / %d97-102
`,
        t += `
`,
        t
    }
}
ks.grammar = Zl;
var _s = {}
  , jr = {
    ALT: 1,
    CAT: 2,
    REP: 3,
    RNM: 4,
    TRG: 5,
    TBS: 6,
    TLS: 7,
    UDT: 11,
    AND: 12,
    NOT: 13,
    BKR: 14,
    BKA: 15,
    BKN: 16,
    ABG: 17,
    AEN: 18,
    ACTIVE: 100,
    MATCH: 101,
    EMPTY: 102,
    NOMATCH: 103,
    SEM_PRE: 200,
    SEM_POST: 201,
    SEM_OK: 300,
    SEM_SKIP: 301,
    ATTR_N: 400,
    ATTR_R: 401,
    ATTR_MR: 402,
    LOOKAROUND_NONE: 500,
    LOOKAROUND_AHEAD: 501,
    LOOKAROUND_BEHIND: 502,
    BKR_MODE_UM: 601,
    BKR_MODE_PM: 602,
    BKR_MODE_CS: 603,
    BKR_MODE_CI: 604
}
  , Mr = {}
  , Ts = {
    CLASS_MONOSPACE: "apg-mono",
    CLASS_ACTIVE: "apg-active",
    CLASS_EMPTY: "apg-empty",
    CLASS_MATCH: "apg-match",
    CLASS_NOMATCH: "apg-nomatch",
    CLASS_LOOKAHEAD: "apg-lh-match",
    CLASS_LOOKBEHIND: "apg-lb-match",
    CLASS_REMAINDER: "apg-remainder",
    CLASS_CTRLCHAR: "apg-ctrl-char",
    CLASS_LINEEND: "apg-line-end",
    CLASS_ERROR: "apg-error",
    CLASS_PHRASE: "apg-phrase",
    CLASS_EMPTYPHRASE: "apg-empty-phrase",
    CLASS_STATE: "apg-state",
    CLASS_STATS: "apg-stats",
    CLASS_TRACE: "apg-trace",
    CLASS_GRAMMAR: "apg-grammar",
    CLASS_RULES: "apg-rules",
    CLASS_RULESLINK: "apg-rules-link",
    CLASS_ATTRIBUTES: "apg-attrs"
}
  , cu = {}
  , uu = {};
(function(e) {
    "use strict;";
    const {Buffer: t} = ou
      , s = 4294967292
      , r = 4294967293
      , n = 4294967294
      , d = 4294967295
      , h = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023]
      , m = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF", "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF", "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF", "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF", "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"]
      , f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("")
      , i = [];
    f.forEach(o => {
        i.push(o.charCodeAt(0))
    }
    ),
    e.utf8 = {
        encode(o) {
            const c = [];
            return o.forEach(u => {
                if (u >= 0 && u <= 127)
                    c.push(u);
                else if (u <= 2047)
                    c.push(192 + (u >> 6 & h[5])),
                    c.push(128 + (u & h[6]));
                else if (u < 55296 || u > 57343 && u <= 65535)
                    c.push(224 + (u >> 12 & h[4])),
                    c.push(128 + (u >> 6 & h[6])),
                    c.push(128 + (u & h[6]));
                else if (u >= 65536 && u <= 1114111) {
                    const g = u >> 16 & h[5];
                    c.push(240 + (g >> 2)),
                    c.push(128 + ((g & h[2]) << 4) + (u >> 12 & h[4])),
                    c.push(128 + (u >> 6 & h[6])),
                    c.push(128 + (u & h[6]))
                } else
                    throw new RangeError(`utf8.encode: character out of range: char: ${u}`)
            }
            ),
            t.from(c)
        },
        decode(o, c) {
            function u(N, A) {
                if ((A & 192) !== 128)
                    return r;
                const R = ((N & h[5]) << 6) + (A & h[6]);
                return R < 128 ? s : R
            }
            function g(N, A, R) {
                if ((R & 192) !== 128 || (A & 192) !== 128)
                    return r;
                const y = ((N & h[4]) << 12) + ((A & h[6]) << 6) + (R & h[6]);
                return y < 2048 ? s : y >= 55296 && y <= 57343 ? n : y
            }
            function P(N, A, R, y) {
                if ((y & 192) !== 128 || (R & 192) !== 128 || (A & 192) !== 128)
                    return r;
                const k = (((N & h[3]) << 2) + (A >> 4 & h[2]) << 16) + ((A & h[4]) << 12) + ((R & h[6]) << 6) + (y & h[6]);
                return k < 65536 ? s : k > 1114111 ? n : k
            }
            let v, b, x, a, E, w;
            const S = o.length;
            let T = c ? 3 : 0;
            const C = [];
            for (; T < S; ) {
                b = o[T],
                v = d;
                const N = !0;
                for (; N; ) {
                    if (b >= 0 && b <= 127) {
                        v = b,
                        w = 1;
                        break
                    }
                    if (x = T + 1,
                    x < S && b >= 194 && b <= 223) {
                        v = u(b, o[x]),
                        w = 2;
                        break
                    }
                    if (a = T + 2,
                    a < S && b >= 224 && b <= 239) {
                        v = g(b, o[x], o[a]),
                        w = 3;
                        break
                    }
                    if (E = T + 3,
                    E < S && b >= 240 && b <= 244) {
                        v = P(b, o[x], o[a], o[E]),
                        w = 4;
                        break
                    }
                    break
                }
                if (v > 1114111) {
                    const A = `byte[${T}]`;
                    throw v === d ? new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${A}`) : v === r ? new RangeError(`utf8.decode: illegal trailing byte found at: ${A}`) : v === n ? new RangeError(`utf8.decode: code point out of range found at: ${A}`) : v === s ? new RangeError(`utf8.decode: non-shortest form found at: ${A}`) : new RangeError(`utf8.decode: unrecognized error found at: ${A}`)
                }
                C.push(v),
                T += w
            }
            return C
        }
    },
    e.utf16be = {
        encode(o) {
            const c = [];
            let u, g, P;
            for (let v = 0; v < o.length; v += 1)
                if (u = o[v],
                u >= 0 && u <= 55295 || u >= 57344 && u <= 65535)
                    c.push(u >> 8 & h[8]),
                    c.push(u & h[8]);
                else if (u >= 65536 && u <= 1114111)
                    P = u - 65536,
                    g = 55296 + (P >> 10),
                    P = 56320 + (P & h[10]),
                    c.push(g >> 8 & h[8]),
                    c.push(g & h[8]),
                    c.push(P >> 8 & h[8]),
                    c.push(P & h[8]);
                else
                    throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${v}]: ${u}`);
            return t.from(c)
        },
        decode(o, c) {
            if (o.length % 2 > 0)
                throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${o.length}`);
            const u = []
              , g = o.length;
            let P = c ? 2 : 0, v = 0, b, x, a, E, w, S;
            for (; P < g; ) {
                for (; ; ) {
                    if (a = P + 1,
                    a < g) {
                        if (w = (o[P] << 8) + o[a],
                        w < 55296 || w > 57343) {
                            b = w,
                            x = 2;
                            break
                        }
                        if (E = P + 3,
                        E < g && (S = (o[P + 2] << 8) + o[E],
                        w <= 56319 && S >= 56320 && S <= 57343)) {
                            b = 65536 + (w - 55296 << 10) + (S - 56320),
                            x = 4;
                            break
                        }
                    }
                    throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${P}]`)
                }
                u[v++] = b,
                P += x
            }
            return u
        }
    },
    e.utf16le = {
        encode(o) {
            const c = [];
            let u, g, P;
            for (let v = 0; v < o.length; v += 1)
                if (u = o[v],
                u >= 0 && u <= 55295 || u >= 57344 && u <= 65535)
                    c.push(u & h[8]),
                    c.push(u >> 8 & h[8]);
                else if (u >= 65536 && u <= 1114111)
                    P = u - 65536,
                    g = 55296 + (P >> 10),
                    P = 56320 + (P & h[10]),
                    c.push(g & h[8]),
                    c.push(g >> 8 & h[8]),
                    c.push(P & h[8]),
                    c.push(P >> 8 & h[8]);
                else
                    throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${v}]: ${u}`);
            return t.from(c)
        },
        decode(o, c) {
            if (o.length % 2 > 0)
                throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${o.length}`);
            const u = []
              , g = o.length;
            let P = c ? 2 : 0, v = 0, b, x, a, E, w, S;
            for (; P < g; ) {
                for (; ; ) {
                    if (a = P + 1,
                    a < g) {
                        if (w = (o[a] << 8) + o[P],
                        w < 55296 || w > 57343) {
                            b = w,
                            x = 2;
                            break
                        }
                        if (E = P + 3,
                        E < g && (S = (o[E] << 8) + o[P + 2],
                        w <= 56319 && S >= 56320 && S <= 57343)) {
                            b = 65536 + (w - 55296 << 10) + (S - 56320),
                            x = 4;
                            break
                        }
                    }
                    throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${P}]`)
                }
                u[v++] = b,
                P += x
            }
            return u
        }
    },
    e.utf32be = {
        encode(o) {
            const c = t.alloc(o.length * 4);
            let u = 0;
            return o.forEach(g => {
                if (g >= 55296 && g <= 57343 || g > 1114111)
                    throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${u / 4}]: ${g}`);
                c[u++] = g >> 24 & h[8],
                c[u++] = g >> 16 & h[8],
                c[u++] = g >> 8 & h[8],
                c[u++] = g & h[8]
            }
            ),
            c
        },
        decode(o, c) {
            if (o.length % 4 > 0)
                throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${o.length}`);
            const u = [];
            let g = c ? 4 : 0;
            for (; g < o.length; g += 4) {
                const P = (o[g] << 24) + (o[g + 1] << 16) + (o[g + 2] << 8) + o[g + 3];
                if (P >= 55296 && P <= 57343 || P > 1114111)
                    throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${g / 4}]: ${P}`);
                u.push(P)
            }
            return u
        }
    },
    e.utf32le = {
        encode(o) {
            const c = t.alloc(o.length * 4);
            let u = 0;
            return o.forEach(g => {
                if (g >= 55296 && g <= 57343 || g > 1114111)
                    throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${u / 4}]: ${g}`);
                c[u++] = g & h[8],
                c[u++] = g >> 8 & h[8],
                c[u++] = g >> 16 & h[8],
                c[u++] = g >> 24 & h[8]
            }
            ),
            c
        },
        decode(o, c) {
            if (o.length % 4 > 0)
                throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${o.length}`);
            const u = [];
            let g = c ? 4 : 0;
            for (; g < o.length; g += 4) {
                const P = (o[g + 3] << 24) + (o[g + 2] << 16) + (o[g + 1] << 8) + o[g];
                if (P >= 55296 && P <= 57343 || P > 1114111)
                    throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${g / 4}]: ${P}`);
                u.push(P)
            }
            return u
        }
    },
    e.uint7 = {
        encode(o) {
            const c = t.alloc(o.length);
            for (let u = 0; u < o.length; u += 1) {
                if (o[u] > 127)
                    throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${u}]: ${o[u]}`);
                c[u] = o[u]
            }
            return c
        },
        decode(o) {
            const c = [];
            for (let u = 0; u < o.length; u += 1) {
                if (o[u] > 127)
                    throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${u}]: ${o[u]}`);
                c[u] = o[u]
            }
            return c
        }
    },
    e.uint8 = {
        encode(o) {
            const c = t.alloc(o.length);
            for (let u = 0; u < o.length; u += 1) {
                if (o[u] > 255)
                    throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${u}]: ${o[u]}`);
                c[u] = o[u]
            }
            return c
        },
        decode(o) {
            const c = [];
            for (let u = 0; u < o.length; u += 1)
                c[u] = o[u];
            return c
        }
    },
    e.uint16be = {
        encode(o) {
            const c = t.alloc(o.length * 2);
            let u = 0;
            return o.forEach(g => {
                if (g > 65535)
                    throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${u / 2}]: ${g}`);
                c[u++] = g >> 8 & h[8],
                c[u++] = g & h[8]
            }
            ),
            c
        },
        decode(o) {
            if (o.length % 2 > 0)
                throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${o.length}`);
            const c = [];
            for (let u = 0; u < o.length; u += 2)
                c.push((o[u] << 8) + o[u + 1]);
            return c
        }
    },
    e.uint16le = {
        encode(o) {
            const c = t.alloc(o.length * 2);
            let u = 0;
            return o.forEach(g => {
                if (g > 65535)
                    throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${u / 2}]: ${g}`);
                c[u++] = g & h[8],
                c[u++] = g >> 8 & h[8]
            }
            ),
            c
        },
        decode(o) {
            if (o.length % 2 > 0)
                throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${o.length}`);
            const c = [];
            for (let u = 0; u < o.length; u += 2)
                c.push((o[u + 1] << 8) + o[u]);
            return c
        }
    },
    e.uint32be = {
        encode(o) {
            const c = t.alloc(o.length * 4);
            let u = 0;
            return o.forEach(g => {
                c[u++] = g >> 24 & h[8],
                c[u++] = g >> 16 & h[8],
                c[u++] = g >> 8 & h[8],
                c[u++] = g & h[8]
            }
            ),
            c
        },
        decode(o) {
            if (o.length % 4 > 0)
                throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${o.length}`);
            const c = [];
            for (let u = 0; u < o.length; u += 4)
                c.push((o[u] << 24) + (o[u + 1] << 16) + (o[u + 2] << 8) + o[u + 3]);
            return c
        }
    },
    e.uint32le = {
        encode(o) {
            const c = t.alloc(o.length * 4);
            let u = 0;
            return o.forEach(g => {
                c[u++] = g & h[8],
                c[u++] = g >> 8 & h[8],
                c[u++] = g >> 16 & h[8],
                c[u++] = g >> 24 & h[8]
            }
            ),
            c
        },
        decode(o) {
            if (o.length % 4 > 0)
                throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${o.length}`);
            const c = [];
            for (let u = 0; u < o.length; u += 4)
                c.push((o[u + 3] << 24) + (o[u + 2] << 16) + (o[u + 1] << 8) + o[u]);
            return c
        }
    },
    e.string = {
        encode(o) {
            return e.utf16le.encode(o).toString("utf16le")
        },
        decode(o) {
            return e.utf16le.decode(t.from(o, "utf16le"), 0)
        }
    },
    e.escaped = {
        encode(o) {
            const c = [];
            for (let u = 0; u < o.length; u += 1) {
                const g = o[u];
                if (g === 96)
                    c.push(g),
                    c.push(g);
                else if (g === 10)
                    c.push(g);
                else if (g >= 32 && g <= 126)
                    c.push(g);
                else {
                    let P = "";
                    if (g >= 0 && g <= 31)
                        P += `\`x${m[g]}`;
                    else if (g >= 127 && g <= 255)
                        P += `\`x${m[g]}`;
                    else if (g >= 256 && g <= 65535)
                        P += `\`u${m[g >> 8 & h[8]]}${m[g & h[8]]}`;
                    else if (g >= 65536 && g <= 4294967295) {
                        P += "`u{";
                        const b = g >> 24 & h[8];
                        b > 0 && (P += m[b]),
                        P += `${m[g >> 16 & h[8]] + m[g >> 8 & h[8]] + m[g & h[8]]}}`
                    } else
                        throw new Error("escape.encode(char): char > 0xffffffff not allowed");
                    t.from(P).forEach(b => {
                        c.push(b)
                    }
                    )
                }
            }
            return t.from(c)
        },
        decode(o) {
            function c(S) {
                return S >= 48 && S <= 57 || S >= 65 && S <= 70 || S >= 97 && S <= 102
            }
            function u(S, T, C) {
                const N = {
                    char: null,
                    nexti: S + 2,
                    error: !0
                };
                if (S + 1 < T && c(C[S]) && c(C[S + 1])) {
                    const A = String.fromCodePoint(C[S], C[S + 1]);
                    N.char = parseInt(A, 16),
                    Number.isNaN(N.char) || (N.error = !1)
                }
                return N
            }
            function g(S, T, C) {
                const N = {
                    char: null,
                    nexti: S + 4,
                    error: !0
                };
                if (S + 3 < T && c(C[S]) && c(C[S + 1]) && c(C[S + 2]) && c(C[S + 3])) {
                    const A = String.fromCodePoint(C[S], C[S + 1], C[S + 2], C[S + 3]);
                    N.char = parseInt(A, 16),
                    Number.isNaN(N.char) || (N.error = !1)
                }
                return N
            }
            function P(S, T, C) {
                const N = {
                    char: null,
                    nexti: S + 4,
                    error: !0
                };
                let A = "";
                for (; S < T && c(C[S]); )
                    A += String.fromCodePoint(C[S]),
                    S += 1;
                return N.char = parseInt(A, 16),
                C[S] === 125 && !Number.isNaN(N.char) && (N.error = !1),
                N.nexti = S + 1,
                N
            }
            const v = []
              , b = o.length;
            let x, a, E, w = 0;
            for (; w < b; ) {
                for (; ; ) {
                    if (E = !0,
                    o[w] !== 96) {
                        v.push(o[w]),
                        w += 1,
                        E = !1;
                        break
                    }
                    if (x = w + 1,
                    x >= b)
                        break;
                    if (o[x] === 96) {
                        v.push(96),
                        w += 2,
                        E = !1;
                        break
                    }
                    if (o[x] === 120) {
                        if (a = u(x + 1, b, o),
                        a.error)
                            break;
                        v.push(a.char),
                        w = a.nexti,
                        E = !1;
                        break
                    }
                    if (o[x] === 117) {
                        if (o[x + 1] === 123) {
                            if (a = P(x + 2, b, o),
                            a.error)
                                break;
                            v.push(a.char),
                            w = a.nexti,
                            E = !1;
                            break
                        }
                        if (a = g(x + 1, b, o),
                        a.error)
                            break;
                        v.push(a.char),
                        w = a.nexti,
                        E = !1;
                        break
                    }
                    break
                }
                if (E)
                    throw new Error(`escaped.decode: ill-formed escape sequence at buf[${w}]`)
            }
            return v
        }
    };
    const l = 13
      , p = 10;
    e.lineEnds = {
        crlf(o) {
            const c = [];
            let u = 0;
            for (; u < o.length; )
                switch (o[u]) {
                case l:
                    u + 1 < o.length && o[u + 1] === p ? u += 2 : u += 1,
                    c.push(l),
                    c.push(p);
                    break;
                case p:
                    c.push(l),
                    c.push(p),
                    u += 1;
                    break;
                default:
                    c.push(o[u]),
                    u += 1;
                    break
                }
            return c.length > 0 && c[c.length - 1] !== p && (c.push(l),
            c.push(p)),
            c
        },
        lf(o) {
            const c = [];
            let u = 0;
            for (; u < o.length; )
                switch (o[u]) {
                case l:
                    u + 1 < o.length && o[u + 1] === p ? u += 2 : u += 1,
                    c.push(p);
                    break;
                case p:
                    c.push(p),
                    u += 1;
                    break;
                default:
                    c.push(o[u]),
                    u += 1;
                    break
                }
            return c.length > 0 && c[c.length - 1] !== p && c.push(p),
            c
        }
    },
    e.base64 = {
        encode(o) {
            if (o.length === 0)
                return t.alloc(0);
            let c, u, g, P = o.length % 3;
            P = P > 0 ? 3 - P : 0;
            let v = (o.length + P) / 3;
            const b = t.alloc(v * 4);
            P > 0 && (v -= 1),
            c = 0,
            u = 0;
            for (let x = 0; x < v; x += 1)
                g = o[c++] << 16,
                g += o[c++] << 8,
                g += o[c++],
                b[u++] = i[g >> 18 & h[6]],
                b[u++] = i[g >> 12 & h[6]],
                b[u++] = i[g >> 6 & h[6]],
                b[u++] = i[g & h[6]];
            if (P === 0)
                return b;
            if (P === 1)
                return g = o[c++] << 16,
                g += o[c] << 8,
                b[u++] = i[g >> 18 & h[6]],
                b[u++] = i[g >> 12 & h[6]],
                b[u++] = i[g >> 6 & h[6]],
                b[u] = i[64],
                b;
            if (P === 2)
                return g = o[c] << 16,
                b[u++] = i[g >> 18 & h[6]],
                b[u++] = i[g >> 12 & h[6]],
                b[u++] = i[64],
                b[u] = i[64],
                b
        },
        decode(o) {
            function c(w) {
                const S = [];
                let T = 0;
                for (let C = 0; C < w.length; C += 1) {
                    const N = w[C]
                      , A = !0;
                    for (; A && !(N === 32 || N === 9 || N === 10 || N === 13); ) {
                        if (N >= 65 && N <= 90) {
                            S.push(N - 65);
                            break
                        }
                        if (N >= 97 && N <= 122) {
                            S.push(N - 71);
                            break
                        }
                        if (N >= 48 && N <= 57) {
                            S.push(N + 4);
                            break
                        }
                        if (N === 43) {
                            S.push(62);
                            break
                        }
                        if (N === 47) {
                            S.push(63);
                            break
                        }
                        if (N === 61) {
                            S.push(64),
                            T += 1;
                            break
                        }
                        throw new RangeError(`base64.decode: invalid character buf[${C}]: ${N}`)
                    }
                }
                if (S.length % 4 > 0)
                    throw new RangeError(`base64.decode: string length not integral multiple of 4: ${S.length}`);
                switch (T) {
                case 0:
                    break;
                case 1:
                    if (S[S.length - 1] !== 64)
                        throw new RangeError("base64.decode: one tail character found: not last character");
                    break;
                case 2:
                    if (S[S.length - 1] !== 64 || S[S.length - 2] !== 64)
                        throw new RangeError("base64.decode: two tail characters found: not last characters");
                    break;
                default:
                    throw new RangeError(`base64.decode: more than two tail characters found: ${T}`)
                }
                return {
                    tail: T,
                    buf: t.from(S)
                }
            }
            if (o.length === 0)
                return t.alloc(0);
            const u = c(o)
              , {tail: g} = u
              , P = u.buf;
            let v, b, x, a = P.length / 4;
            const E = t.alloc(a * 3 - g);
            g > 0 && (a -= 1),
            b = 0,
            v = 0;
            for (let w = 0; w < a; w += 1)
                x = P[v++] << 18,
                x += P[v++] << 12,
                x += P[v++] << 6,
                x += P[v++],
                E[b++] = x >> 16 & h[8],
                E[b++] = x >> 8 & h[8],
                E[b++] = x & h[8];
            return g === 1 && (x = P[v++] << 18,
            x += P[v++] << 12,
            x += P[v] << 6,
            E[b++] = x >> 16 & h[8],
            E[b] = x >> 8 & h[8]),
            g === 2 && (x = P[v++] << 18,
            x += P[v++] << 12,
            E[b] = x >> 16 & h[8]),
            E
        },
        toString(o) {
            if (o.length % 4 > 0)
                throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${o.length}`);
            let c = ""
              , u = 0;
            function g(v, b, x, a) {
                switch (u) {
                case 76:
                    c += `\r
${v}${b}${x}${a}`,
                    u = 4;
                    break;
                case 75:
                    c += `${v}\r
${b}${x}${a}`,
                    u = 3;
                    break;
                case 74:
                    c += `${v + b}\r
${x}${a}`,
                    u = 2;
                    break;
                case 73:
                    c += `${v + b + x}\r
${a}`,
                    u = 1;
                    break;
                default:
                    c += v + b + x + a,
                    u += 4;
                    break
                }
            }
            function P(v) {
                return v >= 65 && v <= 90 || v >= 97 && v <= 122 || v >= 48 && v <= 57 || v === 43 || v === 47 || v === 61
            }
            for (let v = 0; v < o.length; v += 4) {
                for (let b = v; b < v + 4; b += 1)
                    if (!P(o[b]))
                        throw new RangeError(`base64.toString: buf[${b}]: ${o[b]} : not valid base64 character code`);
                g(String.fromCharCode(o[v]), String.fromCharCode(o[v + 1]), String.fromCharCode(o[v + 2]), String.fromCharCode(o[v + 3]))
            }
            return c
        }
    }
}
)(uu);
(function(e) {
    "use strict;";
    const {Buffer: t} = ou
      , s = uu
      , r = "UTF8"
      , n = "UTF16"
      , d = "UTF16BE"
      , h = "UTF16LE"
      , m = "UTF32"
      , f = "UTF32BE"
      , i = "UTF32LE"
      , l = "UINT7"
      , p = "ASCII"
      , o = "BINARY"
      , c = "UINT8"
      , u = "UINT16"
      , g = "UINT16LE"
      , P = "UINT16BE"
      , v = "UINT32"
      , b = "UINT32LE"
      , x = "UINT32BE"
      , a = "ESCAPED"
      , E = "STRING"
      , w = function(_) {
        _.type = r;
        const O = _.data;
        _.bom = 0,
        O.length >= 3 && O[0] === 239 && O[1] === 187 && O[2] === 191 && (_.bom = 3)
    }
      , S = function(_) {
        const O = _.data;
        switch (_.bom = 0,
        _.type) {
        case n:
            _.type = d,
            O.length >= 2 && (O[0] === 254 && O[1] === 255 ? _.bom = 2 : O[0] === 255 && O[1] === 254 && (_.type = h,
            _.bom = 2));
            break;
        case d:
            if (_.type = d,
            O.length >= 2) {
                if (O[0] === 254 && O[1] === 255)
                    _.bom = 2;
                else if (O[0] === 255 && O[1] === 254)
                    throw new TypeError(`src type: "${d}" specified but BOM is for "${h}"`)
            }
            break;
        case h:
            if (_.type = h,
            O.length >= 0) {
                if (O[0] === 254 && O[1] === 255)
                    throw new TypeError(`src type: "${h}" specified but BOM is for "${d}"`);
                O[0] === 255 && O[1] === 254 && (_.bom = 2)
            }
            break;
        default:
            throw new TypeError(`UTF16 BOM: src type "${_.type}" unrecognized`)
        }
    }
      , T = function(_) {
        const O = _.data;
        switch (_.bom = 0,
        _.type) {
        case m:
            _.type = f,
            O.length >= 4 && (O[0] === 0 && O[1] === 0 && O[2] === 254 && O[3] === 255 && (_.bom = 4),
            O[0] === 255 && O[1] === 254 && O[2] === 0 && O[3] === 0 && (_.type = i,
            _.bom = 4));
            break;
        case f:
            if (_.type = f,
            O.length >= 4 && (O[0] === 0 && O[1] === 0 && O[2] === 254 && O[3] === 255 && (_.bom = 4),
            O[0] === 255 && O[1] === 254 && O[2] === 0 && O[3] === 0))
                throw new TypeError(`src type: ${f} specified but BOM is for ${i}"`);
            break;
        case i:
            if (_.type = i,
            O.length >= 4) {
                if (O[0] === 0 && O[1] === 0 && O[2] === 254 && O[3] === 255)
                    throw new TypeError(`src type: "${i}" specified but BOM is for "${f}"`);
                O[0] === 255 && O[1] === 254 && O[2] === 0 && O[3] === 0 && (_.bom = 4)
            }
            break;
        default:
            throw new TypeError(`UTF32 BOM: src type "${_.type}" unrecognized`)
        }
    }
      , C = function(_, O) {
        function L($) {
            const B = {
                type: "",
                base64: !1
            }
              , F = /^(base64:)?([a-zA-Z0-9]+)$/i.exec($);
            return F && (F[2] && (B.type = F[2].toUpperCase()),
            F[1] && (B.base64 = !0)),
            B
        }
        const U = L(_.toUpperCase());
        if (U.base64) {
            if (U.type === E)
                throw new TypeError(`type: "${_} "BASE64:" prefix not allowed with type ${E}`);
            if (t.isBuffer(O))
                U.data = s.base64.decode(O);
            else if (typeof O == "string") {
                const $ = t.from(O, "ascii");
                U.data = s.base64.decode($)
            } else
                throw new TypeError(`type: "${_} unrecognized data type: typeof(data): ${typeof O}`)
        } else
            U.data = O;
        switch (U.type) {
        case r:
            w(U);
            break;
        case n:
        case d:
        case h:
            S(U);
            break;
        case m:
        case f:
        case i:
            T(U);
            break;
        case u:
            U.type = P;
            break;
        case v:
            U.type = x;
            break;
        case p:
            U.type = l;
            break;
        case o:
            U.type = c;
            break;
        case l:
        case c:
        case g:
        case P:
        case b:
        case x:
        case E:
        case a:
            break;
        default:
            throw new TypeError(`type: "${_}" not recognized`)
        }
        if (U.type === E) {
            if (typeof U.data != "string")
                throw new TypeError(`type: "${_}" but data is not a string`)
        } else if (!t.isBuffer(U.data))
            throw new TypeError(`type: "${_}" but data is not a Buffer`);
        return U
    }
      , N = function(_, O) {
        function L($) {
            let B, I;
            const F = {
                crlf: !1,
                lf: !1,
                base64: !1,
                type: ""
            }
              , z = !0;
            for (; z; ) {
                if (I = $,
                B = $.slice(0, 5),
                B === "CRLF:") {
                    F.crlf = !0,
                    I = $.slice(5);
                    break
                }
                if (B = $.slice(0, 3),
                B === "LF:") {
                    F.lf = !0,
                    I = $.slice(3);
                    break
                }
                break
            }
            return B = I.split(":"),
            B.length === 1 ? F.type = B[0] : B.length === 2 && B[1] === "BASE64" && (F.base64 = !0,
            F.type = B[0]),
            F
        }
        if (!Array.isArray(O))
            throw new TypeError(`dst chars: not array: "${typeof O}`);
        if (typeof _ != "string")
            throw new TypeError(`dst type: not string: "${typeof _}`);
        const U = L(_.toUpperCase());
        switch (U.type) {
        case r:
        case d:
        case h:
        case f:
        case i:
        case l:
        case c:
        case g:
        case P:
        case b:
        case x:
        case a:
            break;
        case E:
            if (U.base64)
                throw new TypeError(`":BASE64" suffix not allowed with type ${E}`);
            break;
        case p:
            U.type = l;
            break;
        case o:
            U.type = c;
            break;
        case n:
            U.type = d;
            break;
        case m:
            U.type = f;
            break;
        case u:
            U.type = P;
            break;
        case v:
            U.type = x;
            break;
        default:
            throw new TypeError(`dst type unrecognized: "${_}" : must have form [crlf:|lf:]type[:base64]`)
        }
        return U
    }
      , A = function(_, O) {
        switch (_) {
        case r:
            return s.utf8.encode(O);
        case d:
            return s.utf16be.encode(O);
        case h:
            return s.utf16le.encode(O);
        case f:
            return s.utf32be.encode(O);
        case i:
            return s.utf32le.encode(O);
        case l:
            return s.uint7.encode(O);
        case c:
            return s.uint8.encode(O);
        case P:
            return s.uint16be.encode(O);
        case g:
            return s.uint16le.encode(O);
        case x:
            return s.uint32be.encode(O);
        case b:
            return s.uint32le.encode(O);
        case E:
            return s.string.encode(O);
        case a:
            return s.escaped.encode(O);
        default:
            throw new TypeError(`encode type "${_}" not recognized`)
        }
    }
      , R = function(_) {
        switch (_.type) {
        case r:
            return s.utf8.decode(_.data, _.bom);
        case h:
            return s.utf16le.decode(_.data, _.bom);
        case d:
            return s.utf16be.decode(_.data, _.bom);
        case f:
            return s.utf32be.decode(_.data, _.bom);
        case i:
            return s.utf32le.decode(_.data, _.bom);
        case l:
            return s.uint7.decode(_.data);
        case c:
            return s.uint8.decode(_.data);
        case P:
            return s.uint16be.decode(_.data);
        case g:
            return s.uint16le.decode(_.data);
        case x:
            return s.uint32be.decode(_.data);
        case b:
            return s.uint32le.decode(_.data);
        case E:
            return s.string.decode(_.data);
        case a:
            return s.escaped.decode(_.data);
        default:
            throw new TypeError(`decode type "${_.type}" not recognized`)
        }
    };
    e.decode = function(_, O) {
        const L = C(_, O);
        return R(L)
    }
    ,
    e.encode = function(_, O) {
        let L, U;
        const $ = N(_, O);
        return $.crlf ? (L = s.lineEnds.crlf(O),
        U = A($.type, L)) : $.lf ? (L = s.lineEnds.lf(O),
        U = A($.type, L)) : U = A($.type, O),
        $.base64 && (U = s.base64.encode(U)),
        U
    }
    ;
    const y = function(_, O, L) {
        return e.encode(L, e.decode(_, O))
    };
    e.convert = y
}
)(cu);
var lu = function() {
    return `/* This file automatically generated by jsonToless() and LESS. */
.apg-mono {
  font-family: monospace;
}
.apg-active {
  font-weight: bold;
  color: #000000;
}
.apg-match {
  font-weight: bold;
  color: #264BFF;
}
.apg-empty {
  font-weight: bold;
  color: #0fbd0f;
}
.apg-nomatch {
  font-weight: bold;
  color: #FF4000;
}
.apg-lh-match {
  font-weight: bold;
  color: #1A97BA;
}
.apg-lb-match {
  font-weight: bold;
  color: #5F1687;
}
.apg-remainder {
  font-weight: bold;
  color: #999999;
}
.apg-ctrl-char {
  font-weight: bolder;
  font-style: italic;
  font-size: 0.6em;
}
.apg-line-end {
  font-weight: bold;
  color: #000000;
}
.apg-error {
  font-weight: bold;
  color: #FF4000;
}
.apg-phrase {
  color: #000000;
  background-color: #8caae6;
}
.apg-empty-phrase {
  color: #0fbd0f;
}
table.apg-state {
  font-family: monospace;
  margin-top: 5px;
  font-size: 11px;
  line-height: 130%;
  text-align: left;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-state th,
table.apg-state td {
  text-align: left;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-state th:nth-last-child(2),
table.apg-state td:nth-last-child(2) {
  text-align: right;
}
table.apg-state caption {
  font-size: 125%;
  line-height: 130%;
  font-weight: bold;
  text-align: left;
}
table.apg-stats {
  font-family: monospace;
  margin-top: 5px;
  font-size: 11px;
  line-height: 130%;
  text-align: right;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-stats th,
table.apg-stats td {
  text-align: right;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-stats caption {
  font-size: 125%;
  line-height: 130%;
  font-weight: bold;
  text-align: left;
}
table.apg-trace {
  font-family: monospace;
  margin-top: 5px;
  font-size: 11px;
  line-height: 130%;
  text-align: right;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-trace caption {
  font-size: 125%;
  line-height: 130%;
  font-weight: bold;
  text-align: left;
}
table.apg-trace th,
table.apg-trace td {
  text-align: right;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-trace th:last-child,
table.apg-trace th:nth-last-child(2),
table.apg-trace td:last-child,
table.apg-trace td:nth-last-child(2) {
  text-align: left;
}
table.apg-grammar {
  font-family: monospace;
  margin-top: 5px;
  font-size: 11px;
  line-height: 130%;
  text-align: right;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-grammar caption {
  font-size: 125%;
  line-height: 130%;
  font-weight: bold;
  text-align: left;
}
table.apg-grammar th,
table.apg-grammar td {
  text-align: right;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-grammar th:last-child,
table.apg-grammar td:last-child {
  text-align: left;
}
table.apg-rules {
  font-family: monospace;
  margin-top: 5px;
  font-size: 11px;
  line-height: 130%;
  text-align: right;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-rules caption {
  font-size: 125%;
  line-height: 130%;
  font-weight: bold;
  text-align: left;
}
table.apg-rules th,
table.apg-rules td {
  text-align: right;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-rules a {
  color: #003399 !important;
}
table.apg-rules a:hover {
  color: #8caae6 !important;
}
table.apg-attrs {
  font-family: monospace;
  margin-top: 5px;
  font-size: 11px;
  line-height: 130%;
  text-align: center;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-attrs caption {
  font-size: 125%;
  line-height: 130%;
  font-weight: bold;
  text-align: left;
}
table.apg-attrs th,
table.apg-attrs td {
  text-align: center;
  border: 1px solid black;
  border-collapse: collapse;
}
table.apg-attrs th:nth-child(1),
table.apg-attrs th:nth-child(2),
table.apg-attrs th:nth-child(3) {
  text-align: right;
}
table.apg-attrs td:nth-child(1),
table.apg-attrs td:nth-child(2),
table.apg-attrs td:nth-child(3) {
  text-align: right;
}
table.apg-attrs a {
  color: #003399 !important;
}
table.apg-attrs a:hover {
  color: #8caae6 !important;
}
`
};
(function(e) {
    const t = Ts
      , s = cu
      , r = lu
      , n = jr
      , d = "utilities.js: "
      , h = function(f, i, l) {
        let p, o = i;
        const c = !0;
        for (; c; ) {
            if (f <= 0) {
                o = 0,
                p = 0;
                break
            }
            if (typeof o != "number") {
                o = 0,
                p = f;
                break
            }
            if (o >= f) {
                o = f,
                p = f;
                break
            }
            if (typeof l != "number") {
                p = f;
                break
            }
            if (p = o + l,
            p > f) {
                p = f;
                break
            }
            break
        }
        return {
            beg: o,
            end: p
        }
    };
    e.htmlToPage = function(f, i) {
        let l;
        if (typeof f != "string")
            throw new Error(`${d}htmlToPage: input HTML is not a string`);
        typeof i != "string" ? l = "htmlToPage" : l = i;
        let p = "";
        return p += `<!DOCTYPE html>
`,
        p += `<html lang="en">
`,
        p += `<head>
`,
        p += `<meta charset="utf-8">
`,
        p += `<title>${l}</title>
`,
        p += `<style>
`,
        p += r(),
        p += `</style>
`,
        p += `</head>
<body>
`,
        p += `<p>${new Date}</p>
`,
        p += f,
        p += `</body>
</html>
`,
        p
    }
    ,
    e.parserResultToHtml = function(f, i) {
        let l = null;
        typeof i == "string" && i !== "" && (l = i);
        let p, o;
        f.success === !0 ? p = `<span class="${t.CLASS_MATCH}">true</span>` : p = `<span class="${t.CLASS_NOMATCH}">false</span>`,
        f.state === n.EMPTY ? o = `<span class="${t.CLASS_EMPTY}">EMPTY</span>` : f.state === n.MATCH ? o = `<span class="${t.CLASS_MATCH}">MATCH</span>` : f.state === n.NOMATCH ? o = `<span class="${t.CLASS_NOMATCH}">NOMATCH</span>` : o = `<span class="${t.CLASS_NOMATCH}">unrecognized</span>`;
        let c = "";
        return c += `<table class="${t.CLASS_STATE}">
`,
        l && (c += `<caption>${l}</caption>
`),
        c += `<tr><th>state item</th><th>value</th><th>description</th></tr>
`,
        c += `<tr><td>parser success</td><td>${p}</td>
`,
        c += `<td><span class="${t.CLASS_MATCH}">true</span> if the parse succeeded,
`,
        c += ` <span class="${t.CLASS_NOMATCH}">false</span> otherwise`,
        c += `<br><i>NOTE: for success, entire string must be matched</i></td></tr>
`,
        c += `<tr><td>parser state</td><td>${o}</td>
`,
        c += `<td><span class="${t.CLASS_EMPTY}">EMPTY</span>, `,
        c += `<span class="${t.CLASS_MATCH}">MATCH</span> or 
`,
        c += `<span class="${t.CLASS_NOMATCH}">NOMATCH</span></td></tr>
`,
        c += `<tr><td>string length</td><td>${f.length}</td><td>length of the input (sub)string</td></tr>
`,
        c += `<tr><td>matched length</td><td>${f.matched}</td><td>number of input string characters matched</td></tr>
`,
        c += `<tr><td>max matched</td><td>${f.maxMatched}</td><td>maximum number of input string characters matched</td></tr>
`,
        c += `<tr><td>max tree depth</td><td>${f.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>
`,
        c += `<tr><td>node hits</td><td>${f.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>
`,
        c += `<tr><td>input length</td><td>${f.inputLength}</td><td>length of full input string</td></tr>
`,
        c += `<tr><td>sub-string begin</td><td>${f.subBegin}</td><td>sub-string first character index</td></tr>
`,
        c += `<tr><td>sub-string end</td><td>${f.subEnd}</td><td>sub-string end-of-string index</td></tr>
`,
        c += `<tr><td>sub-string length</td><td>${f.subLength}</td><td>sub-string length</td></tr>
`,
        c += `</table>
`,
        c
    }
    ,
    e.charsToString = function(f, i, l) {
        let p, o;
        if (typeof i == "number") {
            if (i >= f.length)
                return "";
            p = i < 0 ? 0 : i
        } else
            p = 0;
        if (typeof l == "number") {
            if (l <= 0)
                return "";
            o = l > f.length - p ? f.length : p + l
        } else
            o = f.length;
        return p < o ? s.encode("UTF16LE", f.slice(p, o)).toString("utf16le") : ""
    }
    ,
    e.stringToChars = function(f) {
        return s.decode("STRING", f)
    }
    ,
    e.opcodeToString = function(f) {
        let i = "unknown";
        switch (f) {
        case n.ALT:
            i = "ALT";
            break;
        case n.CAT:
            i = "CAT";
            break;
        case n.RNM:
            i = "RNM";
            break;
        case n.UDT:
            i = "UDT";
            break;
        case n.AND:
            i = "AND";
            break;
        case n.NOT:
            i = "NOT";
            break;
        case n.REP:
            i = "REP";
            break;
        case n.TRG:
            i = "TRG";
            break;
        case n.TBS:
            i = "TBS";
            break;
        case n.TLS:
            i = "TLS";
            break;
        case n.BKR:
            i = "BKR";
            break;
        case n.BKA:
            i = "BKA";
            break;
        case n.BKN:
            i = "BKN";
            break;
        case n.ABG:
            i = "ABG";
            break;
        case n.AEN:
            i = "AEN";
            break;
        default:
            throw new Error("unrecognized opcode")
        }
        return i
    }
    ,
    e.stateToString = function(f) {
        let i = "unknown";
        switch (f) {
        case n.ACTIVE:
            i = "ACTIVE";
            break;
        case n.MATCH:
            i = "MATCH";
            break;
        case n.EMPTY:
            i = "EMPTY";
            break;
        case n.NOMATCH:
            i = "NOMATCH";
            break;
        default:
            throw new Error("unrecognized state")
        }
        return i
    }
    ,
    e.asciiChars = ["NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL", "BS", "TAB", "LF", "VT", "FF", "CR", "SO", "SI", "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US", "&nbsp;", "!", "&#34;", "#", "$", "%", "&#38;", "&#39;", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "&#60;", "=", "&#62;", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "&#92;", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "DEL"],
    e.charToHex = function(f) {
        let i = f.toString(16).toUpperCase();
        switch (i.length) {
        case 1:
        case 3:
        case 7:
            i = `0${i}`;
            break;
        case 2:
        case 6:
            i = `00${i}`;
            break;
        case 4:
            break;
        case 5:
            i = `000${i}`;
            break;
        default:
            throw new Error("unrecognized option")
        }
        return i
    }
    ,
    e.charsToDec = function(f, i, l) {
        let p = "";
        if (!Array.isArray(f))
            throw new Error(`${d}charsToDec: input must be an array of integers`);
        const o = h(f.length, i, l);
        if (o.end > o.beg) {
            p += f[o.beg];
            for (let c = o.beg + 1; c < o.end; c += 1)
                p += `,${f[c]}`
        }
        return p
    }
    ,
    e.charsToHex = function(f, i, l) {
        let p = "";
        if (!Array.isArray(f))
            throw new Error(`${d}charsToHex: input must be an array of integers`);
        const o = h(f.length, i, l);
        if (o.end > o.beg) {
            p += `\\x${e.charToHex(f[o.beg])}`;
            for (let c = o.beg + 1; c < o.end; c += 1)
                p += `,\\x${e.charToHex(f[c])}`
        }
        return p
    }
    ,
    e.charsToHtmlEntities = function(f, i, l) {
        let p = "";
        if (!Array.isArray(f))
            throw new Error(`${d}charsToHex: input must be an array of integers`);
        const o = h(f.length, i, l);
        if (o.end > o.beg)
            for (let c = o.beg; c < o.end; c += 1)
                p += `&#x${f[c].toString(16)};`;
        return p
    }
    ;
    function m(f) {
        return !(f >= 55296 && f <= 57343 || f > 1114111)
    }
    e.charsToUnicode = function(f, i, l) {
        let p = "";
        if (!Array.isArray(f))
            throw new Error(`${d}charsToUnicode: input must be an array of integers`);
        const o = h(f.length, i, l);
        if (o.end > o.beg)
            for (let c = o.beg; c < o.end; c += 1)
                m(f[c]) ? p += `&#${f[c]};` : p += ` U+${e.charToHex(f[c])}`;
        return p
    }
    ,
    e.charsToJsUnicode = function(f, i, l) {
        let p = "";
        if (!Array.isArray(f))
            throw new Error(`${d}charsToJsUnicode: input must be an array of integers`);
        const o = h(f.length, i, l);
        if (o.end > o.beg) {
            p += `\\u${e.charToHex(f[o.beg])}`;
            for (let c = o.beg + 1; c < o.end; c += 1)
                p += `,\\u${e.charToHex(f[c])}`
        }
        return p
    }
    ,
    e.charsToAscii = function(f, i, l) {
        let p = "";
        if (!Array.isArray(f))
            throw new Error(`${d}charsToAscii: input must be an array of integers`);
        const o = h(f.length, i, l);
        for (let c = o.beg; c < o.end; c += 1) {
            const u = f[c];
            u >= 32 && u <= 126 ? p += String.fromCharCode(u) : p += `\\x${e.charToHex(u)}`
        }
        return p
    }
    ,
    e.charsToAsciiHtml = function(f, i, l) {
        if (!Array.isArray(f))
            throw new Error(`${d}charsToAsciiHtml: input must be an array of integers`);
        let p = "", o;
        const c = h(f.length, i, l);
        for (let u = c.beg; u < c.end; u += 1)
            o = f[u],
            o < 32 || o === 127 ? p += `<span class="${t.CLASS_CTRLCHAR}">${e.asciiChars[o]}</span>` : o > 127 ? p += `<span class="${t.CLASS_CTRLCHAR}">U+${e.charToHex(o)}</span>` : p += e.asciiChars[o];
        return p
    }
    ,
    e.stringToAsciiHtml = function(f) {
        const i = s.decode("STRING", f);
        return this.charsToAsciiHtml(i)
    }
}
)(Mr);
var Xl = function() {
    const t = jr
      , s = Mr
      , r = "ast.js: "
      , n = this;
    let d = null
      , h = null
      , m = null
      , f = 0;
    const i = []
      , l = []
      , p = []
      , o = [];
    this.callbacks = [],
    this.astObject = "astObject",
    this.init = function(g, P, v) {
        p.length = 0,
        o.length = 0,
        i.length = 0,
        f = 0,
        d = g,
        h = P,
        m = v;
        let b;
        const x = [];
        for (b = 0; b < d.length; b += 1)
            x.push(d[b].lower);
        for (b = 0; b < h.length; b += 1)
            x.push(h[b].lower);
        for (f = d.length + h.length,
        b = 0; b < f; b += 1)
            i[b] = !1,
            l[b] = null;
        for (const a in n.callbacks) {
            const E = a.toLowerCase();
            if (b = x.indexOf(E),
            b < 0)
                throw new Error(`${r}init: node '${a}' not a rule or udt name`);
            typeof n.callbacks[a] == "function" && (i[b] = !0,
            l[b] = n.callbacks[a]),
            n.callbacks[a] === !0 && (i[b] = !0)
        }
    }
    ,
    this.ruleDefined = function(g) {
        return i[g] !== !1
    }
    ,
    this.udtDefined = function(g) {
        return i[d.length + g] !== !1
    }
    ,
    this.down = function(g, P) {
        const v = o.length;
        return p.push(v),
        o.push({
            name: P,
            thisIndex: v,
            thatIndex: null,
            state: t.SEM_PRE,
            callbackIndex: g,
            phraseIndex: null,
            phraseLength: null,
            stack: p.length
        }),
        v
    }
    ,
    this.up = function(g, P, v, b) {
        const x = o.length
          , a = p.pop();
        return o.push({
            name: P,
            thisIndex: x,
            thatIndex: a,
            state: t.SEM_POST,
            callbackIndex: g,
            phraseIndex: v,
            phraseLength: b,
            stack: p.length
        }),
        o[a].thatIndex = x,
        o[a].phraseIndex = v,
        o[a].phraseLength = b,
        x
    }
    ,
    this.translate = function(g) {
        let P, v, b;
        for (let x = 0; x < o.length; x += 1)
            b = o[x],
            v = l[b.callbackIndex],
            b.state === t.SEM_PRE ? v !== null && (P = v(t.SEM_PRE, m, b.phraseIndex, b.phraseLength, g),
            P === t.SEM_SKIP && (x = b.thatIndex)) : v !== null && v(t.SEM_POST, m, b.phraseIndex, b.phraseLength, g)
    }
    ,
    this.setLength = function(g) {
        o.length = g,
        g > 0 ? p.length = o[g - 1].stack : p.length = 0
    }
    ,
    this.getLength = function() {
        return o.length
    }
    ;
    function c(u) {
        let g = "";
        for (let P = 0; P < u; P += 1)
            g += " ";
        return g
    }
    this.toXml = function(g) {
        let P = s.charsToDec
          , v = "decimal integer character codes";
        if (typeof g == "string" && g.length >= 3) {
            const a = g.slice(0, 3).toLowerCase();
            a === "asc" ? (P = s.charsToAscii,
            v = "ASCII for printing characters, hex for non-printing") : a === "hex" ? (P = s.charsToHex,
            v = "hexadecimal integer character codes") : a === "uni" && (P = s.charsToUnicode,
            v = "Unicode UTF-32 integer character codes")
        }
        let b = ""
          , x = 0;
        return b += `<?xml version="1.0" encoding="utf-8"?>
`,
        b += `<root nodes="${o.length / 2}" characters="${m.length}">
`,
        b += `<!-- input string, ${v} -->
`,
        b += c(x + 2),
        b += P(m),
        b += `
`,
        o.forEach(a => {
            a.state === t.SEM_PRE ? (x += 1,
            b += c(x),
            b += `<node name="${a.name}" index="${a.phraseIndex}" length="${a.phraseLength}">
`,
            b += c(x + 2),
            b += P(m, a.phraseIndex, a.phraseLength),
            b += `
`) : (b += c(x),
            b += `</node><!-- name="${a.name}" -->
`,
            x -= 1)
        }
        ),
        b += `</root>
`,
        b
    }
    ,
    this.phrases = function() {
        const g = {};
        let P, v;
        for (P = 0; P < o.length; P += 1)
            v = o[P],
            v.state === t.SEM_PRE && (Array.isArray(g[v.name]) || (g[v.name] = []),
            g[v.name].push({
                index: v.phraseIndex,
                length: v.phraseLength
            }));
        return g
    }
}
  , du = function() {
    "use strict;";
    const t = "circular-buffer.js: ";
    let s = -1
      , r = 0;
    this.init = function(d) {
        if (typeof d != "number" || d <= 0)
            throw new Error(`${t}init: circular buffer size must an integer > 0`);
        r = Math.ceil(d),
        s = -1
    }
    ,
    this.increment = function() {
        return s += 1,
        (s + r) % r
    }
    ,
    this.maxSize = function() {
        return r
    }
    ,
    this.items = function() {
        return s + 1
    }
    ,
    this.getListIndex = function(d) {
        return s === -1 || d < 0 || d > s || s - d >= r ? -1 : (d + r) % r
    }
    ,
    this.forEach = function(d) {
        if (s !== -1) {
            if (s < r) {
                for (let h = 0; h <= s; h += 1)
                    d(h, h);
                return
            }
            for (let h = s - r + 1; h <= s; h += 1) {
                const m = (h + r) % r;
                d(m, h)
            }
        }
    }
}
  , ed = function() {
    const t = jr
      , s = Mr
      , r = "parser.js: "
      , n = this;
    let d;
    this.ast = null,
    this.stats = null,
    this.trace = null,
    this.callbacks = [];
    let h = null, m = null, f, i, l, p, o = 0, c = 0, u = 0, g = null, P = null, v = null, b = null, x = null, a = 0, E = 1 / 0, w = 1 / 0;
    const S = function(J, D, X) {
        const ce = `${r}evaluateRule(): `;
        if (J >= v.length)
            throw new Error(`${ce}rule index: ${J} out of range`);
        if (D >= l)
            throw new Error(`${ce}phrase index: ${D} out of range`);
        const {length: pe} = h;
        h.push({
            type: t.RNM,
            index: J
        }),
        d(pe, D, X),
        h.pop()
    }
      , T = function(Z, J, D) {
        const X = `${r}evaluateUdt(): `;
        if (Z >= b.length)
            throw new Error(`${X}udt index: ${Z} out of range`);
        if (J >= l)
            throw new Error(`${X}phrase index: ${J} out of range`);
        const {length: ce} = h;
        h.push({
            type: t.UDT,
            empty: b[Z].empty,
            index: Z
        }),
        d(ce, J, D),
        h.pop()
    }
      , C = function() {
        o = 0,
        c = 0,
        u = 0,
        a = 0,
        p = [{
            lookAround: t.LOOKAROUND_NONE,
            anchor: 0,
            charsEnd: 0,
            charsLength: 0
        }],
        v = null,
        b = null,
        m = null,
        f = 0,
        i = 0,
        l = 0,
        g = null,
        P = null,
        x = null,
        h = null
    }
      , N = function() {
        const Z = []
          , J = function() {
            const X = {};
            v.forEach(ce => {
                ce.isBkr && (X[ce.lower] = null)
            }
            ),
            b.length > 0 && b.forEach(ce => {
                ce.isBkr && (X[ce.lower] = null)
            }
            ),
            Z.push(X)
        }
          , D = function() {
            const X = Z[Z.length - 1]
              , ce = {};
            for (const pe in X)
                ce[pe] = X[pe];
            return ce
        };
        this.push = function() {
            Z.push(D())
        }
        ,
        this.pop = function(ce) {
            let pe = ce;
            if (pe || (pe = Z.length - 1),
            pe < 1 || pe > Z.length)
                throw new Error(`${r}backRef.pop(): bad length: ${pe}`);
            return Z.length = pe,
            Z[Z.length - 1]
        }
        ,
        this.length = function() {
            return Z.length
        }
        ,
        this.savePhrase = function(ce, pe, ve) {
            Z[Z.length - 1][ce] = {
                phraseIndex: pe,
                phraseLength: ve
            }
        }
        ,
        this.getPhrase = function(X) {
            return Z[Z.length - 1][X]
        }
        ,
        J()
    }
      , A = function() {
        const J = this;
        this.state = t.ACTIVE,
        this.phraseLength = 0,
        this.ruleIndex = 0,
        this.udtIndex = 0,
        this.lookAround = p[p.length - 1],
        this.uFrame = new N,
        this.pFrame = new N,
        this.evaluateRule = S,
        this.evaluateUdt = T,
        this.refresh = function() {
            J.state = t.ACTIVE,
            J.phraseLength = 0,
            J.lookAround = p[p.length - 1]
        }
    }
      , R = function() {
        return p[p.length - 1]
    }
      , y = function() {
        return p.length > 1
    }
      , k = function() {
        return p[p.length - 1].lookAround === t.LOOKAROUND_BEHIND
    }
      , _ = function() {
        const Z = `${r}initializeAst(): `
          , J = !0;
        for (; J; ) {
            if (n.ast === void 0) {
                n.ast = null;
                break
            }
            if (n.ast === null)
                break;
            if (n.ast.astObject !== "astObject")
                throw new Error(`${Z}ast object not recognized`);
            break
        }
        n.ast !== null && n.ast.init(v, b, m)
    }
      , O = function() {
        const Z = `${r}initializeTrace(): `
          , J = !0;
        for (; J; ) {
            if (n.trace === void 0) {
                n.trace = null;
                break
            }
            if (n.trace === null)
                break;
            if (n.trace.traceObject !== "traceObject")
                throw new Error(`${Z}trace object not recognized`);
            break
        }
        n.trace !== null && n.trace.init(v, b, m)
    }
      , L = function() {
        const Z = `${r}initializeStats(): `
          , J = !0;
        for (; J; ) {
            if (n.stats === void 0) {
                n.stats = null;
                break
            }
            if (n.stats === null)
                break;
            if (n.stats.statsObject !== "statsObject")
                throw new Error(`${Z}stats object not recognized`);
            break
        }
        n.stats !== null && n.stats.init(v, b)
    }
      , U = function(Z) {
        const J = `${r}initializeGrammar(): `;
        if (!Z)
            throw new Error(`${J}grammar object undefined`);
        if (Z.grammarObject !== "grammarObject")
            throw new Error(`${J}bad grammar object`);
        v = Z.rules,
        b = Z.udts
    }
      , $ = function(Z) {
        const J = `${r}initializeStartRule(): `;
        let D = null;
        if (typeof Z == "number") {
            if (Z >= v.length)
                throw new Error(`${J}start rule index too large: max: ${v.length}: index: ${Z}`);
            D = Z
        } else if (typeof Z == "string") {
            const X = Z.toLowerCase();
            for (let ce = 0; ce < v.length; ce += 1)
                if (X === v[ce].lower) {
                    D = v[ce].index;
                    break
                }
            if (D === null)
                throw new Error(`${J}start rule name '${Z}' not recognized`)
        } else
            throw new Error(`${J}type of start rule '${typeof Z}' not recognized`);
        return D
    }
      , B = function(J, D, X) {
        const ce = `${r}initializeInputChars(): `;
        let pe = J
          , ve = D
          , Oe = X;
        if (pe === void 0)
            throw new Error(`${ce}input string is undefined`);
        if (pe === null)
            throw new Error(`${ce}input string is null`);
        if (typeof pe == "string")
            pe = s.stringToChars(pe);
        else if (!Array.isArray(pe))
            throw new Error(`${ce}input string is not a string or array`);
        if (pe.length > 0 && typeof pe[0] != "number")
            throw new Error(`${ce}input string not an array of integers`);
        if (typeof ve != "number")
            ve = 0;
        else if (ve = Math.floor(ve),
        ve < 0 || ve > pe.length)
            throw new Error(`${ce}input beginning index out of range: ${ve}`);
        if (typeof Oe != "number")
            Oe = pe.length - ve;
        else if (Oe = Math.floor(Oe),
        Oe < 0 || Oe > pe.length - ve)
            throw new Error(`${ce}input length out of range: ${Oe}`);
        m = pe,
        f = ve,
        i = Oe,
        l = f + i
    }
      , I = function() {
        const Z = `${r}initializeCallbacks(): `;
        let J;
        for (g = [],
        P = [],
        J = 0; J < v.length; J += 1)
            g[J] = null;
        for (J = 0; J < b.length; J += 1)
            P[J] = null;
        let D;
        const X = [];
        for (J = 0; J < v.length; J += 1)
            X.push(v[J].lower);
        for (J = 0; J < b.length; J += 1)
            X.push(b[J].lower);
        for (const ce in n.callbacks) {
            if (J = X.indexOf(ce.toLowerCase()),
            J < 0)
                throw new Error(`${Z}syntax callback '${ce}' not a rule or udt name`);
            if (D = n.callbacks[ce],
            D || (D = null),
            typeof D == "function" || D === null)
                J < v.length ? g[J] = D : P[J - v.length] = D;
            else
                throw new Error(`${Z}syntax callback[${ce}] must be function reference or 'false' (false/null/undefined/etc.)`)
        }
        for (J = 0; J < b.length; J += 1)
            if (P[J] === null)
                throw new Error(`${Z}all UDT callbacks must be defined. UDT callback[${b[J].lower}] not a function reference`)
    };
    this.setMaxTreeDepth = function(Z) {
        if (typeof Z != "number")
            throw new Error(`parser: max tree depth must be integer > 0: ${Z}`);
        if (E = Math.floor(Z),
        E <= 0)
            throw new Error(`parser: max tree depth must be integer > 0: ${Z}`)
    }
    ,
    this.setMaxNodeHits = function(Z) {
        if (typeof Z != "number")
            throw new Error(`parser: max node hits must be integer > 0: ${Z}`);
        if (w = Math.floor(Z),
        w <= 0)
            throw new Error(`parser: max node hits must be integer > 0: ${Z}`)
    }
    ;
    const F = function(Z, J, D) {
        let X;
        const ce = `${r}parse(): `;
        U(Z);
        const pe = $(J);
        I(),
        O(),
        L(),
        _();
        const ve = new A;
        switch (D != null && (x = D),
        h = [{
            type: t.RNM,
            index: pe
        }],
        d(0, f, ve),
        h = null,
        ve.state) {
        case t.ACTIVE:
            throw new Error(`${ce}final state should never be 'ACTIVE'`);
        case t.NOMATCH:
            X = !1;
            break;
        case t.EMPTY:
        case t.MATCH:
            ve.phraseLength === i ? X = !0 : X = !1;
            break;
        default:
            throw new Error("unrecognized state")
        }
        return {
            success: X,
            state: ve.state,
            length: i,
            matched: ve.phraseLength,
            maxMatched: a,
            maxTreeDepth: c,
            nodeHits: u,
            inputLength: m.length,
            subBegin: f,
            subEnd: l,
            subLength: i
        }
    };
    this.parseSubstring = function(J, D, X, ce, pe, ve) {
        return C(),
        B(X, ce, pe),
        F(J, D, ve)
    }
    ,
    this.parse = function(J, D, X, ce) {
        return C(),
        B(X, 0, X.length),
        F(J, D, ce)
    }
    ;
    const z = function(Z, J, D) {
        const X = h[Z];
        for (let ce = 0; ce < X.children.length && (d(X.children[ce], J, D),
        D.state === t.NOMATCH); ce += 1)
            ;
    }
      , Y = function(Z, J, D) {
        let X, ce, pe, ve;
        const Oe = h[Z]
          , Ge = D.uFrame.length()
          , qe = D.pFrame.length();
        n.ast && (ce = n.ast.getLength()),
        X = !0,
        pe = J,
        ve = 0;
        for (let je = 0; je < Oe.children.length; je += 1)
            if (d(Oe.children[je], pe, D),
            D.state === t.NOMATCH) {
                X = !1;
                break
            } else
                pe += D.phraseLength,
                ve += D.phraseLength;
        X ? (D.state = ve === 0 ? t.EMPTY : t.MATCH,
        D.phraseLength = ve) : (D.state = t.NOMATCH,
        D.phraseLength = 0,
        D.uFrame.pop(Ge),
        D.pFrame.pop(qe),
        n.ast && n.ast.setLength(ce))
    }
      , ie = function(Z, J, D) {
        let X, ce, pe, ve;
        const Oe = h[Z];
        if (Oe.max === 0) {
            D.state = t.EMPTY,
            D.phraseLength = 0;
            return
        }
        ce = J,
        pe = 0,
        ve = 0;
        const Ge = D.uFrame.length()
          , qe = D.pFrame.length();
        n.ast && (X = n.ast.getLength());
        const je = !0;
        for (; je && !(ce >= l || (d(Z + 1, ce, D),
        D.state === t.NOMATCH) || D.state === t.EMPTY || (ve += 1,
        pe += D.phraseLength,
        ce += D.phraseLength,
        ve === Oe.max)); )
            ;
        D.state === t.EMPTY || ve >= Oe.min ? (D.state = pe === 0 ? t.EMPTY : t.MATCH,
        D.phraseLength = pe) : (D.state = t.NOMATCH,
        D.phraseLength = 0,
        D.uFrame.pop(Ge),
        D.pFrame.pop(qe),
        n.ast && n.ast.setLength(X))
    }
      , ne = function(Z, J, D, X) {
        if (J.phraseLength > D) {
            let ce = `${r}opRNM(${Z.name}): callback function error: `;
            throw ce += `sysData.phraseLength: ${J.phraseLength}`,
            ce += ` must be <= remaining chars: ${D}`,
            new Error(ce)
        }
        switch (J.state) {
        case t.ACTIVE:
            if (X !== !0)
                throw new Error(`${r}opRNM(${Z.name}): callback function return error. ACTIVE state not allowed.`);
            break;
        case t.EMPTY:
            J.phraseLength = 0;
            break;
        case t.MATCH:
            J.phraseLength === 0 && (J.state = t.EMPTY);
            break;
        case t.NOMATCH:
            J.phraseLength = 0;
            break;
        default:
            throw new Error(`${r}opRNM(${Z.name}): callback function return error. Unrecognized return state: ${J.state}`)
        }
    }
      , xe = function(Z, J, D) {
        let X, ce, pe, ve, Oe, Ge;
        const qe = h[Z]
          , je = v[qe.index]
          , $e = g[je.index]
          , St = !y();
        if (St && (ce = n.ast && n.ast.ruleDefined(qe.index),
        ce && (X = n.ast.getLength(),
        n.ast.down(qe.index, v[qe.index].name)),
        ve = D.uFrame.length(),
        Oe = D.pFrame.length(),
        D.uFrame.push(),
        D.pFrame.push(),
        Ge = D.pFrame,
        D.pFrame = new N),
        $e === null)
            pe = h,
            h = je.opcodes,
            d(0, J, D),
            h = pe;
        else {
            const zt = l - J;
            D.ruleIndex = je.index,
            $e(D, m, J, x),
            ne(je, D, zt, !0),
            D.state === t.ACTIVE && (pe = h,
            h = je.opcodes,
            d(0, J, D),
            h = pe,
            D.ruleIndex = je.index,
            $e(D, m, J, x),
            ne(je, D, zt, !1))
        }
        St && (ce && (D.state === t.NOMATCH ? n.ast.setLength(X) : n.ast.up(qe.index, je.name, J, D.phraseLength)),
        D.pFrame = Ge,
        D.state === t.NOMATCH ? (D.uFrame.pop(ve),
        D.pFrame.pop(Oe)) : je.isBkr && (D.pFrame.savePhrase(je.lower, J, D.phraseLength),
        D.uFrame.savePhrase(je.lower, J, D.phraseLength)))
    }
      , W = function(Z, J, D) {
        if (J.phraseLength > D) {
            let X = `${r}opUDT(${Z.name}): callback function error: `;
            throw X += `sysData.phraseLength: ${J.phraseLength}`,
            X += ` must be <= remaining chars: ${D}`,
            new Error(X)
        }
        switch (J.state) {
        case t.ACTIVE:
            throw new Error(`${r}opUDT(${Z.name}): callback function return error. ACTIVE state not allowed.`);
        case t.EMPTY:
            if (Z.empty === !1)
                throw new Error(`${r}opUDT(${Z.name}): callback function return error. May not return EMPTY.`);
            J.phraseLength = 0;
            break;
        case t.MATCH:
            if (J.phraseLength === 0) {
                if (Z.empty === !1)
                    throw new Error(`${r}opUDT(${Z.name}): callback function return error. May not return EMPTY.`);
                J.state = t.EMPTY
            }
            break;
        case t.NOMATCH:
            J.phraseLength = 0;
            break;
        default:
            throw new Error(`${r}opUDT(${Z.name}): callback function return error. Unrecognized return state: ${J.state}`)
        }
    }
      , ee = function(Z, J, D) {
        let X, ce, pe, ve, Oe, Ge;
        const qe = h[Z]
          , je = b[qe.index];
        D.UdtIndex = je.index;
        const $e = !y();
        $e && (pe = n.ast && n.ast.udtDefined(qe.index),
        pe && (ce = v.length + qe.index,
        X = n.ast.getLength(),
        n.ast.down(ce, je.name)),
        ve = D.uFrame.length(),
        Oe = D.pFrame.length(),
        D.uFrame.push(),
        D.pFrame.push(),
        Ge = D.pFrame,
        D.pFrame = new N);
        const St = l - J;
        P[qe.index](D, m, J, x),
        W(je, D, St),
        $e && (pe && (D.state === t.NOMATCH ? n.ast.setLength(X) : n.ast.up(ce, je.name, J, D.phraseLength)),
        D.pFrame = Ge,
        D.state === t.NOMATCH ? (D.uFrame.pop(ve),
        D.pFrame.pop(Oe)) : je.isBkr && (D.pFrame.savePhrase(je.lower, J, D.phraseLength),
        D.uFrame.savePhrase(je.lower, J, D.phraseLength)))
    }
      , te = function(Z, J, D) {
        p.push({
            lookAround: t.LOOKAROUND_AHEAD,
            anchor: J,
            charsEnd: l,
            charsLength: i
        }),
        l = m.length,
        i = m.length - f,
        d(Z + 1, J, D);
        const X = p.pop();
        switch (l = X.charsEnd,
        i = X.charsLength,
        D.phraseLength = 0,
        D.state) {
        case t.EMPTY:
            D.state = t.EMPTY;
            break;
        case t.MATCH:
            D.state = t.EMPTY;
            break;
        case t.NOMATCH:
            D.state = t.NOMATCH;
            break;
        default:
            throw new Error(`opAND: invalid state ${D.state}`)
        }
    }
      , fe = function(Z, J, D) {
        p.push({
            lookAround: t.LOOKAROUND_AHEAD,
            anchor: J,
            charsEnd: l,
            charsLength: i
        }),
        l = m.length,
        i = m.length - f,
        d(Z + 1, J, D);
        const X = p.pop();
        switch (l = X.charsEnd,
        i = X.charsLength,
        D.phraseLength = 0,
        D.state) {
        case t.EMPTY:
        case t.MATCH:
            D.state = t.NOMATCH;
            break;
        case t.NOMATCH:
            D.state = t.EMPTY;
            break;
        default:
            throw new Error(`opNOT: invalid state ${D.state}`)
        }
    }
      , be = function(Z, J, D) {
        const X = h[Z];
        D.state = t.NOMATCH,
        J < l && X.min <= m[J] && m[J] <= X.max && (D.state = t.MATCH,
        D.phraseLength = 1)
    }
      , le = function(Z, J, D) {
        let X;
        const ce = h[Z]
          , pe = ce.string.length;
        if (D.state = t.NOMATCH,
        J + pe <= l) {
            for (X = 0; X < pe; X += 1)
                if (m[J + X] !== ce.string[X])
                    return;
            D.state = t.MATCH,
            D.phraseLength = pe
        }
    }
      , re = function(Z, J, D) {
        let X, ce;
        const pe = h[Z];
        D.state = t.NOMATCH;
        const ve = pe.string.length;
        if (ve === 0) {
            D.state = t.EMPTY;
            return
        }
        if (J + ve <= l) {
            for (X = 0; X < ve; X += 1)
                if (ce = m[J + X],
                ce >= 65 && ce <= 90 && (ce += 32),
                ce !== pe.string[X])
                    return;
            D.state = t.MATCH,
            D.phraseLength = ve
        }
    }
      , M = function(Z, J, D) {
        D.state = t.NOMATCH,
        D.phraseLength = 0,
        D.state = J === 0 ? t.EMPTY : t.NOMATCH
    }
      , K = function(Z, J, D) {
        D.state = t.NOMATCH,
        D.phraseLength = 0,
        D.state = J === m.length ? t.EMPTY : t.NOMATCH
    }
      , V = function(Z, J, D) {
        let X, ce, pe, ve;
        const Oe = h[Z];
        D.state = t.NOMATCH,
        Oe.index < v.length ? ve = v[Oe.index].lower : ve = b[Oe.index - v.length].lower;
        const Ge = Oe.bkrMode === t.BKR_MODE_PM ? D.pFrame.getPhrase(ve) : D.uFrame.getPhrase(ve)
          , qe = Oe.bkrCase === t.BKR_MODE_CI;
        if (Ge === null)
            return;
        const je = Ge.phraseIndex
          , $e = Ge.phraseLength;
        if ($e === 0) {
            D.state = t.EMPTY;
            return
        }
        if (J + $e <= l) {
            if (qe) {
                for (X = 0; X < $e; X += 1)
                    if (ce = m[J + X],
                    pe = m[je + X],
                    ce >= 65 && ce <= 90 && (ce += 32),
                    pe >= 65 && pe <= 90 && (pe += 32),
                    ce !== pe)
                        return;
                D.state = t.MATCH,
                D.phraseLength = $e
            } else
                for (X = 0; X < $e; X += 1)
                    if (ce = m[J + X],
                    pe = m[je + X],
                    ce !== pe)
                        return;
            D.state = t.MATCH,
            D.phraseLength = $e
        }
    }
      , oe = function(Z, J, D) {
        switch (p.push({
            lookAround: t.LOOKAROUND_BEHIND,
            anchor: J
        }),
        d(Z + 1, J, D),
        p.pop(),
        D.phraseLength = 0,
        D.state) {
        case t.EMPTY:
            D.state = t.EMPTY;
            break;
        case t.MATCH:
            D.state = t.EMPTY;
            break;
        case t.NOMATCH:
            D.state = t.NOMATCH;
            break;
        default:
            throw new Error(`opBKA: invalid state ${D.state}`)
        }
    }
      , me = function(Z, J, D) {
        switch (p.push({
            lookAround: t.LOOKAROUND_BEHIND,
            anchor: J
        }),
        d(Z + 1, J, D),
        p.pop(),
        D.phraseLength = 0,
        D.state) {
        case t.EMPTY:
        case t.MATCH:
            D.state = t.NOMATCH;
            break;
        case t.NOMATCH:
            D.state = t.EMPTY;
            break;
        default:
            throw new Error(`opBKN: invalid state ${D.state}`)
        }
    }
      , Pe = function(Z, J, D) {
        let X, ce, pe, ve;
        const Oe = h[Z]
          , Ge = D.uFrame.length()
          , qe = D.pFrame.length();
        n.ast && (ce = n.ast.getLength()),
        X = !0,
        pe = J,
        ve = 0;
        for (let je = Oe.children.length - 1; je >= 0; je -= 1)
            if (d(Oe.children[je], pe, D),
            pe -= D.phraseLength,
            ve += D.phraseLength,
            D.state === t.NOMATCH) {
                X = !1;
                break
            }
        X ? (D.state = ve === 0 ? t.EMPTY : t.MATCH,
        D.phraseLength = ve) : (D.state = t.NOMATCH,
        D.phraseLength = 0,
        D.uFrame.pop(Ge),
        D.pFrame.pop(qe),
        n.ast && n.ast.setLength(ce))
    }
      , se = function(Z, J, D) {
        let X, ce, pe, ve;
        const Oe = h[Z];
        ce = J,
        pe = 0,
        ve = 0;
        const Ge = D.uFrame.length()
          , qe = D.pFrame.length();
        n.ast && (X = n.ast.getLength());
        const je = !0;
        for (; je && !(ce <= 0 || (d(Z + 1, ce, D),
        D.state === t.NOMATCH) || D.state === t.EMPTY || (ve += 1,
        pe += D.phraseLength,
        ce -= D.phraseLength,
        ve === Oe.max)); )
            ;
        D.state === t.EMPTY || ve >= Oe.min ? (D.state = pe === 0 ? t.EMPTY : t.MATCH,
        D.phraseLength = pe) : (D.state = t.NOMATCH,
        D.phraseLength = 0,
        D.uFrame.pop(Ge),
        D.pFrame.pop(qe),
        n.ast && n.ast.setLength(X))
    }
      , H = function(Z, J, D) {
        const X = h[Z];
        if (D.state = t.NOMATCH,
        D.phraseLength = 0,
        J > 0) {
            const ce = m[J - 1];
            X.min <= ce && ce <= X.max && (D.state = t.MATCH,
            D.phraseLength = 1)
        }
    }
      , G = function(Z, J, D) {
        let X;
        const ce = h[Z];
        D.state = t.NOMATCH;
        const pe = ce.string.length
          , ve = J - pe;
        if (ve >= 0) {
            for (X = 0; X < pe; X += 1)
                if (m[ve + X] !== ce.string[X])
                    return;
            D.state = t.MATCH,
            D.phraseLength = pe
        }
    }
      , q = function(Z, J, D) {
        let X;
        const ce = h[Z];
        D.state = t.NOMATCH;
        const pe = ce.string.length;
        if (pe === 0) {
            D.state = t.EMPTY;
            return
        }
        const ve = J - pe;
        if (ve >= 0) {
            for (let Oe = 0; Oe < pe; Oe += 1)
                if (X = m[ve + Oe],
                X >= 65 && X <= 90 && (X += 32),
                X !== ce.string[Oe])
                    return;
            D.state = t.MATCH,
            D.phraseLength = pe
        }
    }
      , ae = function(Z, J, D) {
        let X, ce, pe, ve;
        const Oe = h[Z];
        D.state = t.NOMATCH,
        D.phraseLength = 0,
        Oe.index < v.length ? ve = v[Oe.index].lower : ve = b[Oe.index - v.length].lower;
        const Ge = Oe.bkrMode === t.BKR_MODE_PM ? D.pFrame.getPhrase(ve) : D.uFrame.getPhrase(ve)
          , qe = Oe.bkrCase === t.BKR_MODE_CI;
        if (Ge === null)
            return;
        const je = Ge.phraseIndex
          , $e = Ge.phraseLength;
        if ($e === 0) {
            D.state = t.EMPTY,
            D.phraseLength = 0;
            return
        }
        const St = J - $e;
        if (St >= 0) {
            if (qe) {
                for (X = 0; X < $e; X += 1)
                    if (ce = m[St + X],
                    pe = m[je + X],
                    ce >= 65 && ce <= 90 && (ce += 32),
                    pe >= 65 && pe <= 90 && (pe += 32),
                    ce !== pe)
                        return;
                D.state = t.MATCH,
                D.phraseLength = $e
            } else
                for (X = 0; X < $e; X += 1)
                    if (ce = m[St + X],
                    pe = m[je + X],
                    ce !== pe)
                        return;
            D.state = t.MATCH,
            D.phraseLength = $e
        }
    };
    d = function(J, D, X) {
        let ce = !0;
        const pe = h[J];
        if (u += 1,
        u > w)
            throw new Error(`parser: maximum number of node hits exceeded: ${w}`);
        if (o += 1,
        o > c && (c = o,
        c > E))
            throw new Error(`parser: maximum parse tree depth exceeded: ${E}`);
        if (X.refresh(),
        n.trace !== null) {
            const ve = R();
            n.trace.down(pe, X.state, D, X.phraseLength, ve.anchor, ve.lookAround)
        }
        if (k())
            switch (pe.type) {
            case t.ALT:
                z(J, D, X);
                break;
            case t.CAT:
                Pe(J, D, X);
                break;
            case t.REP:
                se(J, D, X);
                break;
            case t.RNM:
                xe(J, D, X);
                break;
            case t.UDT:
                ee(J, D, X);
                break;
            case t.AND:
                te(J, D, X);
                break;
            case t.NOT:
                fe(J, D, X);
                break;
            case t.TRG:
                H(J, D, X);
                break;
            case t.TBS:
                G(J, D, X);
                break;
            case t.TLS:
                q(J, D, X);
                break;
            case t.BKR:
                ae(J, D, X);
                break;
            case t.BKA:
                oe(J, D, X);
                break;
            case t.BKN:
                me(J, D, X);
                break;
            case t.ABG:
                M(J, D, X);
                break;
            case t.AEN:
                K(J, D, X);
                break;
            default:
                ce = !1;
                break
            }
        else
            switch (pe.type) {
            case t.ALT:
                z(J, D, X);
                break;
            case t.CAT:
                Y(J, D, X);
                break;
            case t.REP:
                ie(J, D, X);
                break;
            case t.RNM:
                xe(J, D, X);
                break;
            case t.UDT:
                ee(J, D, X);
                break;
            case t.AND:
                te(J, D, X);
                break;
            case t.NOT:
                fe(J, D, X);
                break;
            case t.TRG:
                be(J, D, X);
                break;
            case t.TBS:
                le(J, D, X);
                break;
            case t.TLS:
                re(J, D, X);
                break;
            case t.BKR:
                V(J, D, X);
                break;
            case t.BKA:
                oe(J, D, X);
                break;
            case t.BKN:
                me(J, D, X);
                break;
            case t.ABG:
                M(J, D, X);
                break;
            case t.AEN:
                K(J, D, X);
                break;
            default:
                ce = !1;
                break
            }
        if (!y() && D + X.phraseLength > a && (a = D + X.phraseLength),
        n.stats !== null && n.stats.collect(pe, X),
        n.trace !== null) {
            const ve = R();
            n.trace.up(pe, X.state, D, X.phraseLength, ve.anchor, ve.lookAround)
        }
        return o -= 1,
        ce
    }
}
  , td = function() {
    const t = jr
      , s = Mr
      , r = Ts
      , n = "stats.js: ";
    let d = []
      , h = [];
    const m = [];
    let f;
    const i = []
      , l = [];
    this.statsObject = "statsObject";
    const p = "stats"
      , o = function(w, S) {
        return w.lower < S.lower ? -1 : w.lower > S.lower ? 1 : 0
    }
      , c = function(w, S) {
        return w.total < S.total ? 1 : w.total > S.total ? -1 : o(w, S)
    }
      , u = function(w, S) {
        return w.index < S.index ? -1 : w.index > S.index ? 1 : 0
    }
      , g = function() {
        this.empty = 0,
        this.match = 0,
        this.nomatch = 0,
        this.total = 0
    }
      , P = function() {
        m.length = 0,
        f = new g,
        m[t.ALT] = new g,
        m[t.CAT] = new g,
        m[t.REP] = new g,
        m[t.RNM] = new g,
        m[t.TRG] = new g,
        m[t.TBS] = new g,
        m[t.TLS] = new g,
        m[t.UDT] = new g,
        m[t.AND] = new g,
        m[t.NOT] = new g,
        m[t.BKR] = new g,
        m[t.BKA] = new g,
        m[t.BKN] = new g,
        m[t.ABG] = new g,
        m[t.AEN] = new g,
        i.length = 0;
        for (let w = 0; w < d.length; w += 1)
            i.push({
                empty: 0,
                match: 0,
                nomatch: 0,
                total: 0,
                name: d[w].name,
                lower: d[w].lower,
                index: d[w].index
            });
        if (h.length > 0) {
            l.length = 0;
            for (let w = 0; w < h.length; w += 1)
                l.push({
                    empty: 0,
                    match: 0,
                    nomatch: 0,
                    total: 0,
                    name: h[w].name,
                    lower: h[w].lower,
                    index: h[w].index
                })
        }
    }
      , v = function(w, S) {
        switch (w.total += 1,
        S) {
        case t.EMPTY:
            w.empty += 1;
            break;
        case t.MATCH:
            w.match += 1;
            break;
        case t.NOMATCH:
            w.nomatch += 1;
            break;
        default:
            throw new Error(`${n}collect(): incStat(): unrecognized state: ${S}`)
        }
    }
      , b = function(w, S) {
        let T = "";
        return T += "<tr>",
        T += `<td class="${r.CLASS_ACTIVE}">${w}</td>`,
        T += `<td class="${r.CLASS_EMPTY}">${S.empty}</td>`,
        T += `<td class="${r.CLASS_MATCH}">${S.match}</td>`,
        T += `<td class="${r.CLASS_NOMATCH}">${S.nomatch}</td>`,
        T += `<td class="${r.CLASS_ACTIVE}">${S.total}</td>`,
        T += `</tr>
`,
        T
    }
      , x = function() {
        let w = "";
        return w += b("ALT", m[t.ALT]),
        w += b("CAT", m[t.CAT]),
        w += b("REP", m[t.REP]),
        w += b("RNM", m[t.RNM]),
        w += b("TRG", m[t.TRG]),
        w += b("TBS", m[t.TBS]),
        w += b("TLS", m[t.TLS]),
        w += b("UDT", m[t.UDT]),
        w += b("AND", m[t.AND]),
        w += b("NOT", m[t.NOT]),
        w += b("BKR", m[t.BKR]),
        w += b("BKA", m[t.BKA]),
        w += b("BKN", m[t.BKN]),
        w += b("ABG", m[t.ABG]),
        w += b("AEN", m[t.AEN]),
        w += b("totals", f),
        w
    }
      , a = function() {
        let w = "";
        w += `<tr><th></th><th></th><th></th><th></th><th></th></tr>
`,
        w += `<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>
`;
        for (let S = 0; S < d.length; S += 1)
            i[S].total > 0 && (w += "<tr>",
            w += `<td class="${r.CLASS_ACTIVE}">${i[S].name}</td>`,
            w += `<td class="${r.CLASS_EMPTY}">${i[S].empty}</td>`,
            w += `<td class="${r.CLASS_MATCH}">${i[S].match}</td>`,
            w += `<td class="${r.CLASS_NOMATCH}">${i[S].nomatch}</td>`,
            w += `<td class="${r.CLASS_ACTIVE}">${i[S].total}</td>`,
            w += `</tr>
`);
        if (h.length > 0) {
            w += `<tr><th></th><th></th><th></th><th></th><th></th></tr>
`,
            w += `<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>
`;
            for (let S = 0; S < h.length; S += 1)
                l[S].total > 0 && (w += "<tr>",
                w += `<td class="${r.CLASS_ACTIVE}">${l[S].name}</td>`,
                w += `<td class="${r.CLASS_EMPTY}">${l[S].empty}</td>`,
                w += `<td class="${r.CLASS_MATCH}">${l[S].match}</td>`,
                w += `<td class="${r.CLASS_NOMATCH}">${l[S].nomatch}</td>`,
                w += `<td class="${r.CLASS_ACTIVE}">${l[S].total}</td>`,
                w += `</tr>
`)
        }
        return w
    };
    this.validate = function(w) {
        let S = !1;
        return typeof w == "string" && p === w && (S = !0),
        S
    }
    ,
    this.init = function(w, S) {
        d = w,
        h = S,
        P()
    }
    ,
    this.collect = function(w, S) {
        v(f, S.state, S.phraseLength),
        v(m[w.type], S.state, S.phraseLength),
        w.type === t.RNM && v(i[w.index], S.state, S.phraseLength),
        w.type === t.UDT && v(l[w.index], S.state, S.phraseLength)
    }
    ,
    this.toHtml = function(w, S) {
        let T = "";
        T += `<table class="${r.CLASS_STATS}">
`,
        typeof S == "string" && (T += `<caption>${S}</caption>
`),
        T += `<tr><th class="${r.CLASS_ACTIVE}">ops</th>
`,
        T += `<th class="${r.CLASS_EMPTY}">EMPTY</th>
`,
        T += `<th class="${r.CLASS_MATCH}">MATCH</th>
`,
        T += `<th class="${r.CLASS_NOMATCH}">NOMATCH</th>
`,
        T += `<th class="${r.CLASS_ACTIVE}">totals</th></tr>
`;
        const C = !0;
        for (; C; ) {
            if (w === void 0) {
                T += x();
                break
            }
            if (w === null) {
                T += x();
                break
            }
            if (w === "ops") {
                T += x();
                break
            }
            if (w === "index") {
                i.sort(u),
                l.length > 0 && l.sort(u),
                T += x(),
                T += a();
                break
            }
            if (w === "hits") {
                i.sort(c),
                l.length > 0 && l.sort(u),
                T += x(),
                T += a();
                break
            }
            if (w === "alpha") {
                i.sort(o),
                l.length > 0 && l.sort(o),
                T += x(),
                T += a();
                break
            }
            break
        }
        return T += `</table>
`,
        T
    }
    ,
    this.toHtmlPage = function(w, S, T) {
        return s.htmlToPage(this.toHtml(w, S), T)
    }
}
  , rd = function() {
    const t = Mr
      , s = Ts
      , r = new du
      , n = jr
      , d = "trace.js: "
      , h = this
      , m = 16
      , f = 10
      , i = 8
      , l = 32
      , p = 80
      , o = 5
      , c = [];
    let u = 5e3
      , g = -1
      , P = 0
      , v = 0;
    const b = [];
    let x = null
      , a = null
      , E = null;
    const w = []
      , S = []
      , T = `<span class="${s.CLASS_LINEEND}">&bull;</span>`
      , C = `<span class="${s.CLASS_LINEEND}">&hellip;</span>`
      , N = `<span class="${s.CLASS_EMPTY}">&#120634;</span>`
      , A = function() {
        const W = function(te) {
            w[n.ALT] = te,
            w[n.CAT] = te,
            w[n.REP] = te,
            w[n.TLS] = te,
            w[n.TBS] = te,
            w[n.TRG] = te,
            w[n.AND] = te,
            w[n.NOT] = te,
            w[n.BKR] = te,
            w[n.BKA] = te,
            w[n.BKN] = te,
            w[n.ABG] = te,
            w[n.AEN] = te
        };
        let ee = 0;
        for (const te in h.filter.operators)
            ee += 1;
        if (ee === 0) {
            W(!1);
            return
        }
        for (const te in h.filter.operators) {
            const fe = te.toUpperCase();
            if (fe === "<ALL>") {
                W(!0);
                return
            }
            if (fe === "<NONE>") {
                W(!1);
                return
            }
        }
        W(!1);
        for (const te in h.filter.operators) {
            const fe = te.toUpperCase();
            if (fe === "ALT")
                w[n.ALT] = h.filter.operators[te] === !0;
            else if (fe === "CAT")
                w[n.CAT] = h.filter.operators[te] === !0;
            else if (fe === "REP")
                w[n.REP] = h.filter.operators[te] === !0;
            else if (fe === "AND")
                w[n.AND] = h.filter.operators[te] === !0;
            else if (fe === "NOT")
                w[n.NOT] = h.filter.operators[te] === !0;
            else if (fe === "TLS")
                w[n.TLS] = h.filter.operators[te] === !0;
            else if (fe === "TBS")
                w[n.TBS] = h.filter.operators[te] === !0;
            else if (fe === "TRG")
                w[n.TRG] = h.filter.operators[te] === !0;
            else if (fe === "BKR")
                w[n.BKR] = h.filter.operators[te] === !0;
            else if (fe === "BKA")
                w[n.BKA] = h.filter.operators[te] === !0;
            else if (fe === "BKN")
                w[n.BKN] = h.filter.operators[te] === !0;
            else if (fe === "ABG")
                w[n.ABG] = h.filter.operators[te] === !0;
            else if (fe === "AEN")
                w[n.AEN] = h.filter.operators[te] === !0;
            else
                throw new Error(`${d}initOpratorFilter: '${te}' not a valid operator name. Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`)
        }
    }
      , R = function() {
        const W = function(be) {
            w[n.RNM] = be,
            w[n.UDT] = be;
            const le = a.length + E.length;
            S.length = 0;
            for (let re = 0; re < le; re += 1)
                S.push(be)
        };
        let ee, te;
        const fe = [];
        for (te = 0; te < a.length; te += 1)
            fe.push(a[te].lower);
        for (te = 0; te < E.length; te += 1)
            fe.push(E[te].lower);
        S.length = 0,
        ee = 0;
        for (const be in h.filter.rules)
            ee += 1;
        if (ee === 0) {
            W(!0);
            return
        }
        for (const be in h.filter.rules) {
            const le = be.toLowerCase();
            if (le === "<all>") {
                W(!0);
                return
            }
            if (le === "<none>") {
                W(!1);
                return
            }
        }
        W(!1),
        w[n.RNM] = !0,
        w[n.UDT] = !0;
        for (const be in h.filter.rules) {
            const le = be.toLowerCase();
            if (te = fe.indexOf(le),
            te < 0)
                throw new Error(`${d}initRuleFilter: '${be}' not a valid rule or udt name`);
            S[te] = h.filter.rules[be] === !0
        }
    };
    this.traceObject = "traceObject",
    this.filter = {
        operators: [],
        rules: []
    },
    this.setMaxRecords = function(W, ee) {
        if (g = -1,
        typeof W == "number" && W > 0)
            u = Math.ceil(W);
        else {
            u = 0;
            return
        }
        typeof ee == "number" && (g = Math.floor(ee),
        g < 0 && (g = -1))
    }
    ,
    this.getMaxRecords = function() {
        return u
    }
    ,
    this.getLastRecord = function() {
        return g
    }
    ,
    this.init = function(W, ee, te) {
        c.length = 0,
        b.length = 0,
        P = 0,
        v = 0,
        x = te,
        a = W,
        E = ee,
        A(),
        R(),
        r.init(u)
    }
    ;
    const y = function(W) {
        let ee = !1;
        return W.type === n.RNM ? w[W.type] && S[W.index] ? ee = !0 : ee = !1 : W.type === n.UDT ? w[W.type] && S[a.length + W.index] ? ee = !0 : ee = !1 : ee = w[W.type],
        ee
    }
      , k = function(W) {
        return g === -1 || W <= g
    };
    this.down = function(W, ee, te, fe, be, le) {
        k(P) && y(W) && (b.push(P),
        c[r.increment()] = {
            dirUp: !1,
            depth: v,
            thisLine: P,
            thatLine: void 0,
            opcode: W,
            state: ee,
            phraseIndex: te,
            phraseLength: fe,
            lookAnchor: be,
            lookAround: le
        },
        P += 1,
        v += 1)
    }
    ,
    this.up = function(W, ee, te, fe, be, le) {
        if (k(P) && y(W)) {
            const re = P
              , M = b.pop()
              , K = r.getListIndex(M);
            K !== -1 && (c[K].thatLine = re),
            v -= 1,
            c[r.increment()] = {
                dirUp: !0,
                depth: v,
                thisLine: re,
                thatLine: M,
                opcode: W,
                state: ee,
                phraseIndex: te,
                phraseLength: fe,
                lookAnchor: be,
                lookAround: le
            },
            P += 1
        }
    }
    ;
    const _ = function() {
        function W(D, X) {
            let ce, pe, ve;
            if (X)
                switch (D.op = {
                    id: X.type,
                    name: t.opcodeToString(X.type)
                },
                D.opData = void 0,
                X.type) {
                case n.RNM:
                    D.opData = a[X.index].name;
                    break;
                case n.UDT:
                    D.opData = E[X.index].name;
                    break;
                case n.BKR:
                    X.index < a.length ? ce = a[X.index].name : ce = E[X.index - a.length].name,
                    pe = X.bkrCase === n.BKR_MODE_CI ? "%i" : "%s",
                    ve = X.bkrMode === n.BKR_MODE_UM ? "%u" : "%p",
                    D.opData = `\\\\${pe}${ve}${ce}`;
                    break;
                case n.TLS:
                    D.opData = [];
                    for (let Oe = 0; Oe < X.string.length; Oe += 1)
                        D.opData.push(X.string[Oe]);
                    break;
                case n.TBS:
                    D.opData = [];
                    for (let Oe = 0; Oe < X.string.length; Oe += 1)
                        D.opData.push(X.string[Oe]);
                    break;
                case n.TRG:
                    D.opData = [X.min, X.max];
                    break;
                case n.REP:
                    D.opData = [X.min, X.max];
                    break;
                default:
                    throw new Error("unrecognized opcode")
                }
            else
                D.op = {
                    id: void 0,
                    name: void 0
                },
                D.opData = void 0
        }
        function ee(D, X, ce) {
            return D === n.MATCH ? {
                index: X,
                length: ce
            } : D === n.NOMATCH ? {
                index: X,
                length: 0
            } : D === n.EMPTY ? {
                index: X,
                length: 0
            } : null
        }
        let te = -1;
        function fe(D, X, ce) {
            const pe = {
                id: te++,
                branch: -1,
                parent: D,
                up: !1,
                down: !1,
                depth: ce,
                children: []
            };
            return X ? (pe.down = !0,
            pe.state = {
                id: X.state,
                name: t.stateToString(X.state)
            },
            pe.phrase = null,
            W(pe, X.opcode)) : (pe.state = {
                id: void 0,
                name: void 0
            },
            pe.phrase = ee(),
            W(pe, void 0)),
            pe
        }
        function be(D, X) {
            X && (D.up = !0,
            D.state = {
                id: X.state,
                name: t.stateToString(X.state)
            },
            D.phrase = ee(X.state, X.phraseIndex, X.phraseLength),
            D.down || W(D, X.opcode))
        }
        let le = 0
          , re = -1
          , M = 1;
        function K(D) {
            if (re += 1,
            D.branch = M,
            re > v && (v = re),
            D.children.length === 0)
                le += 1;
            else
                for (let X = 0; X < D.children.length; X += 1)
                    X > 0 && (M += 1),
                    D.children[X].leftMost = !1,
                    D.children[X].rightMost = !1,
                    D.leftMost && (D.children[X].leftMost = X === 0),
                    D.rightMost && (D.children[X].rightMost = X === D.children.length - 1),
                    K(D.children[X]);
            re -= 1
        }
        function V(D, X) {
            let ce;
            const pe = {};
            if (pe.id = D.id,
            pe.branch = D.branch,
            pe.leftMost = D.leftMost,
            pe.rightMost = D.rightMost,
            ce = D.state.name ? D.state.name : "ACTIVE",
            pe.state = {
                id: D.state.id,
                name: ce
            },
            ce = D.op.name ? D.op.name : "?",
            pe.op = {
                id: D.op.id,
                name: ce
            },
            typeof D.opData == "string")
                pe.opData = D.opData;
            else if (Array.isArray(D.opData)) {
                pe.opData = [];
                for (let ve = 0; ve < D.opData.length; ve += 1)
                    pe.opData[ve] = D.opData[ve]
            } else
                pe.opData = void 0;
            D.phrase ? pe.phrase = {
                index: D.phrase.index,
                length: D.phrase.length
            } : pe.phrase = null,
            pe.depth = D.depth,
            pe.children = [];
            for (let ve = 0; ve < D.children.length; ve += 1)
                D.children.length - 1,
                pe.children[ve] = V(D.children[ve]);
            return pe
        }
 const oe = [];
        let me, Pe, se, H, G = !0;
        const q = fe(null, null, -1);
        for (oe.push(q),
        Pe = q,
        r.forEach(D => {
            if (H = c[D],
            G && (G = !1,
            H.depth > 0)) {
                const X = H.dirUp ? H.depth + 1 : H.depth;
                for (let ce = 0; ce < X; ce += 1)
                    se = Pe,
                    Pe = fe(Pe, null, ce),
                    oe.push(Pe),
                    se.children.push(Pe)
            }
            H.dirUp ? (Pe = oe.pop(),
            be(Pe, H),
            Pe = oe[oe.length - 1]) : (se = Pe,
            Pe = fe(Pe, H, H.depth),
            oe.push(Pe),
            se.children.push(Pe))
        }
        ); oe.length > 1; )
            Pe = oe.pop(),
            be(Pe, null);
        if (q.children.length === 0)
            throw new Error("trace.toTree(): parse tree has no nodes");
        if (oe.length === 0)
            throw new Error("trace.toTree(): integrity check: dummy root node disappeared?");
        me = q.children[0];
        let ae = me;
        for (; me && !me.down && !me.up; )
            ae = me,
            me = me.children[0];
        me = ae,
        me.leftMost = !0,
        me.rightMost = !0,
        K(me),
        me.branch = 0;
        const Z = {};
        Z.string = [];
        for (let D = 0; D < x.length; D += 1)
            Z.string[D] = x[D];
        Z.rules = [];
        for (let D = 0; D < a.length; D += 1)
            Z.rules[D] = a[D].name;
        Z.udts = [];
        for (let D = 0; D < E.length; D += 1)
            Z.udts[D] = E[D].name;
        Z.id = {},
        Z.id.ALT = {
            id: n.ALT,
            name: "ALT"
        },
        Z.id.CAT = {
            id: n.CAT,
            name: "CAT"
        },
        Z.id.REP = {
            id: n.REP,
            name: "REP"
        },
        Z.id.RNM = {
            id: n.RNM,
            name: "RNM"
        },
        Z.id.TLS = {
            id: n.TLS,
            name: "TLS"
        },
        Z.id.TBS = {
            id: n.TBS,
            name: "TBS"
        },
        Z.id.TRG = {
            id: n.TRG,
            name: "TRG"
        },
        Z.id.UDT = {
            id: n.UDT,
            name: "UDT"
        },
        Z.id.AND = {
            id: n.AND,
            name: "AND"
        },
        Z.id.NOT = {
            id: n.NOT,
            name: "NOT"
        },
        Z.id.BKR = {
            id: n.BKR,
            name: "BKR"
        },
        Z.id.BKA = {
            id: n.BKA,
            name: "BKA"
        },
        Z.id.BKN = {
            id: n.BKN,
            name: "BKN"
        },
        Z.id.ABG = {
            id: n.ABG,
            name: "ABG"
        },
        Z.id.AEN = {
            id: n.AEN,
            name: "AEN"
        },
        Z.id.ACTIVE = {
            id: n.ACTIVE,
            name: "ACTIVE"
        },
        Z.id.MATCH = {
            id: n.MATCH,
            name: "MATCH"
        },
        Z.id.EMPTY = {
            id: n.EMPTY,
            name: "EMPTY"
        },
        Z.id.NOMATCH = {
            id: n.NOMATCH,
            name: "NOMATCH"
        },
        Z.treeDepth = v,
        Z.leafNodes = le;
        let J;
        return me.down ? me.up ? J = "none" : J = "right" : me.up ? J = "left" : J = "both",
        Z.branchesIncomplete = J,
        Z.tree = V(me, me.depth),
        Z
    };
    this.toTree = function(W) {
        const ee = _();
        return W ? JSON.stringify(ee) : ee
    }
    ,
    this.toHtmlPage = function(W, ee, te) {
        return t.htmlToPage(this.toHtml(W, ee), te)
    }
    ;
    const O = function(W, ee) {
        let te;
        switch (W) {
        case m:
            te = "hexadecimal";
            break;
        case f:
            te = "decimal";
            break;
        case i:
            te = "ASCII";
            break;
        case l:
            te = "UNICODE";
            break;
        default:
            throw new Error(`${d}htmlHeader: unrecognized mode: ${W}`)
        }
        let fe = "";
        return fe += `<p>display mode: ${te}</p>
`,
        fe += `<table class="${s.CLASS_TRACE}">
`,
        typeof ee == "string" && (fe += `<caption>${ee}</caption>`),
        fe
    }
      , L = function() {
        let W = "";
        return W += `</table>
`,
        W += `<p class="${s.CLASS_MONOSPACE}">legend:<br>
`,
        W += `(a)&nbsp;-&nbsp;line number<br>
`,
        W += `(b)&nbsp;-&nbsp;matching line number<br>
`,
        W += `(c)&nbsp;-&nbsp;phrase offset<br>
`,
        W += `(d)&nbsp;-&nbsp;phrase length<br>
`,
        W += `(e)&nbsp;-&nbsp;tree depth<br>
`,
        W += `(f)&nbsp;-&nbsp;operator state<br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${s.CLASS_ACTIVE}">&darr;</span>&nbsp;&nbsp;phrase opened<br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${s.CLASS_MATCH}">&uarr;M</span> phrase matched<br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${s.CLASS_EMPTY}">&uarr;E</span> empty phrase matched<br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${s.CLASS_NOMATCH}">&uarr;N</span> phrase not matched<br>
`,
        W += `operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>
`,
        W += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${p} characters of the phrase being matched<br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${s.CLASS_MATCH}">matched characters</span><br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${s.CLASS_LOOKAHEAD}">matched characters in look ahead mode</span><br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${s.CLASS_LOOKBEHIND}">matched characters in look behind mode</span><br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${s.CLASS_REMAINDER}">remainder characters(not yet examined by parser)</span><br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${s.CLASS_CTRLCHAR}">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${N} empty string<br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${T} end of input string<br>
`,
        W += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${C} input string display truncated<br>
`,
        W += `</p>
`,
        W += `<p class="${s.CLASS_MONOSPACE}">
`,
        W += `<sup>&dagger;</sup>original ABNF operators:<br>
`,
        W += `ALT - alternation<br>
`,
        W += `CAT - concatenation<br>
`,
        W += `REP - repetition<br>
`,
        W += `RNM - rule name<br>
`,
        W += `TRG - terminal range<br>
`,
        W += `TLS - terminal literal string (case insensitive)<br>
`,
        W += `TBS - terminal binary string (case sensitive)<br>
`,
        W += `<br>
`,
        W += `<sup>&Dagger;</sup>super set SABNF operators:<br>
`,
        W += `UDT - user-defined terminal<br>
`,
        W += `AND - positive look ahead<br>
`,
        W += `NOT - negative look ahead<br>
`,
        W += `BKA - positive look behind<br>
`,
        W += `BKN - negative look behind<br>
`,
        W += `BKR - back reference<br>
`,
        W += `ABG - anchor - begin of input string<br>
`,
        W += `AEN - anchor - end of input string<br>
`,
        W += `</p>
`,
        W
    };
    this.indent = function(W) {
        let ee = "";
        for (let te = 0; te < W; te += 1)
            ee += ".";
        return ee
    }
    ;
    const U = function(W, ee) {
        let te = "";
        if (ee.type === n.TRG)
            if (W === m || W === l) {
                let fe = ee.min.toString(16).toUpperCase();
                fe.length % 2 !== 0 && (fe = `0${fe}`),
                te += W === m ? "%x" : "U+",
                te += fe,
                fe = ee.max.toString(16).toUpperCase(),
                fe.length % 2 !== 0 && (fe = `0${fe}`),
                te += `&ndash;${fe}`
            } else
                te = `%d${ee.min.toString(10)}&ndash;${ee.max.toString(10)}`;
        return te
    }
      , $ = function(W, ee) {
        let te = "";
        if (ee.type === n.REP)
            if (W === m) {
                let fe = ee.min.toString(16).toUpperCase();
                fe.length % 2 !== 0 && (fe = `0${fe}`),
                te = `x${fe}`,
                ee.max < 1 / 0 ? (fe = ee.max.toString(16).toUpperCase(),
                fe.length % 2 !== 0 && (fe = `0${fe}`)) : fe = "inf",
                te += `&ndash;${fe}`
            } else
                ee.max < 1 / 0 ? te = `${ee.min.toString(10)}&ndash;${ee.max.toString(10)}` : te = `${ee.min.toString(10)}&ndash;inf`;
        return te
    }
      , B = function(W, ee) {
        let te = "";
        if (ee.type === n.TBS) {
            const fe = Math.min(ee.string.length, o * 2);
            if (W === m || W === l) {
                te += W === m ? "%x" : "U+";
                for (let be = 0; be < fe; be += 1) {
                    let le;
                    be > 0 && (te += "."),
                    le = ee.string[be].toString(16).toUpperCase(),
                    le.length % 2 !== 0 && (le = `0${le}`),
                    te += le
                }
            } else {
                te = "%d";
                for (let be = 0; be < fe; be += 1)
                    be > 0 && (te += "."),
                    te += ee.string[be].toString(10)
            }
            fe < ee.string.length && (te += C)
        }
        return te
    }
      , I = function(W, ee) {
        let te = "";
        if (ee.type === n.TLS) {
            const fe = Math.min(ee.string.length, o);
            if (W === m || W === f) {
                let be, le, re;
                W === m ? (te = "%x",
                re = 16) : (te = "%d",
                re = 10);
                for (let M = 0; M < fe; M += 1)
                    M > 0 && (te += "."),
                    le = ee.string[M],
                    le >= 97 && le <= 122 ? (be = le - 32,
                    te += `${be.toString(re)}/${le.toString(re)}`.toUpperCase()) : le >= 65 && le <= 90 ? (be = le,
                    le += 32,
                    te += `${be.toString(re)}/${le.toString(re)}`.toUpperCase()) : te += le.toString(re).toUpperCase();
                fe < ee.string.length && (te += C)
            } else {
                te = '"';
                for (let be = 0; be < fe; be += 1)
                    te += t.asciiChars[ee.string[be]];
                fe < ee.string.length && (te += C),
                te += '"'
            }
        }
        return te
    }
      , F = function(W, ee, te, fe, be) {
        if (fe === 0)
            return "";
        let le = "";
        const re = be ? "," : "";
        switch (W) {
        case m:
            le = re + t.charsToHex(ee, te, fe);
            break;
        case f:
            if (be)
                return `,${t.charsToDec(ee, te, fe)}`;
            le = re + t.charsToDec(ee, te, fe);
            break;
        case l:
            le = t.charsToUnicode(ee, te, fe);
            break;
        case i:
        default:
            le = t.charsToAsciiHtml(ee, te, fe);
            break
        }
        return le
    }
      , z = function(W, ee, te, fe, be, le) {
        let re = "", M, K, V, oe, me = T;
        const Pe = `<span class="${s.CLASS_LOOKBEHIND}">`
          , se = `<span class="${s.CLASS_REMAINDER}">`
          , H = "</span>";
        let G = !1;
        switch (te) {
        case n.EMPTY:
            re += N;
        case n.NOMATCH:
        case n.MATCH:
        case n.ACTIVE:
            M = fe - be,
            K = le - M,
            V = le,
            oe = ee.length - V;
            break;
        default:
            throw new Error("unrecognized state")
        }
        return me = T,
        K > p ? (K = p,
        me = C,
        oe = 0) : K + oe > p && (me = C,
        oe = p - K),
        K > 0 && (re += Pe,
        re += F(W, ee, M, K, G),
        re += H,
        G = !0),
        oe > 0 && (re += se,
        re += F(W, ee, V, oe, G),
        re += H),
        re + me
    }
      , Y = function(W, ee, te, fe, be, le) {
        let re = "", M, K, V, oe, me = T;
        const Pe = `<span class="${s.CLASS_REMAINDER}">`
          , se = "</span>";
        let H = !1;
        switch (te) {
        case n.EMPTY:
            re += N;
        case n.NOMATCH:
        case n.ACTIVE:
            M = fe,
            K = 0,
            V = fe,
            oe = ee.length - V;
            break;
        case n.MATCH:
            M = fe,
            K = be,
            V = fe + K,
            oe = ee.length - V;
            break;
        default:
            throw new Error("unrecognized state")
        }
        return me = T,
        K > p ? (K = p,
        me = C,
        oe = 0) : K + oe > p && (me = C,
        oe = p - K),
        K > 0 && (re += le,
        re += F(W, ee, M, K, H),
        re += se,
        H = !0),
        oe > 0 && (re += Pe,
        re += F(W, ee, V, oe, H),
        re += se),
        re + me
    }
      , ie = function(W, ee, te, fe, be) {
        const le = `<span class="${s.CLASS_LOOKAHEAD}">`;
        return Y(W, ee, te, fe, be, le)
    }
      , ne = function(W, ee, te, fe, be) {
        const le = `<span class="${s.CLASS_MATCH}">`;
        return Y(W, ee, te, fe, be, le)
    }
      , xe = function(W) {
        if (a === null)
            return "";
        let ee = "", te, fe, be, le, re, M;
        return ee += "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>",
        ee += `<th>operator</th><th>phrase</th></tr>
`,
        r.forEach(K => {
            const V = c[K];
            switch (te = V.thisLine,
            fe = V.thatLine !== void 0 ? V.thatLine : "--",
            be = !1,
            le = !1,
            re = !1,
            V.lookAround === n.LOOKAROUND_AHEAD && (be = !0,
            re = !0,
            M = V.lookAnchor),
            (V.opcode.type === n.AND || V.opcode.type === n.NOT) && (be = !0,
            re = !0,
            M = V.phraseIndex),
            V.lookAround === n.LOOKAROUND_BEHIND && (le = !0,
            re = !0,
            M = V.lookAnchor),
            (V.opcode.type === n.BKA || V.opcode.type === n.BKN) && (le = !0,
            re = !0,
            M = V.phraseIndex),
            ee += "<tr>",
            ee += `<td>${te}</td><td>${fe}</td>`,
            ee += `<td>${V.phraseIndex}</td>`,
            ee += `<td>${V.phraseLength}</td>`,
            ee += `<td>${V.depth}</td>`,
            ee += "<td>",
            V.state) {
            case n.ACTIVE:
                ee += `<span class="${s.CLASS_ACTIVE}">&darr;&nbsp;</span>`;
                break;
            case n.MATCH:
                ee += `<span class="${s.CLASS_MATCH}">&uarr;M</span>`;
                break;
            case n.NOMATCH:
                ee += `<span class="${s.CLASS_NOMATCH}">&uarr;N</span>`;
                break;
            case n.EMPTY:
                ee += `<span class="${s.CLASS_EMPTY}">&uarr;E</span>`;
                break;
            default:
                ee += `<span class="${s.CLASS_ACTIVE}">--</span>`;
                break
            }
            if (ee += "</td>",
            ee += "<td>",
            ee += h.indent(V.depth),
            be ? ee += `<span class="${s.CLASS_LOOKAHEAD}">` : le && (ee += `<span class="${s.CLASS_LOOKBEHIND}">`),
            ee += t.opcodeToString(V.opcode.type),
            V.opcode.type === n.RNM && (ee += `(${a[V.opcode.index].name}) `),
            V.opcode.type === n.BKR) {
                const oe = V.opcode.bkrCase === n.BKR_MODE_CI ? "%i" : "%s"
                  , me = V.opcode.bkrMode === n.BKR_MODE_UM ? "%u" : "%p";
                ee += `(\\${oe}${me}${a[V.opcode.index].name}) `
            }
            V.opcode.type === n.UDT && (ee += `(${E[V.opcode.index].name}) `),
            V.opcode.type === n.TRG && (ee += `(${U(W, V.opcode)}) `),
            V.opcode.type === n.TBS && (ee += `(${B(W, V.opcode)}) `),
            V.opcode.type === n.TLS && (ee += `(${I(W, V.opcode)}) `),
            V.opcode.type === n.REP && (ee += `(${$(W, V.opcode)}) `),
            re && (ee += "</span>"),
            ee += "</td>",
            ee += "<td>",
            le ? ee += z(W, x, V.state, V.phraseIndex, V.phraseLength, M) : be ? ee += ie(W, x, V.state, V.phraseIndex, V.phraseLength) : ee += ne(W, x, V.state, V.phraseIndex, V.phraseLength),
            ee += `</td></tr>
`
        }
        ),
        ee += "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>",
        ee += `<th>operator</th><th>phrase</th></tr>
`,
        ee += `</table>
`,
        ee
    };
    this.toHtml = function(W, ee) {
        let te = i;
        if (typeof W == "string" && W.length >= 3) {
            const be = W.toLowerCase().slice(0, 3);
            be === "hex" ? te = m : be === "dec" ? te = f : be === "uni" && (te = l)
        }
        let fe = "";
        return fe += O(te, ee),
        fe += xe(te),
        fe += L(),
        fe
    }
}
  , fu = {
    ast: Xl,
    circular: du,
    ids: jr,
    parser: ed,
    stats: td,
    trace: rd,
    utils: Mr,
    emitcss: lu,
    style: Ts
}
  , _r = {};
Object.defineProperty(_r, "__esModule", {
    value: !0
});
_r.parseIntegerNumber = _r.isEIP55Address = void 0;
const nd = Jl
  , sd = Vl
  , id = e => {
    if (e.length != 42)
        return !1;
    const t = `${e}`.toLowerCase().replace("0x", "")
      , s = (0,
    sd.bytesToHex)((0,
    nd.keccak_256)(t));
    let r = "0x";
    for (let n = 0; n < t.length; n++)
        parseInt(s[n], 16) >= 8 ? r += t[n].toUpperCase() : r += t[n];
    return e === r
}
;
_r.isEIP55Address = id;
const od = e => {
    const t = parseInt(e);
    if (isNaN(t))
        throw new Error("Invalid number.");
    if (t === 1 / 0)
        throw new Error("Invalid number.");
    return t
}
;
_r.parseIntegerNumber = od;
var ad = He && He.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
;
Object.defineProperty(_s, "__esModule", {
    value: !0
});
_s.cb = void 0;
const hu = ad(fu)
  , Ye = hu.default.utils
  , Te = hu.default.ids
  , qs = _r
  , yo = /^(?<date>[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/
  , zs = e => {
    const t = yo.exec(e);
    if (!t)
        return !1;
    const s = new Date(t.groups.date).toISOString()
      , r = yo.exec(s);
    return t.groups.date === r.groups.date
}
;
_s.cb = {
    signInWithEtherium: function(e, t, s, r) {
        switch (e.state) {
        case Te.ACTIVE:
            if (typeof r != "object" || r === null)
                throw new Error("data must be an object");
            break;
        case Te.NOMATCH:
            r.errors.push(`invalid message: max line number was ${r.lineno}`)
        }
    },
    lineno: function(t, s, r, n) {
        t.state === Te.MATCH && (n.lineno += 1)
    },
    exTitle: function(t, s, r, n) {
        t.state === Te.NOMATCH && (n.lineno -= 1)
    },
    nbTitle: function(t, s, r, n) {
        t.state === Te.NOMATCH && (n.lineno -= 1)
    },
    riTitle: function(t, s, r, n) {
        t.state === Te.NOMATCH && (n.lineno -= 1)
    },
    reTitle: function(t, s, r, n) {
        t.state === Te.MATCH ? n.resources = [] : t.state === Te.NOMATCH && (n.lineno -= 1)
    },
    oscheme: function(t, s, r, n) {
        t.state === Te.MATCH && (n.scheme = Ye.charsToString(s, r, t.phraseLength - 3))
    },
    domain: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.domain = Ye.charsToString(s, r, t.phraseLength);
            break;
        case Te.EMPTY:
            n.errors.push(`line ${n.lineno}: domain cannot be empty`);
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid domain`)
        }
    },
    address: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.address = Ye.charsToString(s, r, t.phraseLength),
            (0,
            qs.isEIP55Address)(n.address) || n.errors.push(`line ${n.lineno}: invalid EIP-55 address - ${n.address}`);
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid address`);
            break
        }
    },
    statement: function(t, s, r, n) {
        t.state === Te.MATCH && (n.statement = Ye.charsToString(s, r, t.phraseLength))
    },
    emptyStatement: function(t, s, r, n) {
        t.state === Te.MATCH && (n.statement = "")
    },
    version: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.version = Ye.charsToString(s, r, t.phraseLength);
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid version`);
            break
        }
    },
    nonce: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.nonce = Ye.charsToString(s, r, t.phraseLength);
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid nonce`);
            break
        }
    },
    issuedAt: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.issuedAt = Ye.charsToString(s, r, t.phraseLength),
            zs(n.issuedAt) || n.errors.push(`line ${n.lineno}: invalid issued-at date time semantics`);
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid issued-at date time syntax`);
            break
        }
    },
    expirationTime: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.expirationTime = Ye.charsToString(s, r, t.phraseLength),
            zs(n.expirationTime) || n.errors.push(`line ${n.lineno}: invalid expiration-time date time semantics`);
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid expiration-time date time syntax`);
            break
        }
    },
    notBefore: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.notBefore = Ye.charsToString(s, r, t.phraseLength),
            zs(n.notBefore) || n.errors.push(`line ${n.lineno}: invalid not-before date time semantics`);
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid not-before date time syntax`);
            break
        }
    },
    requestId: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.requestId = Ye.charsToString(s, r, t.phraseLength);
            break;
        case Te.EMPTY:
            n.requestId = "";
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid requestID`);
            break
        }
    },
    chainId: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.chainId = (0,
            qs.parseIntegerNumber)(Ye.charsToString(s, r, t.phraseLength));
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid chain-id`);
            break
        }
    },
    uriR: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.uriR = Ye.charsToString(s, r, t.phraseLength);
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid resource URI`);
            break
        }
    },
    resource: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.resources.push(n.uriR),
            delete n.uriR;
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid resource`);
            break
        }
    },
    scheme: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.uriElements.scheme = Ye.charsToString(s, r, t.phraseLength);
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid URI scheme`);
            break
        }
    },
    userinfo: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.uriElements.userinfo = Ye.charsToString(s, r, t.phraseLength - 1);
            break
        }
    },
    host: function(t, s, r, n) {
        switch (t.state) {
        case Te.ACTIVE:
            n.iplit = !1;
            break;
        case Te.MATCH:
            n.iplit ? n.uriElements.host = Ye.charsToString(s, r + 1, t.phraseLength - 2) : n.uriElements.host = Ye.charsToString(s, r, t.phraseLength);
            break;
        case Te.EMPTY:
            n.uriElements.host = "";
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid URI host`);
            break
        }
    },
    ipLiteral: function(t, s, r, n) {
        t.state === Te.MATCH && (n.iplit = !0)
    },
    port: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.uriElements.port = (0,
            qs.parseIntegerNumber)(Ye.charsToString(s, r, t.phraseLength));
            break;
        case Te.EMPTY:
            n.uriElements.port = "";
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid URI port`);
            break
        }
    },
    pathAbempty: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.uriElements.path = Ye.charsToString(s, r, t.phraseLength);
            break;
        case Te.EMPTY:
            n.uriElements.path = "";
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid URI path-abempty`);
            break
        }
    },
    pathAbsolute: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.uriElements.path = Ye.charsToString(s, r, t.phraseLength);
            break
        }
    },
    pathRootless: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.uriElements.path = Ye.charsToString(s, r, t.phraseLength);
            break
        }
    },
    pathEmpty: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid URI - path-empty must be empty`);
            break;
        case Te.EMPTY:
            n.uriElements.path = "";
            break
        }
    },
    query: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.uriElements.query = Ye.charsToString(s, r, t.phraseLength);
            break;
        case Te.EMPTY:
            n.uriElements.query = "";
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid URI query`);
            break
        }
    },
    fragment: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.uriElements.fragment = Ye.charsToString(s, r, t.phraseLength);
            break;
        case Te.EMPTY:
            n.uriElements.fragment = "";
            break;
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid URI fragment`);
            break
        }
    },
    uri: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.uri = Ye.charsToString(s, r, t.phraseLength);
            break;
        case Te.EMPTY:
        case Te.NOMATCH:
            n.errors.push(`line ${n.lineno}: invalid URI`);
            break
        }
    },
    ipv4: function(t, s, r, n) {
        t.state === Te.MATCH && (n.ipv4 = !0)
    },
    h16: function(t, s, r, n) {
        t.state === Te.MATCH && (n.h16count += 1)
    },
    nodcolon: function(t, s, r, n) {
        switch (t.state) {
        case Te.ACTIVE:
            n.h16count = 0,
            n.ipv4 = !1;
            break;
        case Te.MATCH:
            n.ipv4 ? n.h16count === 6 ? t.state = Te.MATCH : (t.state = Te.NOMATCH,
            t.phraseLength = 0) : n.h16count === 8 ? t.state = Te.MATCH : (t.state = Te.NOMATCH,
            t.phraseLength = 0);
            break
        }
    },
    dcolon: function(t, s, r, n) {
        switch (t.state) {
        case Te.ACTIVE:
            n.h16count = 0,
            n.ipv4 = !1;
            break;
        case Te.MATCH:
            n.ipv4 ? n.h16count < 6 ? t.state = Te.MATCH : (t.state = Te.NOMATCH,
            t.phraseLength = 0) : n.h16count < 8 ? t.state = Te.MATCH : (t.state = Te.NOMATCH,
            t.phraseLength = 0);
            break
        }
    },
    decOctet: function(t, s, r, n) {
        switch (t.state) {
        case Te.ACTIVE:
            n.octet = 0;
            break;
        case Te.MATCH:
            n.octet > 255 ? (t.state = Te.NOMATCH,
            t.phraseLength = 0) : t.state = Te.MATCH;
            break
        }
    },
    decDigit: function(t, s, r, n) {
        switch (t.state) {
        case Te.MATCH:
            n.octet = 10 * n.octet + s[r] - 48;
            break
        }
    }
};
var cd = He && He.__importDefault || function(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
;
Object.defineProperty(kr, "__esModule", {
    value: !0
});
kr.isUri = kr.ParsedMessage = void 0;
const ud = ks
  , Ce = _s
  , pu = cd(fu)
  , bu = new ud.grammar;
class ld {
    constructor(t) {
        const s = new pu.default.parser;
        s.callbacks["sign-in-with-ethereum"] = Ce.cb.signInWithEtherium,
        s.callbacks.oscheme = Ce.cb.oscheme,
        s.callbacks.domain = Ce.cb.domain,
        s.callbacks.LF = Ce.cb.lineno,
        s.callbacks["ex-title"] = Ce.cb.exTitle,
        s.callbacks["nb-title"] = Ce.cb.nbTitle,
        s.callbacks["ri-title"] = Ce.cb.riTitle,
        s.callbacks["re-title"] = Ce.cb.reTitle,
        s.callbacks.address = Ce.cb.address,
        s.callbacks.statement = Ce.cb.statement,
        s.callbacks["empty-statement"] = Ce.cb.emptyStatement,
        s.callbacks.version = Ce.cb.version,
        s.callbacks["chain-id"] = Ce.cb.chainId,
        s.callbacks.nonce = Ce.cb.nonce,
        s.callbacks["issued-at"] = Ce.cb.issuedAt,
        s.callbacks["expiration-time"] = Ce.cb.expirationTime,
        s.callbacks["not-before"] = Ce.cb.notBefore,
        s.callbacks["request-id"] = Ce.cb.requestId,
        s.callbacks.uri = Ce.cb.uri,
        s.callbacks["uri-r"] = Ce.cb.uriR,
        s.callbacks.resource = Ce.cb.resource,
        s.callbacks.scheme = Ce.cb.scheme,
        s.callbacks["userinfo-at"] = Ce.cb.userinfo,
        s.callbacks.host = Ce.cb.host,
        s.callbacks["IP-literal"] = Ce.cb.ipLiteral,
        s.callbacks.port = Ce.cb.port,
        s.callbacks["path-abempty"] = Ce.cb.pathAbempty,
        s.callbacks["path-absolute"] = Ce.cb.pathAbsolute,
        s.callbacks["path-rootless"] = Ce.cb.pathRootless,
        s.callbacks["path-empty"] = Ce.cb.pathEmpty,
        s.callbacks.query = Ce.cb.query,
        s.callbacks.fragment = Ce.cb.fragment,
        s.callbacks.IPv4address = Ce.cb.ipv4,
        s.callbacks.nodcolon = Ce.cb.nodcolon,
        s.callbacks.dcolon = Ce.cb.dcolon,
        s.callbacks.h16 = Ce.cb.h16,
        s.callbacks.h16c = Ce.cb.h16,
        s.callbacks.h16n = Ce.cb.h16,
        s.callbacks.h16cn = Ce.cb.h16,
        s.callbacks["dec-octet"] = Ce.cb.decOctet,
        s.callbacks["dec-digit"] = Ce.cb.decDigit;
        const r = {
            errors: [],
            lineno: 1,
            scheme: void 0,
            domain: void 0,
            address: void 0,
            statement: void 0,
            uri: void 0,
            version: void 0,
            chainId: void 0,
            nonce: void 0,
            issuedAt: void 0,
            expirationTime: void 0,
            notBefore: void 0,
            requestId: void 0,
            resources: void 0,
            uriElements: {
                scheme: void 0,
                userinfo: void 0,
                host: void 0,
                port: void 0,
                path: void 0,
                query: void 0,
                fragment: void 0
            }
        }
          , n = s.parse(bu, 0, t, r);
        let d = "";
        for (let h = 0; h < r.errors.length; h += 1)
            d += r.errors[h] + `
`;
        if (n.success || (d += `Invalid message: ${JSON.stringify(n)}`),
        d !== "")
            throw new Error(d);
        this.scheme = r.scheme,
        this.domain = r.domain,
        this.address = r.address,
        this.statement = r.statement,
        this.uri = r.uri,
        this.version = r.version,
        this.chainId = r.chainId,
        this.nonce = r.nonce,
        this.issuedAt = r.issuedAt,
        this.expirationTime = r.expirationTime,
        this.notBefore = r.notBefore,
        this.requestId = r.requestId,
        this.resources = r.resources,
        this.uriElements = r.uriElements
    }
}
kr.ParsedMessage = ld;
const dd = e => {
    const t = new pu.default.parser;
    t.callbacks["IP-literal"] = Ce.cb.ipLiteral,
    t.callbacks.IPv4address = Ce.cb.ipv4,
    t.callbacks.nodcolon = Ce.cb.nodcolon,
    t.callbacks.dcolon = Ce.cb.dcolon,
    t.callbacks.h16 = Ce.cb.h16,
    t.callbacks.h16c = Ce.cb.h16,
    t.callbacks.h16n = Ce.cb.h16,
    t.callbacks.h16cn = Ce.cb.h16,
    t.callbacks["dec-octet"] = Ce.cb.decOctet,
    t.callbacks["dec-digit"] = Ce.cb.decDigit;
    const s = {
        errors: []
    };
    return t.parse(bu, "uri-r", e, s).success
}
;
kr.isUri = dd;
(function(e) {
    var t = He && He.__createBinding || (Object.create ? function(d, h, m, f) {
        f === void 0 && (f = m);
        var i = Object.getOwnPropertyDescriptor(h, m);
        (!i || ("get"in i ? !h.__esModule : i.writable || i.configurable)) && (i = {
            enumerable: !0,
            get: function() {
                return h[m]
            }
        }),
        Object.defineProperty(d, f, i)
    }
    : function(d, h, m, f) {
        f === void 0 && (f = m),
        d[f] = h[m]
    }
    )
      , s = He && He.__exportStar || function(d, h) {
        for (var m in d)
            m !== "default" && !Object.prototype.hasOwnProperty.call(h, m) && t(h, d, m)
    }
    ;
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.isUri = e.ParsedMessage = void 0;
    const r = kr;
    Object.defineProperty(e, "ParsedMessage", {
        enumerable: !0,
        get: function() {
            return r.ParsedMessage
        }
    });
    const n = kr;
    Object.defineProperty(e, "isUri", {
        enumerable: !0,
        get: function() {
            return n.isUri
        }
    }),
    s(_r, e)
}
)(au);
var Gt = {}
  , Hi = {}
  , pi = function(e, t) {
    return pi = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(s, r) {
        s.__proto__ = r
    }
    || function(s, r) {
        for (var n in r)
            Object.prototype.hasOwnProperty.call(r, n) && (s[n] = r[n])
    }
    ,
    pi(e, t)
};
function gu(e, t) {
    if (typeof t != "function" && t !== null)
        throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
    pi(e, t);
    function s() {
        this.constructor = e
    }
    e.prototype = t === null ? Object.create(t) : (s.prototype = t.prototype,
    new s)
}
var ws = function() {
    return ws = Object.assign || function(t) {
        for (var s, r = 1, n = arguments.length; r < n; r++) {
            s = arguments[r];
            for (var d in s)
                Object.prototype.hasOwnProperty.call(s, d) && (t[d] = s[d])
        }
        return t
    }
    ,
    ws.apply(this, arguments)
};
function mu(e, t) {
    var s = {};
    for (var r in e)
        Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (s[r] = e[r]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var n = 0, r = Object.getOwnPropertySymbols(e); n < r.length; n++)
            t.indexOf(r[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[n]) && (s[r[n]] = e[r[n]]);
    return s
}
function yu(e, t, s, r) {
    var n = arguments.length, d = n < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, s) : r, h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        d = Reflect.decorate(e, t, s, r);
    else
        for (var m = e.length - 1; m >= 0; m--)
            (h = e[m]) && (d = (n < 3 ? h(d) : n > 3 ? h(t, s, d) : h(t, s)) || d);
    return n > 3 && d && Object.defineProperty(t, s, d),
    d
}
function xu(e, t) {
    return function(s, r) {
        t(s, r, e)
    }
}
function fd(e, t, s, r, n, d) {
    function h(v) {
        if (v !== void 0 && typeof v != "function")
            throw new TypeError("Function expected");
        return v
    }
    for (var m = r.kind, f = m === "getter" ? "get" : m === "setter" ? "set" : "value", i = !t && e ? r.static ? e : e.prototype : null, l = t || (i ? Object.getOwnPropertyDescriptor(i, r.name) : {}), p, o = !1, c = s.length - 1; c >= 0; c--) {
        var u = {};
        for (var g in r)
            u[g] = g === "access" ? {} : r[g];
        for (var g in r.access)
            u.access[g] = r.access[g];
        u.addInitializer = function(v) {
            if (o)
                throw new TypeError("Cannot add initializers after decoration has completed");
            d.push(h(v || null))
        }
        ;
        var P = (0,
        s[c])(m === "accessor" ? {
            get: l.get,
            set: l.set
        } : l[f], u);
        if (m === "accessor") {
            if (P === void 0)
                continue;
            if (P === null || typeof P != "object")
                throw new TypeError("Object expected");
            (p = h(P.get)) && (l.get = p),
            (p = h(P.set)) && (l.set = p),
            (p = h(P.init)) && n.unshift(p)
        } else
            (p = h(P)) && (m === "field" ? n.unshift(p) : l[f] = p)
    }
    i && Object.defineProperty(i, r.name, l),
    o = !0
}
function hd(e, t, s) {
    for (var r = arguments.length > 2, n = 0; n < t.length; n++)
        s = r ? t[n].call(e, s) : t[n].call(e);
    return r ? s : void 0
}
function pd(e) {
    return typeof e == "symbol" ? e : "".concat(e)
}
function bd(e, t, s) {
    return typeof t == "symbol" && (t = t.description ? "[".concat(t.description, "]") : ""),
    Object.defineProperty(e, "name", {
        configurable: !0,
        value: s ? "".concat(s, " ", t) : t
    })
}
function wu(e, t) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
        return Reflect.metadata(e, t)
}
function Au(e, t, s, r) {
    function n(d) {
        return d instanceof s ? d : new s(function(h) {
            h(d)
        }
        )
    }
    return new (s || (s = Promise))(function(d, h) {
        function m(l) {
            try {
                i(r.next(l))
            } catch (p) {
                h(p)
            }
        }
        function f(l) {
            try {
                i(r.throw(l))
            } catch (p) {
                h(p)
            }
        }
        function i(l) {
            l.done ? d(l.value) : n(l.value).then(m, f)
        }
        i((r = r.apply(e, t || [])).next())
    }
    )
}
function vu(e, t) {
    var s = {
        label: 0,
        sent: function() {
            if (d[0] & 1)
                throw d[1];
            return d[1]
        },
        trys: [],
        ops: []
    }, r, n, d, h = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return h.next = m(0),
    h.throw = m(1),
    h.return = m(2),
    typeof Symbol == "function" && (h[Symbol.iterator] = function() {
        return this
    }
    ),
    h;
    function m(i) {
        return function(l) {
            return f([i, l])
        }
    }
    function f(i) {
        if (r)
            throw new TypeError("Generator is already executing.");
        for (; h && (h = 0,
        i[0] && (s = 0)),
        s; )
            try {
                if (r = 1,
                n && (d = i[0] & 2 ? n.return : i[0] ? n.throw || ((d = n.return) && d.call(n),
                0) : n.next) && !(d = d.call(n, i[1])).done)
                    return d;
                switch (n = 0,
                d && (i = [i[0] & 2, d.value]),
                i[0]) {
                case 0:
                case 1:
                    d = i;
                    break;
                case 4:
                    return s.label++,
                    {
                        value: i[1],
                        done: !1
                    };
                case 5:
                    s.label++,
                    n = i[1],
                    i = [0];
                    continue;
                case 7:
                    i = s.ops.pop(),
                    s.trys.pop();
                    continue;
                default:
                    if (d = s.trys,
                    !(d = d.length > 0 && d[d.length - 1]) && (i[0] === 6 || i[0] === 2)) {
                        s = 0;
                        continue
                    }
                    if (i[0] === 3 && (!d || i[1] > d[0] && i[1] < d[3])) {
                        s.label = i[1];
                        break
                    }
                    if (i[0] === 6 && s.label < d[1]) {
                        s.label = d[1],
                        d = i;
                        break
                    }
                    if (d && s.label < d[2]) {
                        s.label = d[2],
                        s.ops.push(i);
                        break
                    }
                    d[2] && s.ops.pop(),
                    s.trys.pop();
                    continue
                }
                i = t.call(e, s)
            } catch (l) {
                i = [6, l],
                n = 0
            } finally {
                r = d = 0
            }
        if (i[0] & 5)
            throw i[1];
        return {
            value: i[0] ? i[1] : void 0,
            done: !0
        }
    }
}
var Os = Object.create ? function(e, t, s, r) {
    r === void 0 && (r = s);
    var n = Object.getOwnPropertyDescriptor(t, s);
    (!n || ("get"in n ? !t.__esModule : n.writable || n.configurable)) && (n = {
        enumerable: !0,
        get: function() {
            return t[s]
        }
    }),
    Object.defineProperty(e, r, n)
}
: function(e, t, s, r) {
    r === void 0 && (r = s),
    e[r] = t[s]
}
;
function Eu(e, t) {
    for (var s in e)
        s !== "default" && !Object.prototype.hasOwnProperty.call(t, s) && Os(t, e, s)
}
function As(e) {
    var t = typeof Symbol == "function" && Symbol.iterator
      , s = t && e[t]
      , r = 0;
    if (s)
        return s.call(e);
    if (e && typeof e.length == "number")
        return {
            next: function() {
                return e && r >= e.length && (e = void 0),
                {
                    value: e && e[r++],
                    done: !e
                }
            }
        };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
}
function Gi(e, t) {
    var s = typeof Symbol == "function" && e[Symbol.iterator];
    if (!s)
        return e;
    var r = s.call(e), n, d = [], h;
    try {
        for (; (t === void 0 || t-- > 0) && !(n = r.next()).done; )
            d.push(n.value)
    } catch (m) {
        h = {
            error: m
        }
    } finally {
        try {
            n && !n.done && (s = r.return) && s.call(r)
        } finally {
            if (h)
                throw h.error
        }
    }
    return d
}
function Pu() {
    for (var e = [], t = 0; t < arguments.length; t++)
        e = e.concat(Gi(arguments[t]));
    return e
}
function ku() {
    for (var e = 0, t = 0, s = arguments.length; t < s; t++)
        e += arguments[t].length;
    for (var r = Array(e), n = 0, t = 0; t < s; t++)
        for (var d = arguments[t], h = 0, m = d.length; h < m; h++,
        n++)
            r[n] = d[h];
    return r
}
function _u(e, t, s) {
    if (s || arguments.length === 2)
        for (var r = 0, n = t.length, d; r < n; r++)
            (d || !(r in t)) && (d || (d = Array.prototype.slice.call(t, 0, r)),
            d[r] = t[r]);
    return e.concat(d || Array.prototype.slice.call(t))
}
function Rr(e) {
    return this instanceof Rr ? (this.v = e,
    this) : new Rr(e)
}
function Tu(e, t, s) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var r = s.apply(e, t || []), n, d = [];
    return n = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype),
    m("next"),
    m("throw"),
    m("return", h),
    n[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    n;
    function h(c) {
        return function(u) {
            return Promise.resolve(u).then(c, p)
        }
    }
    function m(c, u) {
        r[c] && (n[c] = function(g) {
            return new Promise(function(P, v) {
                d.push([c, g, P, v]) > 1 || f(c, g)
            }
            )
        }
        ,
        u && (n[c] = u(n[c])))
    }
    function f(c, u) {
        try {
            i(r[c](u))
        } catch (g) {
            o(d[0][3], g)
        }
    }
    function i(c) {
        c.value instanceof Rr ? Promise.resolve(c.value.v).then(l, p) : o(d[0][2], c)
    }
    function l(c) {
        f("next", c)
    }
    function p(c) {
        f("throw", c)
    }
    function o(c, u) {
        c(u),
        d.shift(),
        d.length && f(d[0][0], d[0][1])
    }
}
function Ou(e) {
    var t, s;
    return t = {},
    r("next"),
    r("throw", function(n) {
        throw n
    }),
    r("return"),
    t[Symbol.iterator] = function() {
        return this
    }
    ,
    t;
    function r(n, d) {
        t[n] = e[n] ? function(h) {
            return (s = !s) ? {
                value: Rr(e[n](h)),
                done: !1
            } : d ? d(h) : h
        }
        : d
    }
}
function Bu(e) {
    if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
    var t = e[Symbol.asyncIterator], s;
    return t ? t.call(e) : (e = typeof As == "function" ? As(e) : e[Symbol.iterator](),
    s = {},
    r("next"),
    r("throw"),
    r("return"),
    s[Symbol.asyncIterator] = function() {
        return this
    }
    ,
    s);
    function r(d) {
        s[d] = e[d] && function(h) {
            return new Promise(function(m, f) {
                h = e[d](h),
                n(m, f, h.done, h.value)
            }
            )
        }
    }
    function n(d, h, m, f) {
        Promise.resolve(f).then(function(i) {
            d({
                value: i,
                done: m
            })
        }, h)
    }
}
function Su(e, t) {
    return Object.defineProperty ? Object.defineProperty(e, "raw", {
        value: t
    }) : e.raw = t,
    e
}
var gd = Object.create ? function(e, t) {
    Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
    })
}
: function(e, t) {
    e.default = t
}
;
function Cu(e) {
    if (e && e.__esModule)
        return e;
    var t = {};
    if (e != null)
        for (var s in e)
            s !== "default" && Object.prototype.hasOwnProperty.call(e, s) && Os(t, e, s);
    return gd(t, e),
    t
}
function Nu(e) {
    return e && e.__esModule ? e : {
        default: e
    }
}
function Ru(e, t, s, r) {
    if (s === "a" && !r)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !r : !t.has(e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return s === "m" ? r : s === "a" ? r.call(e) : r ? r.value : t.get(e)
}
function Iu(e, t, s, r, n) {
    if (r === "m")
        throw new TypeError("Private method is not writable");
    if (r === "a" && !n)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !n : !t.has(e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return r === "a" ? n.call(e, s) : n ? n.value = s : t.set(e, s),
    s
}
function ju(e, t) {
    if (t === null || typeof t != "object" && typeof t != "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof e == "function" ? t === e : e.has(t)
}
function Mu(e, t, s) {
    if (t != null) {
        if (typeof t != "object" && typeof t != "function")
            throw new TypeError("Object expected.");
        var r, n;
        if (s) {
            if (!Symbol.asyncDispose)
                throw new TypeError("Symbol.asyncDispose is not defined.");
            r = t[Symbol.asyncDispose]
        }
        if (r === void 0) {
            if (!Symbol.dispose)
                throw new TypeError("Symbol.dispose is not defined.");
            r = t[Symbol.dispose],
            s && (n = r)
        }
        if (typeof r != "function")
            throw new TypeError("Object not disposable.");
        n && (r = function() {
            try {
                n.call(this)
            } catch (d) {
                return Promise.reject(d)
            }
        }
        ),
        e.stack.push({
            value: t,
            dispose: r,
            async: s
        })
    } else
        s && e.stack.push({
            async: !0
        });
    return t
}
var md = typeof SuppressedError == "function" ? SuppressedError : function(e, t, s) {
    var r = new Error(s);
    return r.name = "SuppressedError",
    r.error = e,
    r.suppressed = t,
    r
}
;
function Lu(e) {
    function t(d) {
        e.error = e.hasError ? new md(d,e.error,"An error was suppressed during disposal.") : d,
        e.hasError = !0
    }
    var s, r = 0;
    function n() {
        for (; s = e.stack.pop(); )
            try {
                if (!s.async && r === 1)
                    return r = 0,
                    e.stack.push(s),
                    Promise.resolve().then(n);
                if (s.dispose) {
                    var d = s.dispose.call(s.value);
                    if (s.async)
                        return r |= 2,
                        Promise.resolve(d).then(n, function(h) {
                            return t(h),
                            n()
                        })
                } else
                    r |= 1
            } catch (h) {
                t(h)
            }
        if (r === 1)
            return e.hasError ? Promise.reject(e.error) : Promise.resolve();
        if (e.hasError)
            throw e.error
    }
    return n()
}
const yd = {
    __extends: gu,
    __assign: ws,
    __rest: mu,
    __decorate: yu,
    __param: xu,
    __metadata: wu,
    __awaiter: Au,
    __generator: vu,
    __createBinding: Os,
    __exportStar: Eu,
    __values: As,
    __read: Gi,
    __spread: Pu,
    __spreadArrays: ku,
    __spreadArray: _u,
    __await: Rr,
    __asyncGenerator: Tu,
    __asyncDelegator: Ou,
    __asyncValues: Bu,
    __makeTemplateObject: Su,
    __importStar: Cu,
    __importDefault: Nu,
    __classPrivateFieldGet: Ru,
    __classPrivateFieldSet: Iu,
    __classPrivateFieldIn: ju,
    __addDisposableResource: Mu,
    __disposeResources: Lu
}
  , xd = Object.freeze(Object.defineProperty({
    __proto__: null,
    __addDisposableResource: Mu,
    get __assign() {
        return ws
    },
    __asyncDelegator: Ou,
    __asyncGenerator: Tu,
    __asyncValues: Bu,
    __await: Rr,
    __awaiter: Au,
    __classPrivateFieldGet: Ru,
    __classPrivateFieldIn: ju,
    __classPrivateFieldSet: Iu,
    __createBinding: Os,
    __decorate: yu,
    __disposeResources: Lu,
    __esDecorate: fd,
    __exportStar: Eu,
    __extends: gu,
    __generator: vu,
    __importDefault: Nu,
    __importStar: Cu,
    __makeTemplateObject: Su,
    __metadata: wu,
    __param: xu,
    __propKey: pd,
    __read: Gi,
    __rest: mu,
    __runInitializers: hd,
    __setFunctionName: bd,
    __spread: Pu,
    __spreadArray: _u,
    __spreadArrays: ku,
    __values: As,
    default: yd
}, Symbol.toStringTag, {
    value: "Module"
}))
  , wd = zl(xd);
var Ks = {}, Dr = {}, xo;
function $i() {
    return xo || (xo = 1,
    Object.defineProperty(Dr, "__esModule", {
        value: !0
    }),
    Dr.version = void 0,
    Dr.version = "6.15.0"),
    Dr
}
var Vs = {}, Hr = {}, Js = {}, Wt = {}, Qe = {}, nt = {}, Yt = {}, wo;
function Tr() {
    if (wo)
        return Yt;
    wo = 1,
    Object.defineProperty(Yt, "__esModule", {
        value: !0
    }),
    Yt.defineProperties = Yt.resolveProperties = void 0;
    function e(r, n, d) {
        const h = n.split("|").map(f => f.trim());
        for (let f = 0; f < h.length; f++)
            switch (n) {
            case "any":
                return;
            case "bigint":
            case "boolean":
            case "number":
            case "string":
                if (typeof r === n)
                    return
            }
        const m = new Error(`invalid value for type ${n}`);
        throw m.code = "INVALID_ARGUMENT",
        m.argument = `value.${d}`,
        m.value = r,
        m
    }
    async function t(r) {
        const n = Object.keys(r);
        return (await Promise.all(n.map(h => Promise.resolve(r[h])))).reduce( (h, m, f) => (h[n[f]] = m,
        h), {})
    }
    Yt.resolveProperties = t;
    function s(r, n, d) {
        for (let h in n) {
            let m = n[h];
            const f = d ? d[h] : null;
            f && e(m, f, h),
            Object.defineProperty(r, h, {
                enumerable: !0,
                value: m,
                writable: !1
            })
        }
    }
    return Yt.defineProperties = s,
    Yt
}
var Ao;
function Rt() {
    if (Ao)
        return nt;
    Ao = 1,
    Object.defineProperty(nt, "__esModule", {
        value: !0
    }),
    nt.assertPrivate = nt.assertNormalize = nt.assertArgumentCount = nt.assertArgument = nt.assert = nt.makeError = nt.isCallException = nt.isError = void 0;
    const e = $i()
      , t = Tr();
    function s(o, c) {
        if (o == null)
            return "null";
        if (c == null && (c = new Set),
        typeof o == "object") {
            if (c.has(o))
                return "[Circular]";
            c.add(o)
        }
        if (Array.isArray(o))
            return "[ " + o.map(u => s(u, c)).join(", ") + " ]";
        if (o instanceof Uint8Array) {
            const u = "0123456789abcdef";
            let g = "0x";
            for (let P = 0; P < o.length; P++)
                g += u[o[P] >> 4],
                g += u[o[P] & 15];
            return g
        }
        if (typeof o == "object" && typeof o.toJSON == "function")
            return s(o.toJSON(), c);
        switch (typeof o) {
        case "boolean":
        case "number":
        case "symbol":
            return o.toString();
        case "bigint":
            return BigInt(o).toString();
        case "string":
            return JSON.stringify(o);
        case "object":
            {
                const u = Object.keys(o);
                return u.sort(),
                "{ " + u.map(g => `${s(g, c)}: ${s(o[g], c)}`).join(", ") + " }"
            }
        }
        return "[ COULD NOT SERIALIZE ]"
    }
    function r(o, c) {
        return o && o.code === c
    }
    nt.isError = r;
    function n(o) {
        return r(o, "CALL_EXCEPTION")
    }
    nt.isCallException = n;
    function d(o, c, u) {
        let g = o;
        {
            const v = [];
            if (u) {
                if ("message"in u || "code"in u || "name"in u)
                    throw new Error(`value will overwrite populated values: ${s(u)}`);
                for (const b in u) {
                    if (b === "shortMessage")
                        continue;
                    const x = u[b];
                    v.push(b + "=" + s(x))
                }
            }
            v.push(`code=${c}`),
            v.push(`version=${e.version}`),
            v.length && (o += " (" + v.join(", ") + ")")
        }
        let P;
        switch (c) {
        case "INVALID_ARGUMENT":
            P = new TypeError(o);
            break;
        case "NUMERIC_FAULT":
        case "BUFFER_OVERRUN":
            P = new RangeError(o);
            break;
        default:
            P = new Error(o)
        }
        return (0,
        t.defineProperties)(P, {
            code: c
        }),
        u && Object.assign(P, u),
        P.shortMessage == null && (0,
        t.defineProperties)(P, {
            shortMessage: g
        }),
        P
    }
    nt.makeError = d;
    function h(o, c, u, g) {
        if (!o)
            throw d(c, u, g)
    }
    nt.assert = h;
    function m(o, c, u, g) {
        h(o, c, "INVALID_ARGUMENT", {
            argument: u,
            value: g
        })
    }
    nt.assertArgument = m;
    function f(o, c, u) {
        u == null && (u = ""),
        u && (u = ": " + u),
        h(o >= c, "missing argument" + u, "MISSING_ARGUMENT", {
            count: o,
            expectedCount: c
        }),
        h(o <= c, "too many arguments" + u, "UNEXPECTED_ARGUMENT", {
            count: o,
            expectedCount: c
        })
    }
    nt.assertArgumentCount = f;
    const i = ["NFD", "NFC", "NFKD", "NFKC"].reduce( (o, c) => {
        try {
            if ("test".normalize(c) !== "test")
                throw new Error("bad");
            if (c === "NFD" && "".normalize("NFD") !== "e")
                throw new Error("broken");
            o.push(c)
        } catch {}
        return o
    }
    , []);
    function l(o) {
        h(i.indexOf(o) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
            operation: "String.prototype.normalize",
            info: {
                form: o
            }
        })
    }
    nt.assertNormalize = l;
    function p(o, c, u) {
        if (u == null && (u = ""),
        o !== c) {
            let g = u
              , P = "new";
            u && (g += ".",
            P += " " + u),
            h(!1, `private constructor; use ${g}from* methods`, "UNSUPPORTED_OPERATION", {
                operation: P
            })
        }
    }
    return nt.assertPrivate = p,
    nt
}
var vo;
function Ot() {
    if (vo)
        return Qe;
    vo = 1,
    Object.defineProperty(Qe, "__esModule", {
        value: !0
    }),
    Qe.zeroPadBytes = Qe.zeroPadValue = Qe.stripZerosLeft = Qe.dataSlice = Qe.dataLength = Qe.concat = Qe.hexlify = Qe.isBytesLike = Qe.isHexString = Qe.getBytesCopy = Qe.getBytes = void 0;
    const e = Rt();
    function t(g, P, v) {
        if (g instanceof Uint8Array)
            return v ? new Uint8Array(g) : g;
        if (typeof g == "string" && g.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
            const b = new Uint8Array((g.length - 2) / 2);
            let x = 2;
            for (let a = 0; a < b.length; a++)
                b[a] = parseInt(g.substring(x, x + 2), 16),
                x += 2;
            return b
        }
        (0,
        e.assertArgument)(!1, "invalid BytesLike value", P || "value", g)
    }
    function s(g, P) {
        return t(g, P, !1)
    }
    Qe.getBytes = s;
    function r(g, P) {
        return t(g, P, !0)
    }
    Qe.getBytesCopy = r;
    function n(g, P) {
        return !(typeof g != "string" || !g.match(/^0x[0-9A-Fa-f]*$/) || typeof P == "number" && g.length !== 2 + 2 * P || P === !0 && g.length % 2 !== 0)
    }
    Qe.isHexString = n;
    function d(g) {
        return n(g, !0) || g instanceof Uint8Array
    }
    Qe.isBytesLike = d;
    const h = "0123456789abcdef";
    function m(g) {
        const P = s(g);
        let v = "0x";
        for (let b = 0; b < P.length; b++) {
            const x = P[b];
            v += h[(x & 240) >> 4] + h[x & 15]
        }
        return v
    }
    Qe.hexlify = m;
    function f(g) {
        return "0x" + g.map(P => m(P).substring(2)).join("")
    }
    Qe.concat = f;
    function i(g) {
        return n(g, !0) ? (g.length - 2) / 2 : s(g).length
    }
    Qe.dataLength = i;
    function l(g, P, v) {
        const b = s(g);
        return v != null && v > b.length && (0,
        e.assert)(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
            buffer: b,
            length: b.length,
            offset: v
        }),
        m(b.slice(P ?? 0, v ?? b.length))
    }
    Qe.dataSlice = l;
    function p(g) {
        let P = m(g).substring(2);
        for (; P.startsWith("00"); )
            P = P.substring(2);
        return "0x" + P
    }
    Qe.stripZerosLeft = p;
    function o(g, P, v) {
        const b = s(g);
        (0,
        e.assert)(P >= b.length, "padding exceeds data length", "BUFFER_OVERRUN", {
            buffer: new Uint8Array(b),
            length: P,
            offset: P + 1
        });
        const x = new Uint8Array(P);
        return x.fill(0),
        v ? x.set(b, P - b.length) : x.set(b, 0),
        m(x)
    }
    function c(g, P) {
        return o(g, P, !0)
    }
    Qe.zeroPadValue = c;
    function u(g, P) {
        return o(g, P, !1)
    }
    return Qe.zeroPadBytes = u,
    Qe
}
var We = {}, Eo;
function ns() {
    if (Eo)
        return We;
    Eo = 1,
    Object.defineProperty(We, "__esModule", {
        value: !0
    }),
    We.toQuantity = We.toBeArray = We.toBeHex = We.toNumber = We.getNumber = We.toBigInt = We.getUint = We.getBigInt = We.mask = We.toTwos = We.fromTwos = void 0;
    const e = Ot()
      , t = Rt()
      , s = BigInt(0)
      , r = BigInt(1)
      , n = 9007199254740991;
    function d(v, b) {
        const x = i(v, "value")
          , a = BigInt(o(b, "width"));
        if ((0,
        t.assert)(x >> a === s, "overflow", "NUMERIC_FAULT", {
            operation: "fromTwos",
            fault: "overflow",
            value: v
        }),
        x >> a - r) {
            const E = (r << a) - r;
            return -((~x & E) + r)
        }
        return x
    }
    We.fromTwos = d;
    function h(v, b) {
        let x = f(v, "value");
        const a = BigInt(o(b, "width"))
          , E = r << a - r;
        if (x < s) {
            x = -x,
            (0,
            t.assert)(x <= E, "too low", "NUMERIC_FAULT", {
                operation: "toTwos",
                fault: "overflow",
                value: v
            });
            const w = (r << a) - r;
            return (~x & w) + r
        } else
            (0,
            t.assert)(x < E, "too high", "NUMERIC_FAULT", {
                operation: "toTwos",
                fault: "overflow",
                value: v
            });
        return x
    }
    We.toTwos = h;
    function m(v, b) {
        const x = i(v, "value")
          , a = BigInt(o(b, "bits"));
        return x & (r << a) - r
    }
    We.mask = m;
    function f(v, b) {
        switch (typeof v) {
        case "bigint":
            return v;
        case "number":
            return (0,
            t.assertArgument)(Number.isInteger(v), "underflow", b || "value", v),
            (0,
            t.assertArgument)(v >= -9007199254740991 && v <= n, "overflow", b || "value", v),
            BigInt(v);
        case "string":
            try {
                if (v === "")
                    throw new Error("empty string");
                return v[0] === "-" && v[1] !== "-" ? -BigInt(v.substring(1)) : BigInt(v)
            } catch (x) {
                (0,
                t.assertArgument)(!1, `invalid BigNumberish string: ${x.message}`, b || "value", v)
            }
        }
        (0,
        t.assertArgument)(!1, "invalid BigNumberish value", b || "value", v)
    }
    We.getBigInt = f;
    function i(v, b) {
        const x = f(v, b);
        return (0,
        t.assert)(x >= s, "unsigned value cannot be negative", "NUMERIC_FAULT", {
            fault: "overflow",
            operation: "getUint",
            value: v
        }),
        x
    }
    We.getUint = i;
    const l = "0123456789abcdef";
    function p(v) {
        if (v instanceof Uint8Array) {
            let b = "0x0";
            for (const x of v)
                b += l[x >> 4],
                b += l[x & 15];
            return BigInt(b)
        }
        return f(v)
    }
    We.toBigInt = p;
    function o(v, b) {
        switch (typeof v) {
        case "bigint":
            return (0,
            t.assertArgument)(v >= -9007199254740991 && v <= n, "overflow", b || "value", v),
            Number(v);
        case "number":
            return (0,
            t.assertArgument)(Number.isInteger(v), "underflow", b || "value", v),
            (0,
            t.assertArgument)(v >= -9007199254740991 && v <= n, "overflow", b || "value", v),
            v;
        case "string":
            try {
                if (v === "")
                    throw new Error("empty string");
                return o(BigInt(v), b)
            } catch (x) {
                (0,
                t.assertArgument)(!1, `invalid numeric string: ${x.message}`, b || "value", v)
            }
        }
        (0,
        t.assertArgument)(!1, "invalid numeric value", b || "value", v)
    }
    We.getNumber = o;
    function c(v) {
        return o(p(v))
    }
    We.toNumber = c;
    function u(v, b) {
        let a = i(v, "value").toString(16);
        if (b == null)
            a.length % 2 && (a = "0" + a);
        else {
            const E = o(b, "width");
            for ((0,
            t.assert)(E * 2 >= a.length, `value exceeds width (${E} bytes)`, "NUMERIC_FAULT", {
                operation: "toBeHex",
                fault: "overflow",
                value: v
            }); a.length < E * 2; )
                a = "0" + a
        }
        return "0x" + a
    }
    We.toBeHex = u;
    function g(v) {
        const b = i(v, "value");
        if (b === s)
            return new Uint8Array([]);
        let x = b.toString(16);
        x.length % 2 && (x = "0" + x);
        const a = new Uint8Array(x.length / 2);
        for (let E = 0; E < a.length; E++) {
            const w = E * 2;
            a[E] = parseInt(x.substring(w, w + 2), 16)
        }
        return a
    }
    We.toBeArray = g;
    function P(v) {
        let b = (0,
        e.hexlify)((0,
        e.isBytesLike)(v) ? v : g(v)).substring(2);
        for (; b.startsWith("0"); )
            b = b.substring(1);
        return b === "" && (b = "0"),
        "0x" + b
    }
    return We.toQuantity = P,
    We
}
var Po;
function Ad() {
    if (Po)
        return Wt;
    Po = 1,
    Object.defineProperty(Wt, "__esModule", {
        value: !0
    }),
    Wt.decodeBase58 = Wt.encodeBase58 = void 0;
    const e = Ot()
      , t = Rt()
      , s = ns()
      , r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let n = null;
    function d(l) {
        if (n == null) {
            n = {};
            for (let o = 0; o < r.length; o++)
                n[r[o]] = BigInt(o)
        }
        const p = n[l];
        return (0,
        t.assertArgument)(p != null, "invalid base58 value", "letter", l),
        p
    }
    const h = BigInt(0)
      , m = BigInt(58);
    function f(l) {
        const p = (0,
        e.getBytes)(l);
        let o = (0,
        s.toBigInt)(p)
          , c = "";
        for (; o; )
            c = r[Number(o % m)] + c,
            o /= m;
        for (let u = 0; u < p.length && !p[u]; u++)
            c = r[0] + c;
        return c
    }
    Wt.encodeBase58 = f;
    function i(l) {
        let p = h;
        for (let o = 0; o < l.length; o++)
            p *= m,
            p += d(l[o]);
        return p
    }
    return Wt.decodeBase58 = i,
    Wt
}
var Zt = {}, ko;
function Uu() {
    if (ko)
        return Zt;
    ko = 1,
    Object.defineProperty(Zt, "__esModule", {
        value: !0
    }),
    Zt.encodeBase64 = Zt.decodeBase64 = void 0;
    const e = Ot();
    function t(r) {
        r = atob(r);
        const n = new Uint8Array(r.length);
        for (let d = 0; d < r.length; d++)
            n[d] = r.charCodeAt(d);
        return (0,
        e.getBytes)(n)
    }
    Zt.decodeBase64 = t;
    function s(r) {
        const n = (0,
        e.getBytes)(r);
        let d = "";
        for (let h = 0; h < n.length; h++)
            d += String.fromCharCode(n[h]);
        return btoa(d)
    }
    return Zt.encodeBase64 = s,
    Zt
}
var Gr = {}, _o;
function vd() {
    var s;
    if (_o)
        return Gr;
    _o = 1,
    Object.defineProperty(Gr, "__esModule", {
        value: !0
    }),
    Gr.EventPayload = void 0;
    const e = Tr();
    class t {
        constructor(n, d, h) {
            ue(this, "filter");
            ue(this, "emitter");
            he(this, s);
            Q(this, s, d),
            (0,
            e.defineProperties)(this, {
                emitter: n,
                filter: h
            })
        }
        async removeListener() {
            j(this, s) != null && await this.emitter.off(this.filter, j(this, s))
        }
    }
    return s = new WeakMap,
    Gr.EventPayload = t,
    Gr
}
var jt = {}, Qs = {}, To;
function qi() {
    return To || (To = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.toUtf8CodePoints = e.toUtf8String = e.toUtf8Bytes = e.Utf8ErrorFuncs = void 0;
        const t = Ot()
          , s = Rt();
        function r(p, o, c, u, g) {
            (0,
            s.assertArgument)(!1, `invalid codepoint at offset ${o}; ${p}`, "bytes", c)
        }
        function n(p, o, c, u, g) {
            if (p === "BAD_PREFIX" || p === "UNEXPECTED_CONTINUE") {
                let P = 0;
                for (let v = o + 1; v < c.length && c[v] >> 6 === 2; v++)
                    P++;
                return P
            }
            return p === "OVERRUN" ? c.length - o - 1 : 0
        }
        function d(p, o, c, u, g) {
            return p === "OVERLONG" ? ((0,
            s.assertArgument)(typeof g == "number", "invalid bad code point for replacement", "badCodepoint", g),
            u.push(g),
            0) : (u.push(65533),
            n(p, o, c))
        }
        e.Utf8ErrorFuncs = Object.freeze({
            error: r,
            ignore: n,
            replace: d
        });
        function h(p, o) {
            o == null && (o = e.Utf8ErrorFuncs.error);
            const c = (0,
            t.getBytes)(p, "bytes")
              , u = [];
            let g = 0;
            for (; g < c.length; ) {
                const P = c[g++];
                if (!(P >> 7)) {
                    u.push(P);
                    continue
                }
                let v = null
                  , b = null;
                if ((P & 224) === 192)
                    v = 1,
                    b = 127;
                else if ((P & 240) === 224)
                    v = 2,
                    b = 2047;
                else if ((P & 248) === 240)
                    v = 3,
                    b = 65535;
                else {
                    (P & 192) === 128 ? g += o("UNEXPECTED_CONTINUE", g - 1, c, u) : g += o("BAD_PREFIX", g - 1, c, u);
                    continue
                }
                if (g - 1 + v >= c.length) {
                    g += o("OVERRUN", g - 1, c, u);
                    continue
                }
                let x = P & (1 << 8 - v - 1) - 1;
                for (let a = 0; a < v; a++) {
                    let E = c[g];
                    if ((E & 192) != 128) {
                        g += o("MISSING_CONTINUE", g, c, u),
                        x = null;
                        break
                    }
                    x = x << 6 | E & 63,
                    g++
                }
                if (x !== null) {
                    if (x > 1114111) {
                        g += o("OUT_OF_RANGE", g - 1 - v, c, u, x);
                        continue
                    }
                    if (x >= 55296 && x <= 57343) {
                        g += o("UTF16_SURROGATE", g - 1 - v, c, u, x);
                        continue
                    }
                    if (x <= b) {
                        g += o("OVERLONG", g - 1 - v, c, u, x);
                        continue
                    }
                    u.push(x)
                }
            }
            return u
        }
        function m(p, o) {
            (0,
            s.assertArgument)(typeof p == "string", "invalid string value", "str", p),
            o != null && ((0,
            s.assertNormalize)(o),
            p = p.normalize(o));
            let c = [];
            for (let u = 0; u < p.length; u++) {
                const g = p.charCodeAt(u);
                if (g < 128)
                    c.push(g);
                else if (g < 2048)
                    c.push(g >> 6 | 192),
                    c.push(g & 63 | 128);
                else if ((g & 64512) == 55296) {
                    u++;
                    const P = p.charCodeAt(u);
                    (0,
                    s.assertArgument)(u < p.length && (P & 64512) === 56320, "invalid surrogate pair", "str", p);
                    const v = 65536 + ((g & 1023) << 10) + (P & 1023);
                    c.push(v >> 18 | 240),
                    c.push(v >> 12 & 63 | 128),
                    c.push(v >> 6 & 63 | 128),
                    c.push(v & 63 | 128)
                } else
                    c.push(g >> 12 | 224),
                    c.push(g >> 6 & 63 | 128),
                    c.push(g & 63 | 128)
            }
            return new Uint8Array(c)
        }
        e.toUtf8Bytes = m;
        function f(p) {
            return p.map(o => o <= 65535 ? String.fromCharCode(o) : (o -= 65536,
            String.fromCharCode((o >> 10 & 1023) + 55296, (o & 1023) + 56320))).join("")
        }
        function i(p, o) {
            return f(h(p, o))
        }
        e.toUtf8String = i;
        function l(p, o) {
            return h(m(p, o))
        }
        e.toUtf8CodePoints = l
    }(Qs)),
    Qs
}
var Xt = {}, Oo;
function Ed() {
    if (Oo)
        return Xt;
    Oo = 1,
    Object.defineProperty(Xt, "__esModule", {
        value: !0
    }),
    Xt.getUrl = Xt.createGetUrl = void 0;
    const e = Rt();
    function t(n) {
        async function d(h, m) {
            (0,
            e.assert)(m == null || !m.cancelled, "request cancelled before sending", "CANCELLED");
            const f = h.url.split(":")[0].toLowerCase();
            (0,
            e.assert)(f === "http" || f === "https", `unsupported protocol ${f}`, "UNSUPPORTED_OPERATION", {
                info: {
                    protocol: f
                },
                operation: "request"
            }),
            (0,
            e.assert)(f === "https" || !h.credentials || h.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
                operation: "request"
            });
            let i = null;
            const l = new AbortController
              , p = setTimeout( () => {
                i = (0,
                e.makeError)("request timeout", "TIMEOUT"),
                l.abort()
            }
            , h.timeout);
            m && m.addListener( () => {
                i = (0,
                e.makeError)("request cancelled", "CANCELLED"),
                l.abort()
            }
            );
            const o = Object.assign({}, n, {
                method: h.method,
                headers: new Headers(Array.from(h)),
                body: h.body || void 0,
                signal: l.signal
            });
            let c;
            try {
                c = await fetch(h.url, o)
            } catch (v) {
                throw clearTimeout(p),
                i || v
            }
            clearTimeout(p);
            const u = {};
            c.headers.forEach( (v, b) => {
                u[b.toLowerCase()] = v
            }
            );
            const g = await c.arrayBuffer()
              , P = g == null ? null : new Uint8Array(g);
            return {
                statusCode: c.status,
                statusMessage: c.statusText,
                headers: u,
                body: P
            }
        }
        return d
    }
    Xt.createGetUrl = t;
    const s = t({});
    async function r(n, d) {
        return s(n, d)
    }
    return Xt.getUrl = r,
    Xt
}
var Bo;
function Pd() {
    var S, T, C, N, A, R, y, k, _, O, L, U, $, B, I, F, z, Y, Xn, xe, W, ee, te, fe, be;
    if (Bo)
        return jt;
    Bo = 1,
    Object.defineProperty(jt, "__esModule", {
        value: !0
    }),
    jt.FetchResponse = jt.FetchRequest = jt.FetchCancelSignal = void 0;
    const e = Uu()
      , t = Ot()
      , s = Rt()
      , r = Tr()
      , n = qi()
      , d = Ed()
      , h = 12
      , m = 250;
    let f = (0,
    d.createGetUrl)();
    const i = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$","i")
      , l = new RegExp("^ipfs://(ipfs/)?(.*)$","i");
    let p = !1;
    async function o(re, M) {
        try {
            const K = re.match(i);
            if (!K)
                throw new Error("invalid data");
            return new x(200,"OK",{
                "content-type": K[1] || "text/plain"
            },K[2] ? (0,
            e.decodeBase64)(K[3]) : E(K[3]))
        } catch {
            return new x(599,"BAD REQUEST (invalid data: URI)",{},null,new b(re))
        }
    }
    function c(re) {
        async function M(K, V) {
            try {
                const oe = K.match(l);
                if (!oe)
                    throw new Error("invalid link");
                return new b(`${re}${oe[2]}`)
            } catch {
                return new x(599,"BAD REQUEST (invalid IPFS URI)",{},null,new b(K))
            }
        }
        return M
    }
    const u = {
        data: o,
        ipfs: c("https://gateway.ipfs.io/ipfs/")
    }
      , g = new WeakMap;
    class P {
        constructor(M) {
            he(this, S);
            he(this, T);
            Q(this, S, []),
            Q(this, T, !1),
            g.set(M, () => {
                if (!j(this, T)) {
                    Q(this, T, !0);
                    for (const K of j(this, S))
                        setTimeout( () => {
                            K()
                        }
                        , 0);
                    Q(this, S, [])
                }
            }
            )
        }
        addListener(M) {
            (0,
            s.assert)(!j(this, T), "singal already cancelled", "UNSUPPORTED_OPERATION", {
                operation: "fetchCancelSignal.addCancelListener"
            }),
            j(this, S).push(M)
        }
        get cancelled() {
            return j(this, T)
        }
        checkSignal() {
            (0,
            s.assert)(!this.cancelled, "cancelled", "CANCELLED", {})
        }
    }
    S = new WeakMap,
    T = new WeakMap,
    jt.FetchCancelSignal = P;
    function v(re) {
        if (re == null)
            throw new Error("missing signal; should not happen");
        return re.checkSignal(),
        re
    }
    const ne = class ne {
        constructor(M) {
            he(this, Y);
            he(this, C);
            he(this, N);
            he(this, A);
            he(this, R);
            he(this, y);
            he(this, k);
            he(this, _);
            he(this, O);
            he(this, L);
            he(this, U);
            he(this, $);
            he(this, B);
            he(this, I);
            he(this, F);
            he(this, z);
            Q(this, k, String(M)),
            Q(this, C, !1),
            Q(this, N, !0),
            Q(this, A, {}),
            Q(this, R, ""),
            Q(this, y, 3e5),
            Q(this, F, {
                slotInterval: m,
                maxAttempts: h
            }),
            Q(this, z, null)
        }
        get url() {
            return j(this, k)
        }
        set url(M) {
            Q(this, k, String(M))
        }
        get body() {
            return j(this, _) == null ? null : new Uint8Array(j(this, _))
        }
        set body(M) {
            if (M == null)
                Q(this, _, void 0),
                Q(this, O, void 0);
            else if (typeof M == "string")
                Q(this, _, (0,
                n.toUtf8Bytes)(M)),
                Q(this, O, "text/plain");
            else if (M instanceof Uint8Array)
                Q(this, _, M),
                Q(this, O, "application/octet-stream");
            else if (typeof M == "object")
                Q(this, _, (0,
                n.toUtf8Bytes)(JSON.stringify(M))),
                Q(this, O, "application/json");
            else
                throw new Error("invalid body")
        }
        hasBody() {
            return j(this, _) != null
        }
        get method() {
            return j(this, R) ? j(this, R) : this.hasBody() ? "POST" : "GET"
        }
        set method(M) {
            M == null && (M = ""),
            Q(this, R, String(M).toUpperCase())
        }
        get headers() {
            const M = Object.assign({}, j(this, A));
            return j(this, L) && (M.authorization = `Basic ${(0,
            e.encodeBase64)((0,
            n.toUtf8Bytes)(j(this, L)))}`),
            this.allowGzip && (M["accept-encoding"] = "gzip"),
            M["content-type"] == null && j(this, O) && (M["content-type"] = j(this, O)),
            this.body && (M["content-length"] = String(this.body.length)),
            M
        }
        getHeader(M) {
            return this.headers[M.toLowerCase()]
        }
        setHeader(M, K) {
            j(this, A)[String(M).toLowerCase()] = String(K)
        }
        clearHeaders() {
            Q(this, A, {})
        }
        [Symbol.iterator]() {
            const M = this.headers
              , K = Object.keys(M);
            let V = 0;
            return {
                next: () => {
                    if (V < K.length) {
                        const oe = K[V++];
                        return {
                            value: [oe, M[oe]],
                            done: !1
                        }
                    }
                    return {
                        value: void 0,
                        done: !0
                    }
                }
            }
        }
        get credentials() {
            return j(this, L) || null
        }
        setCredentials(M, K) {
            (0,
            s.assertArgument)(!M.match(/:/), "invalid basic authentication username", "username", "[REDACTED]"),
            Q(this, L, `${M}:${K}`)
        }
        get allowGzip() {
            return j(this, N)
        }
        set allowGzip(M) {
            Q(this, N, !!M)
        }
        get allowInsecureAuthentication() {
            return !!j(this, C)
        }
        set allowInsecureAuthentication(M) {
            Q(this, C, !!M)
        }
        get timeout() {
            return j(this, y)
        }
        set timeout(M) {
            (0,
            s.assertArgument)(M >= 0, "timeout must be non-zero", "timeout", M),
            Q(this, y, M)
        }
        get preflightFunc() {
            return j(this, U) || null
        }
        set preflightFunc(M) {
            Q(this, U, M)
        }
        get processFunc() {
            return j(this, $) || null
        }
        set processFunc(M) {
            Q(this, $, M)
        }
        get retryFunc() {
            return j(this, B) || null
        }
        set retryFunc(M) {
            Q(this, B, M)
        }
        get getUrlFunc() {
            return j(this, z) || f
        }
        set getUrlFunc(M) {
            Q(this, z, M)
        }
        toString() {
            return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${j(this, _) ? (0,
            t.hexlify)(j(this, _)) : "null"}>`
        }
        setThrottleParams(M) {
            M.slotInterval != null && (j(this, F).slotInterval = M.slotInterval),
            M.maxAttempts != null && (j(this, F).maxAttempts = M.maxAttempts)
        }
        send() {
            return (0,
            s.assert)(j(this, I) == null, "request already sent", "UNSUPPORTED_OPERATION", {
                operation: "fetchRequest.send"
            }),
            Q(this, I, new P(this)),
            we(this, Y, Xn).call(this, 0, a() + this.timeout, 0, this, new x(0,"",{},null,this))
        }
        cancel() {
            (0,
            s.assert)(j(this, I) != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
                operation: "fetchRequest.cancel"
            });
            const M = g.get(this);
            if (!M)
                throw new Error("missing signal; should not happen");
            M()
        }
        redirect(M) {
            const K = this.url.split(":")[0].toLowerCase()
              , V = M.split(":")[0].toLowerCase();
            (0,
            s.assert)(this.method === "GET" && (K !== "https" || V !== "http") && M.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
                operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(M)})`
            });
            const oe = new ne(M);
            return oe.method = "GET",
            oe.allowGzip = this.allowGzip,
            oe.timeout = this.timeout,
            Q(oe, A, Object.assign({}, j(this, A))),
            j(this, _) && Q(oe, _, new Uint8Array(j(this, _))),
            Q(oe, O, j(this, O)),
            oe
        }
        clone() {
            const M = new ne(this.url);
            return Q(M, R, j(this, R)),
            j(this, _) && Q(M, _, j(this, _)),
            Q(M, O, j(this, O)),
            Q(M, A, Object.assign({}, j(this, A))),
            Q(M, L, j(this, L)),
            this.allowGzip && (M.allowGzip = !0),
            M.timeout = this.timeout,
            this.allowInsecureAuthentication && (M.allowInsecureAuthentication = !0),
            Q(M, U, j(this, U)),
            Q(M, $, j(this, $)),
            Q(M, B, j(this, B)),
            Q(M, F, Object.assign({}, j(this, F))),
            Q(M, z, j(this, z)),
            M
        }
        static lockConfig() {
            p = !0
        }
        static getGateway(M) {
            return u[M.toLowerCase()] || null
        }
        static registerGateway(M, K) {
            if (M = M.toLowerCase(),
            M === "http" || M === "https")
                throw new Error(`cannot intercept ${M}; use registerGetUrl`);
            if (p)
                throw new Error("gateways locked");
            u[M] = K
        }
        static registerGetUrl(M) {
            if (p)
                throw new Error("gateways locked");
            f = M
        }
        static createGetUrlFunc(M) {
            return (0,
            d.createGetUrl)(M)
        }
        static createDataGateway() {
            return o
        }
        static createIpfsGatewayFunc(M) {
            return c(M)
        }
    }
    ;
    C = new WeakMap,
    N = new WeakMap,
    A = new WeakMap,
    R = new WeakMap,
    y = new WeakMap,
    k = new WeakMap,
    _ = new WeakMap,
    O = new WeakMap,
    L = new WeakMap,
    U = new WeakMap,
    $ = new WeakMap,
    B = new WeakMap,
    I = new WeakMap,
    F = new WeakMap,
    z = new WeakMap,
    Y = new WeakSet,
    Xn = async function(M, K, V, oe, me) {
        var q, ae, Z;
        if (M >= j(this, F).maxAttempts)
            return me.makeServerError("exceeded maximum retry limit");
        (0,
        s.assert)(a() <= K, "timeout", "TIMEOUT", {
            operation: "request.send",
            reason: "timeout",
            request: oe
        }),
        V > 0 && await w(V);
        let Pe = this.clone();
        const se = (Pe.url.split(":")[0] || "").toLowerCase();
        if (se in u) {
            const J = await u[se](Pe.url, v(j(oe, I)));
            if (J instanceof x) {
                let D = J;
                if (this.processFunc) {
                    v(j(oe, I));
                    try {
                        D = await this.processFunc(Pe, D)
                    } catch (X) {
                        (X.throttle == null || typeof X.stall != "number") && D.makeServerError("error in post-processing function", X).assertOk()
                    }
                }
                return D
            }
            Pe = J
        }
        this.preflightFunc && (Pe = await this.preflightFunc(Pe));
        const H = await this.getUrlFunc(Pe, v(j(oe, I)));
        let G = new x(H.statusCode,H.statusMessage,H.headers,H.body,oe);
        if (G.statusCode === 301 || G.statusCode === 302) {
            try {
                const J = G.headers.location || "";
                return we(q = Pe.redirect(J), Y, Xn).call(q, M + 1, K, 0, oe, G)
            } catch {}
            return G
        } else if (G.statusCode === 429 && (this.retryFunc == null || await this.retryFunc(Pe, G, M))) {
            const J = G.headers["retry-after"];
            let D = j(this, F).slotInterval * Math.trunc(Math.random() * Math.pow(2, M));
            return typeof J == "string" && J.match(/^[1-9][0-9]*$/) && (D = parseInt(J)),
            we(ae = Pe.clone(), Y, Xn).call(ae, M + 1, K, D, oe, G)
        }
        if (this.processFunc) {
            v(j(oe, I));
            try {
                G = await this.processFunc(Pe, G)
            } catch (J) {
                (J.throttle == null || typeof J.stall != "number") && G.makeServerError("error in post-processing function", J).assertOk();
                let D = j(this, F).slotInterval * Math.trunc(Math.random() * Math.pow(2, M));
                return J.stall >= 0 && (D = J.stall),
                we(Z = Pe.clone(), Y, Xn).call(Z, M + 1, K, D, oe, G)
            }
        }
        return G
    }
    ;
    let b = ne;
    jt.FetchRequest = b;
    const le = class le {
        constructor(M, K, V, oe, me) {
            he(this, xe);
            he(this, W);
            he(this, ee);
            he(this, te);
            he(this, fe);
            he(this, be);
            Q(this, xe, M),
            Q(this, W, K),
            Q(this, ee, Object.keys(V).reduce( (Pe, se) => (Pe[se.toLowerCase()] = String(V[se]),
            Pe), {})),
            Q(this, te, oe == null ? null : new Uint8Array(oe)),
            Q(this, fe, me || null),
            Q(this, be, {
                message: ""
            })
        }
        toString() {
            return `<FetchResponse status=${this.statusCode} body=${j(this, te) ? (0,
            t.hexlify)(j(this, te)) : "null"}>`
        }
        get statusCode() {
            return j(this, xe)
        }
        get statusMessage() {
            return j(this, W)
        }
        get headers() {
            return Object.assign({}, j(this, ee))
        }
        get body() {
            return j(this, te) == null ? null : new Uint8Array(j(this, te))
        }
        get bodyText() {
            try {
                return j(this, te) == null ? "" : (0,
                n.toUtf8String)(j(this, te))
            } catch {
                (0,
                s.assert)(!1, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
                    operation: "bodyText",
                    info: {
                        response: this
                    }
                })
            }
        }
        get bodyJson() {
            try {
                return JSON.parse(this.bodyText)
            } catch {
                (0,
                s.assert)(!1, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
                    operation: "bodyJson",
                    info: {
                        response: this
                    }
                })
            }
        }
        [Symbol.iterator]() {
            const M = this.headers
              , K = Object.keys(M);
            let V = 0;
            return {
                next: () => {
                    if (V < K.length) {
                        const oe = K[V++];
                        return {
                            value: [oe, M[oe]],
                            done: !1
                        }
                    }
                    return {
                        value: void 0,
                        done: !0
                    }
                }
            }
        }
        makeServerError(M, K) {
            let V;
            M ? V = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${M})` : (M = `${this.statusCode} ${this.statusMessage}`,
            V = `CLIENT ESCALATED SERVER ERROR (${M})`);
            const oe = new le(599,V,this.headers,this.body,j(this, fe) || void 0);
            return Q(oe, be, {
                message: M,
                error: K
            }),
            oe
        }
        throwThrottleError(M, K) {
            K == null ? K = -1 : (0,
            s.assertArgument)(Number.isInteger(K) && K >= 0, "invalid stall timeout", "stall", K);
            const V = new Error(M || "throttling requests");
            throw (0,
            r.defineProperties)(V, {
                stall: K,
                throttle: !0
            }),
            V
        }
        getHeader(M) {
            return this.headers[M.toLowerCase()]
        }
        hasBody() {
            return j(this, te) != null
        }
        get request() {
            return j(this, fe)
        }
        ok() {
            return j(this, be).message === "" && this.statusCode >= 200 && this.statusCode < 300
        }
        assertOk() {
            if (this.ok())
                return;
            let {message: M, error: K} = j(this, be);
            M === "" && (M = `server response ${this.statusCode} ${this.statusMessage}`);
            let V = null;
            this.request && (V = this.request.url);
            let oe = null;
            try {
                j(this, te) && (oe = (0,
                n.toUtf8String)(j(this, te)))
            } catch {}
            (0,
            s.assert)(!1, M, "SERVER_ERROR", {
                request: this.request || "unknown request",
                response: this,
                error: K,
                info: {
                    requestUrl: V,
                    responseBody: oe,
                    responseStatus: `${this.statusCode} ${this.statusMessage}`
                }
            })
        }
    }
    ;
    xe = new WeakMap,
    W = new WeakMap,
    ee = new WeakMap,
    te = new WeakMap,
    fe = new WeakMap,
    be = new WeakMap;
    let x = le;
    jt.FetchResponse = x;
    function a() {
        return new Date().getTime()
    }
    function E(re) {
        return (0,
        n.toUtf8Bytes)(re.replace(/%([0-9a-f][0-9a-f])/gi, (M, K) => String.fromCharCode(parseInt(K, 16))))
    }
    function w(re) {
        return new Promise(M => setTimeout(M, re))
    }
    return jt
}
var $r = {}, So;
function Fu() {
    var g, P, v, b, Pr, Ht, bi, gi, mi, yi;
    if (So)
        return $r;
    So = 1,
    Object.defineProperty($r, "__esModule", {
        value: !0
    }),
    $r.FixedNumber = void 0;
    const e = Ot()
      , t = Rt()
      , s = ns()
      , r = Tr()
      , n = BigInt(-1)
      , d = BigInt(0)
      , h = BigInt(1)
      , m = BigInt(5)
      , f = {};
    let i = "0000";
    for (; i.length < 80; )
        i += i;
    function l(N) {
        let A = i;
        for (; A.length < N; )
            A += A;
        return BigInt("1" + A.substring(0, N))
    }
    function p(N, A, R) {
        const y = BigInt(A.width);
        if (A.signed) {
            const k = h << y - h;
            (0,
            t.assert)(R == null || N >= -k && N < k, "overflow", "NUMERIC_FAULT", {
                operation: R,
                fault: "overflow",
                value: N
            }),
            N > d ? N = (0,
            s.fromTwos)((0,
            s.mask)(N, y), y) : N = -(0,
            s.fromTwos)((0,
            s.mask)(-N, y), y)
        } else {
            const k = h << y;
            (0,
            t.assert)(R == null || N >= 0 && N < k, "overflow", "NUMERIC_FAULT", {
                operation: R,
                fault: "overflow",
                value: N
            }),
            N = (N % k + k) % k & k - h
        }
        return N
    }
    function o(N) {
        typeof N == "number" && (N = `fixed128x${N}`);
        let A = !0
          , R = 128
          , y = 18;
        if (typeof N == "string") {
            if (N !== "fixed")
                if (N === "ufixed")
                    A = !1;
                else {
                    const _ = N.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                    (0,
                    t.assertArgument)(_, "invalid fixed format", "format", N),
                    A = _[1] !== "u",
                    R = parseInt(_[2]),
                    y = parseInt(_[3])
                }
        } else if (N) {
            const _ = N
              , O = (L, U, $) => _[L] == null ? $ : ((0,
            t.assertArgument)(typeof _[L] === U, "invalid fixed format (" + L + " not " + U + ")", "format." + L, _[L]),
            _[L]);
            A = O("signed", "boolean", A),
            R = O("width", "number", R),
            y = O("decimals", "number", y)
        }
        (0,
        t.assertArgument)(R % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", R),
        (0,
        t.assertArgument)(y <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", y);
        const k = (A ? "" : "u") + "fixed" + String(R) + "x" + String(y);
        return {
            signed: A,
            width: R,
            decimals: y,
            name: k
        }
    }
    function c(N, A) {
        let R = "";
        N < d && (R = "-",
        N *= n);
        let y = N.toString();
        if (A === 0)
            return R + y;
        for (; y.length <= A; )
            y = i + y;
        const k = y.length - A;
        for (y = y.substring(0, k) + "." + y.substring(k); y[0] === "0" && y[1] !== "."; )
            y = y.substring(1);
        for (; y[y.length - 1] === "0" && y[y.length - 2] !== "."; )
            y = y.substring(0, y.length - 1);
        return R + y
    }
    const C = class C {
        constructor(A, R, y) {
            he(this, b);
            ue(this, "format");
            he(this, g);
            he(this, P);
            he(this, v);
            ue(this, "_value");
            (0,
            t.assertPrivate)(A, f, "FixedNumber"),
            Q(this, P, R),
            Q(this, g, y);
            const k = c(R, y.decimals);
            (0,
            r.defineProperties)(this, {
                format: y.name,
                _value: k
            }),
            Q(this, v, l(y.decimals))
        }
        get signed() {
            return j(this, g).signed
        }
        get width() {
            return j(this, g).width
        }
        get decimals() {
            return j(this, g).decimals
        }
        get value() {
            return j(this, P)
        }
        addUnsafe(A) {
            return we(this, b, bi).call(this, A)
        }
        add(A) {
            return we(this, b, bi).call(this, A, "add")
        }
        subUnsafe(A) {
            return we(this, b, gi).call(this, A)
        }
        sub(A) {
            return we(this, b, gi).call(this, A, "sub")
        }
        mulUnsafe(A) {
            return we(this, b, mi).call(this, A)
        }
        mul(A) {
            return we(this, b, mi).call(this, A, "mul")
        }
        mulSignal(A) {
            we(this, b, Pr).call(this, A);
            const R = j(this, P) * j(A, P);
            return (0,
            t.assert)(R % j(this, v) === d, "precision lost during signalling mul", "NUMERIC_FAULT", {
                operation: "mulSignal",
                fault: "underflow",
                value: this
            }),
            we(this, b, Ht).call(this, R / j(this, v), "mulSignal")
        }
        divUnsafe(A) {
            return we(this, b, yi).call(this, A)
        }
        div(A) {
            return we(this, b, yi).call(this, A, "div")
        }
        divSignal(A) {
            (0,
            t.assert)(j(A, P) !== d, "division by zero", "NUMERIC_FAULT", {
                operation: "div",
                fault: "divide-by-zero",
                value: this
            }),
            we(this, b, Pr).call(this, A);
            const R = j(this, P) * j(this, v);
            return (0,
            t.assert)(R % j(A, P) === d, "precision lost during signalling div", "NUMERIC_FAULT", {
                operation: "divSignal",
                fault: "underflow",
                value: this
            }),
            we(this, b, Ht).call(this, R / j(A, P), "divSignal")
        }
        cmp(A) {
            let R = this.value
              , y = A.value;
            const k = this.decimals - A.decimals;
            return k > 0 ? y *= l(k) : k < 0 && (R *= l(-k)),
            R < y ? -1 : R > y ? 1 : 0
        }
        eq(A) {
            return this.cmp(A) === 0
        }
        lt(A) {
            return this.cmp(A) < 0
        }
        lte(A) {
            return this.cmp(A) <= 0
        }
        gt(A) {
            return this.cmp(A) > 0
        }
        gte(A) {
            return this.cmp(A) >= 0
        }
        floor() {
            let A = j(this, P);
            return j(this, P) < d && (A -= j(this, v) - h),
            A = j(this, P) / j(this, v) * j(this, v),
            we(this, b, Ht).call(this, A, "floor")
        }
        ceiling() {
            let A = j(this, P);
            return j(this, P) > d && (A += j(this, v) - h),
            A = j(this, P) / j(this, v) * j(this, v),
            we(this, b, Ht).call(this, A, "ceiling")
        }
        round(A) {
            if (A == null && (A = 0),
            A >= this.decimals)
                return this;
            const R = this.decimals - A
              , y = m * l(R - 1);
            let k = this.value + y;
            const _ = l(R);
            return k = k / _ * _,
            p(k, j(this, g), "round"),
            new C(f,k,j(this, g))
        }
        isZero() {
            return j(this, P) === d
        }
        isNegative() {
            return j(this, P) < d
        }
        toString() {
            return this._value
        }
        toUnsafeFloat() {
            return parseFloat(this.toString())
        }
        toFormat(A) {
            return C.fromString(this.toString(), A)
        }
        static fromValue(A, R, y) {
            const k = R == null ? 0 : (0,
            s.getNumber)(R)
              , _ = o(y);
            let O = (0,
            s.getBigInt)(A, "value");
            const L = k - _.decimals;
            if (L > 0) {
                const U = l(L);
                (0,
                t.assert)(O % U === d, "value loses precision for format", "NUMERIC_FAULT", {
                    operation: "fromValue",
                    fault: "underflow",
                    value: A
                }),
                O /= U
            } else
                L < 0 && (O *= l(-L));
            return p(O, _, "fromValue"),
            new C(f,O,_)
        }
        static fromString(A, R) {
            const y = A.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
            (0,
            t.assertArgument)(y && y[2].length + y[3].length > 0, "invalid FixedNumber string value", "value", A);
            const k = o(R);
            let _ = y[2] || "0"
              , O = y[3] || "";
            for (; O.length < k.decimals; )
                O += i;
            (0,
            t.assert)(O.substring(k.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
                operation: "fromString",
                fault: "underflow",
                value: A
            }),
            O = O.substring(0, k.decimals);
            const L = BigInt(y[1] + _ + O);
            return p(L, k, "fromString"),
            new C(f,L,k)
        }
        static fromBytes(A, R) {
            let y = (0,
            s.toBigInt)((0,
            e.getBytes)(A, "value"));
            const k = o(R);
            return k.signed && (y = (0,
            s.fromTwos)(y, k.width)),
            p(y, k, "fromBytes"),
            new C(f,y,k)
        }
    }
    ;
    g = new WeakMap,
    P = new WeakMap,
    v = new WeakMap,
    b = new WeakSet,
    Pr = function(A) {
        (0,
        t.assertArgument)(this.format === A.format, "incompatible format; use fixedNumber.toFormat", "other", A)
    }
    ,
    Ht = function(A, R) {
        return A = p(A, j(this, g), R),
        new C(f,A,j(this, g))
    }
    ,
    bi = function(A, R) {
        return we(this, b, Pr).call(this, A),
        we(this, b, Ht).call(this, j(this, P) + j(A, P), R)
    }
    ,
    gi = function(A, R) {
        return we(this, b, Pr).call(this, A),
        we(this, b, Ht).call(this, j(this, P) - j(A, P), R)
    }
    ,
    mi = function(A, R) {
        return we(this, b, Pr).call(this, A),
        we(this, b, Ht).call(this, j(this, P) * j(A, P) / j(this, v), R)
    }
    ,
    yi = function(A, R) {
        return (0,
        t.assert)(j(A, P) !== d, "division by zero", "NUMERIC_FAULT", {
            operation: "div",
            fault: "divide-by-zero",
            value: this
        }),
        we(this, b, Pr).call(this, A),
        we(this, b, Ht).call(this, j(this, P) * j(this, v) / j(A, P), R)
    }
    ;
    let u = C;
    return $r.FixedNumber = u,
    $r
}
var qr = {}, Co;
function kd() {
    if (Co)
        return qr;
    Co = 1,
    Object.defineProperty(qr, "__esModule", {
        value: !0
    }),
    qr.decodeRlp = void 0;
    const e = Ot()
      , t = Rt()
      , s = Ot();
    function r(f) {
        let i = f.toString(16);
        for (; i.length < 2; )
            i = "0" + i;
        return "0x" + i
    }
    function n(f, i, l) {
        let p = 0;
        for (let o = 0; o < l; o++)
            p = p * 256 + f[i + o];
        return p
    }
    function d(f, i, l, p) {
        const o = [];
        for (; l < i + 1 + p; ) {
            const c = h(f, l);
            o.push(c.result),
            l += c.consumed,
            (0,
            t.assert)(l <= i + 1 + p, "child data too short", "BUFFER_OVERRUN", {
                buffer: f,
                length: p,
                offset: i
            })
        }
        return {
            consumed: 1 + p,
            result: o
        }
    }
    function h(f, i) {
        (0,
        t.assert)(f.length !== 0, "data too short", "BUFFER_OVERRUN", {
            buffer: f,
            length: 0,
            offset: 1
        });
        const l = p => {
            (0,
            t.assert)(p <= f.length, "data short segment too short", "BUFFER_OVERRUN", {
                buffer: f,
                length: f.length,
                offset: p
            })
        }
        ;
        if (f[i] >= 248) {
            const p = f[i] - 247;
            l(i + 1 + p);
            const o = n(f, i + 1, p);
            return l(i + 1 + p + o),
            d(f, i, i + 1 + p, p + o)
        } else if (f[i] >= 192) {
            const p = f[i] - 192;
            return l(i + 1 + p),
            d(f, i, i + 1, p)
        } else if (f[i] >= 184) {
            const p = f[i] - 183;
            l(i + 1 + p);
            const o = n(f, i + 1, p);
            l(i + 1 + p + o);
            const c = (0,
            e.hexlify)(f.slice(i + 1 + p, i + 1 + p + o));
            return {
                consumed: 1 + p + o,
                result: c
            }
        } else if (f[i] >= 128) {
            const p = f[i] - 128;
            l(i + 1 + p);
            const o = (0,
            e.hexlify)(f.slice(i + 1, i + 1 + p));
            return {
                consumed: 1 + p,
                result: o
            }
        }
        return {
            consumed: 1,
            result: r(f[i])
        }
    }
    function m(f) {
        const i = (0,
        s.getBytes)(f, "data")
          , l = h(i, 0);
        return (0,
        t.assertArgument)(l.consumed === i.length, "unexpected junk after rlp payload", "data", f),
        l.result
    }
    return qr.decodeRlp = m,
    qr
}
var zr = {}, No;
function _d() {
    if (No)
        return zr;
    No = 1,
    Object.defineProperty(zr, "__esModule", {
        value: !0
    }),
    zr.encodeRlp = void 0;
    const e = Ot();
    function t(d) {
        const h = [];
        for (; d; )
            h.unshift(d & 255),
            d >>= 8;
        return h
    }
    function s(d) {
        if (Array.isArray(d)) {
            let f = [];
            if (d.forEach(function(l) {
                f = f.concat(s(l))
            }),
            f.length <= 55)
                return f.unshift(192 + f.length),
                f;
            const i = t(f.length);
            return i.unshift(247 + i.length),
            i.concat(f)
        }
        const h = Array.prototype.slice.call((0,
        e.getBytes)(d, "object"));
        if (h.length === 1 && h[0] <= 127)
            return h;
        if (h.length <= 55)
            return h.unshift(128 + h.length),
            h;
        const m = t(h.length);
        return m.unshift(183 + m.length),
        m.concat(h)
    }
    const r = "0123456789abcdef";
    function n(d) {
        let h = "0x";
        for (const m of s(d))
            h += r[m >> 4],
            h += r[m & 15];
        return h
    }
    return zr.encodeRlp = n,
    zr
}
var At = {}, Ro;
function Td() {
    if (Ro)
        return At;
    Ro = 1,
    Object.defineProperty(At, "__esModule", {
        value: !0
    }),
    At.parseEther = At.formatEther = At.parseUnits = At.formatUnits = void 0;
    const e = Rt()
      , t = Fu()
      , s = ns()
      , r = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
    function n(f, i) {
        let l = 18;
        if (typeof i == "string") {
            const p = r.indexOf(i);
            (0,
            e.assertArgument)(p >= 0, "invalid unit", "unit", i),
            l = 3 * p
        } else
            i != null && (l = (0,
            s.getNumber)(i, "unit"));
        return t.FixedNumber.fromValue(f, l, {
            decimals: l,
            width: 512
        }).toString()
    }
    At.formatUnits = n;
    function d(f, i) {
        (0,
        e.assertArgument)(typeof f == "string", "value must be a string", "value", f);
        let l = 18;
        if (typeof i == "string") {
            const p = r.indexOf(i);
            (0,
            e.assertArgument)(p >= 0, "invalid unit", "unit", i),
            l = 3 * p
        } else
            i != null && (l = (0,
            s.getNumber)(i, "unit"));
        return t.FixedNumber.fromString(f, {
            decimals: l,
            width: 512
        }).value
    }
    At.parseUnits = d;
    function h(f) {
        return n(f, 18)
    }
    At.formatEther = h;
    function m(f) {
        return d(f, 18)
    }
    return At.parseEther = m,
    At
}
var Kr = {}, Io;
function Od() {
    if (Io)
        return Kr;
    Io = 1,
    Object.defineProperty(Kr, "__esModule", {
        value: !0
    }),
    Kr.uuidV4 = void 0;
    const e = Ot();
    function t(s) {
        const r = (0,
        e.getBytes)(s, "randomBytes");
        r[6] = r[6] & 15 | 64,
        r[8] = r[8] & 63 | 128;
        const n = (0,
        e.hexlify)(r);
        return [n.substring(2, 10), n.substring(10, 14), n.substring(14, 18), n.substring(18, 22), n.substring(22, 34)].join("-")
    }
    return Kr.uuidV4 = t,
    Kr
}
var jo;
function Be() {
    return jo || (jo = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.toUtf8String = e.toUtf8CodePoints = e.toUtf8Bytes = e.parseUnits = e.formatUnits = e.parseEther = e.formatEther = e.encodeRlp = e.decodeRlp = e.defineProperties = e.resolveProperties = e.toQuantity = e.toBeArray = e.toBeHex = e.toNumber = e.toBigInt = e.getUint = e.getNumber = e.getBigInt = e.mask = e.toTwos = e.fromTwos = e.FixedNumber = e.FetchCancelSignal = e.FetchResponse = e.FetchRequest = e.EventPayload = e.makeError = e.assertNormalize = e.assertPrivate = e.assertArgumentCount = e.assertArgument = e.assert = e.isError = e.isCallException = e.zeroPadBytes = e.zeroPadValue = e.stripZerosLeft = e.dataSlice = e.dataLength = e.concat = e.hexlify = e.isBytesLike = e.isHexString = e.getBytesCopy = e.getBytes = e.encodeBase64 = e.decodeBase64 = e.encodeBase58 = e.decodeBase58 = void 0,
        e.uuidV4 = e.Utf8ErrorFuncs = void 0;
        var t = Ad();
        Object.defineProperty(e, "decodeBase58", {
            enumerable: !0,
            get: function() {
                return t.decodeBase58
            }
        }),
        Object.defineProperty(e, "encodeBase58", {
            enumerable: !0,
            get: function() {
                return t.encodeBase58
            }
        });
        var s = Uu();
        Object.defineProperty(e, "decodeBase64", {
            enumerable: !0,
            get: function() {
                return s.decodeBase64
            }
        }),
        Object.defineProperty(e, "encodeBase64", {
            enumerable: !0,
            get: function() {
                return s.encodeBase64
            }
        });
        var r = Ot();
        Object.defineProperty(e, "getBytes", {
            enumerable: !0,
            get: function() {
                return r.getBytes
            }
        }),
        Object.defineProperty(e, "getBytesCopy", {
            enumerable: !0,
            get: function() {
                return r.getBytesCopy
            }
        }),
        Object.defineProperty(e, "isHexString", {
            enumerable: !0,
            get: function() {
                return r.isHexString
            }
        }),
        Object.defineProperty(e, "isBytesLike", {
            enumerable: !0,
            get: function() {
                return r.isBytesLike
            }
        }),
        Object.defineProperty(e, "hexlify", {
            enumerable: !0,
            get: function() {
                return r.hexlify
            }
        }),
        Object.defineProperty(e, "concat", {
            enumerable: !0,
            get: function() {
                return r.concat
            }
        }),
        Object.defineProperty(e, "dataLength", {
            enumerable: !0,
            get: function() {
                return r.dataLength
            }
        }),
        Object.defineProperty(e, "dataSlice", {
            enumerable: !0,
            get: function() {
                return r.dataSlice
            }
        }),
        Object.defineProperty(e, "stripZerosLeft", {
            enumerable: !0,
            get: function() {
                return r.stripZerosLeft
            }
        }),
        Object.defineProperty(e, "zeroPadValue", {
            enumerable: !0,
            get: function() {
                return r.zeroPadValue
            }
        }),
        Object.defineProperty(e, "zeroPadBytes", {
            enumerable: !0,
            get: function() {
                return r.zeroPadBytes
            }
        });
        var n = Rt();
        Object.defineProperty(e, "isCallException", {
            enumerable: !0,
            get: function() {
                return n.isCallException
            }
        }),
        Object.defineProperty(e, "isError", {
            enumerable: !0,
            get: function() {
                return n.isError
            }
        }),
        Object.defineProperty(e, "assert", {
            enumerable: !0,
            get: function() {
                return n.assert
            }
        }),
        Object.defineProperty(e, "assertArgument", {
            enumerable: !0,
            get: function() {
                return n.assertArgument
            }
        }),
        Object.defineProperty(e, "assertArgumentCount", {
            enumerable: !0,
            get: function() {
                return n.assertArgumentCount
            }
        }),
        Object.defineProperty(e, "assertPrivate", {
            enumerable: !0,
            get: function() {
                return n.assertPrivate
            }
        }),
        Object.defineProperty(e, "assertNormalize", {
            enumerable: !0,
            get: function() {
                return n.assertNormalize
            }
        }),
        Object.defineProperty(e, "makeError", {
            enumerable: !0,
            get: function() {
                return n.makeError
            }
        });
        var d = vd();
        Object.defineProperty(e, "EventPayload", {
            enumerable: !0,
            get: function() {
                return d.EventPayload
            }
        });
        var h = Pd();
        Object.defineProperty(e, "FetchRequest", {
            enumerable: !0,
            get: function() {
                return h.FetchRequest
            }
        }),
        Object.defineProperty(e, "FetchResponse", {
            enumerable: !0,
            get: function() {
                return h.FetchResponse
            }
        }),
        Object.defineProperty(e, "FetchCancelSignal", {
            enumerable: !0,
            get: function() {
                return h.FetchCancelSignal
            }
        });
        var m = Fu();
        Object.defineProperty(e, "FixedNumber", {
            enumerable: !0,
            get: function() {
                return m.FixedNumber
            }
        });
        var f = ns();
        Object.defineProperty(e, "fromTwos", {
            enumerable: !0,
            get: function() {
                return f.fromTwos
            }
        }),
        Object.defineProperty(e, "toTwos", {
            enumerable: !0,
            get: function() {
                return f.toTwos
            }
        }),
        Object.defineProperty(e, "mask", {
            enumerable: !0,
            get: function() {
                return f.mask
            }
        }),
        Object.defineProperty(e, "getBigInt", {
            enumerable: !0,
            get: function() {
                return f.getBigInt
            }
        }),
        Object.defineProperty(e, "getNumber", {
            enumerable: !0,
            get: function() {
                return f.getNumber
            }
        }),
        Object.defineProperty(e, "getUint", {
            enumerable: !0,
            get: function() {
                return f.getUint
            }
        }),
        Object.defineProperty(e, "toBigInt", {
            enumerable: !0,
            get: function() {
                return f.toBigInt
            }
        }),
        Object.defineProperty(e, "toNumber", {
            enumerable: !0,
            get: function() {
                return f.toNumber
            }
        }),
        Object.defineProperty(e, "toBeHex", {
            enumerable: !0,
            get: function() {
                return f.toBeHex
            }
        }),
        Object.defineProperty(e, "toBeArray", {
            enumerable: !0,
            get: function() {
                return f.toBeArray
            }
        }),
        Object.defineProperty(e, "toQuantity", {
            enumerable: !0,
            get: function() {
                return f.toQuantity
            }
        });
        var i = Tr();
        Object.defineProperty(e, "resolveProperties", {
            enumerable: !0,
            get: function() {
                return i.resolveProperties
            }
        }),
        Object.defineProperty(e, "defineProperties", {
            enumerable: !0,
            get: function() {
                return i.defineProperties
            }
        });
        var l = kd();
        Object.defineProperty(e, "decodeRlp", {
            enumerable: !0,
            get: function() {
                return l.decodeRlp
            }
        });
        var p = _d();
        Object.defineProperty(e, "encodeRlp", {
            enumerable: !0,
            get: function() {
                return p.encodeRlp
            }
        });
        var o = Td();
        Object.defineProperty(e, "formatEther", {
            enumerable: !0,
            get: function() {
                return o.formatEther
            }
        }),
        Object.defineProperty(e, "parseEther", {
            enumerable: !0,
            get: function() {
                return o.parseEther
            }
        }),
        Object.defineProperty(e, "formatUnits", {
            enumerable: !0,
            get: function() {
                return o.formatUnits
            }
        }),
        Object.defineProperty(e, "parseUnits", {
            enumerable: !0,
            get: function() {
                return o.parseUnits
            }
        });
        var c = qi();
        Object.defineProperty(e, "toUtf8Bytes", {
            enumerable: !0,
            get: function() {
                return c.toUtf8Bytes
            }
        }),
        Object.defineProperty(e, "toUtf8CodePoints", {
            enumerable: !0,
            get: function() {
                return c.toUtf8CodePoints
            }
        }),
        Object.defineProperty(e, "toUtf8String", {
            enumerable: !0,
            get: function() {
                return c.toUtf8String
            }
        }),
        Object.defineProperty(e, "Utf8ErrorFuncs", {
            enumerable: !0,
            get: function() {
                return c.Utf8ErrorFuncs
            }
        });
        var u = Od();
        Object.defineProperty(e, "uuidV4", {
            enumerable: !0,
            get: function() {
                return u.uuidV4
            }
        })
    }(Js)),
    Js
}
var Ws = {}, Mo;
function Bt() {
    return Mo || (Mo = 1,
    function(e) {
        var P, b, x, a, fs, w, S, T, C, N, A, xi, Du;
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.Reader = e.Writer = e.Coder = e.checkResultErrors = e.Result = e.WordSize = void 0;
        const t = Be();
        e.WordSize = 32;
        const s = new Uint8Array(e.WordSize)
          , r = ["then"]
          , n = {}
          , d = new WeakMap;
        function h(_) {
            return d.get(_)
        }
        function m(_, O) {
            d.set(_, O)
        }
        function f(_, O) {
            const L = new Error(`deferred error during ABI decoding triggered accessing ${_}`);
            throw L.error = O,
            L
        }
        function i(_, O, L) {
            return _.indexOf(null) >= 0 ? O.map( (U, $) => U instanceof l ? i(h(U), U, L) : U) : _.reduce( (U, $, B) => {
                let I = O.getValue($);
                return $ in U || (L && I instanceof l && (I = i(h(I), I, L)),
                U[$] = I),
                U
            }
            , {})
        }
        const v = class v extends Array {
            constructor(...L) {
                const U = L[0];
                let $ = L[1]
                  , B = (L[2] || []).slice()
                  , I = !0;
                U !== n && ($ = L,
                B = [],
                I = !1);
                super($.length);
                he(this, P);
                $.forEach( (Y, ie) => {
                    this[ie] = Y
                }
                );
                const F = B.reduce( (Y, ie) => (typeof ie == "string" && Y.set(ie, (Y.get(ie) || 0) + 1),
                Y), new Map);
                if (m(this, Object.freeze($.map( (Y, ie) => {
                    const ne = B[ie];
                    return ne != null && F.get(ne) === 1 ? ne : null
                }
                ))),
                Q(this, P, []),
                j(this, P) == null && j(this, P),
                !I)
                    return;
                Object.freeze(this);
                const z = new Proxy(this,{
                    get: (Y, ie, ne) => {
                        if (typeof ie == "string") {
                            if (ie.match(/^[0-9]+$/)) {
                                const W = (0,
                                t.getNumber)(ie, "%index");
                                if (W < 0 || W >= this.length)
                                    throw new RangeError("out of result range");
                                const ee = Y[W];
                                return ee instanceof Error && f(`index ${W}`, ee),
                                ee
                            }
                            if (r.indexOf(ie) >= 0)
                                return Reflect.get(Y, ie, ne);
                            const xe = Y[ie];
                            if (xe instanceof Function)
                                return function(...W) {
                                    return xe.apply(this === ne ? Y : this, W)
                                }
                                ;
                            if (!(ie in Y))
                                return Y.getValue.apply(this === ne ? Y : this, [ie])
                        }
                        return Reflect.get(Y, ie, ne)
                    }
                });
                return m(z, h(this)),
                z
            }
            toArray(L) {
                const U = [];
                return this.forEach( ($, B) => {
                    $ instanceof Error && f(`index ${B}`, $),
                    L && $ instanceof v && ($ = $.toArray(L)),
                    U.push($)
                }
                ),
                U
            }
            toObject(L) {
                const U = h(this);
                return U.reduce( ($, B, I) => ((0,
                t.assert)(B != null, `value at index ${I} unnamed`, "UNSUPPORTED_OPERATION", {
                    operation: "toObject()"
                }),
                i(U, this, L)), {})
            }
            slice(L, U) {
                L == null && (L = 0),
                L < 0 && (L += this.length,
                L < 0 && (L = 0)),
                U == null && (U = this.length),
                U < 0 && (U += this.length,
                U < 0 && (U = 0)),
                U > this.length && (U = this.length);
                const $ = h(this)
                  , B = []
                  , I = [];
                for (let F = L; F < U; F++)
                    B.push(this[F]),
                    I.push($[F]);
                return new v(n,B,I)
            }
            filter(L, U) {
                const $ = h(this)
                  , B = []
                  , I = [];
                for (let F = 0; F < this.length; F++) {
                    const z = this[F];
                    z instanceof Error && f(`index ${F}`, z),
                    L.call(U, z, F, this) && (B.push(z),
                    I.push($[F]))
                }
                return new v(n,B,I)
            }
            map(L, U) {
                const $ = [];
                for (let B = 0; B < this.length; B++) {
                    const I = this[B];
                    I instanceof Error && f(`index ${B}`, I),
                    $.push(L.call(U, I, B, this))
                }
                return $
            }
            getValue(L) {
                const U = h(this).indexOf(L);
                if (U === -1)
                    return;
                const $ = this[U];
                return $ instanceof Error && f(`property ${JSON.stringify(L)}`, $.error),
                $
            }
            static fromItems(L, U) {
                return new v(n,L,U)
            }
        }
        ;
        P = new WeakMap;
        let l = v;
        e.Result = l;
        function p(_) {
            const O = []
              , L = function(U, $) {
                if (Array.isArray($))
                    for (let B in $) {
                        const I = U.slice();
                        I.push(B);
                        try {
                            L(I, $[B])
                        } catch (F) {
                            O.push({
                                path: I,
                                error: F
                            })
                        }
                    }
            };
            return L([], _),
            O
        }
        e.checkResultErrors = p;
        function o(_) {
            let O = (0,
            t.toBeArray)(_);
            return (0,
            t.assert)(O.length <= e.WordSize, "value out-of-bounds", "BUFFER_OVERRUN", {
                buffer: O,
                length: e.WordSize,
                offset: O.length
            }),
            O.length !== e.WordSize && (O = (0,
            t.getBytesCopy)((0,
            t.concat)([s.slice(O.length % e.WordSize), O]))),
            O
        }
        class c {
            constructor(O, L, U, $) {
                ue(this, "name");
                ue(this, "type");
                ue(this, "localName");
                ue(this, "dynamic");
                (0,
                t.defineProperties)(this, {
                    name: O,
                    type: L,
                    localName: U,
                    dynamic: $
                }, {
                    name: "string",
                    type: "string",
                    localName: "string",
                    dynamic: "boolean"
                })
            }
            _throwError(O, L) {
                (0,
                t.assertArgument)(!1, O, this.localName, L)
            }
        }
        e.Coder = c;
        class u {
            constructor() {
                he(this, a);
                he(this, b);
                he(this, x);
                Q(this, b, []),
                Q(this, x, 0)
            }
            get data() {
                return (0,
                t.concat)(j(this, b))
            }
            get length() {
                return j(this, x)
            }
            appendWriter(O) {
                return we(this, a, fs).call(this, (0,
                t.getBytesCopy)(O.data))
            }
            writeBytes(O) {
                let L = (0,
                t.getBytesCopy)(O);
                const U = L.length % e.WordSize;
                return U && (L = (0,
                t.getBytesCopy)((0,
                t.concat)([L, s.slice(U)]))),
                we(this, a, fs).call(this, L)
            }
            writeValue(O) {
                return we(this, a, fs).call(this, o(O))
            }
            writeUpdatableValue() {
                const O = j(this, b).length;
                return j(this, b).push(s),
                Q(this, x, j(this, x) + e.WordSize),
                L => {
                    j(this, b)[O] = o(L)
                }
            }
        }
        b = new WeakMap,
        x = new WeakMap,
        a = new WeakSet,
        fs = function(O) {
            return j(this, b).push(O),
            Q(this, x, j(this, x) + O.length),
            O.length
        }
        ,
        e.Writer = u;
        const k = class k {
            constructor(O, L, U) {
                he(this, A);
                ue(this, "allowLoose");
                he(this, w);
                he(this, S);
                he(this, T);
                he(this, C);
                he(this, N);
                (0,
                t.defineProperties)(this, {
                    allowLoose: !!L
                }),
                Q(this, w, (0,
                t.getBytesCopy)(O)),
                Q(this, T, 0),
                Q(this, C, null),
                Q(this, N, U ?? 1024),
                Q(this, S, 0)
            }
            get data() {
                return (0,
                t.hexlify)(j(this, w))
            }
            get dataLength() {
                return j(this, w).length
            }
            get consumed() {
                return j(this, S)
            }
            get bytes() {
                return new Uint8Array(j(this, w))
            }
            subReader(O) {
                const L = new k(j(this, w).slice(j(this, S) + O),this.allowLoose,j(this, N));
                return Q(L, C, this),
                L
            }
            readBytes(O, L) {
                let U = we(this, A, Du).call(this, 0, O, !!L);
                return we(this, A, xi).call(this, O),
                Q(this, S, j(this, S) + U.length),
                U.slice(0, O)
            }
            readValue() {
                return (0,
                t.toBigInt)(this.readBytes(e.WordSize))
            }
            readIndex() {
                return (0,
                t.toNumber)(this.readBytes(e.WordSize))
            }
        }
        ;
        w = new WeakMap,
        S = new WeakMap,
        T = new WeakMap,
        C = new WeakMap,
        N = new WeakMap,
        A = new WeakSet,
        xi = function(O) {
            var L;
            if (j(this, C))
                return we(L = j(this, C), A, xi).call(L, O);
            Q(this, T, j(this, T) + O),
            (0,
            t.assert)(j(this, N) < 1 || j(this, T) <= j(this, N) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${j(this, N)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
                buffer: (0,
                t.getBytesCopy)(j(this, w)),
                offset: j(this, S),
                length: O,
                info: {
                    bytesRead: j(this, T),
                    dataLength: this.dataLength
                }
            })
        }
        ,
        Du = function(O, L, U) {
            let $ = Math.ceil(L / e.WordSize) * e.WordSize;
            return j(this, S) + $ > j(this, w).length && (this.allowLoose && U && j(this, S) + L <= j(this, w).length ? $ = L : (0,
            t.assert)(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
                buffer: (0,
                t.getBytesCopy)(j(this, w)),
                length: j(this, w).length,
                offset: j(this, S) + $
            })),
            j(this, w).slice(j(this, S), j(this, S) + $)
        }
        ;
        let g = k;
        e.Reader = g
    }(Ws)),
    Ws
}
var Vr = {}, Ys = {}, er = {}, Zs = {}, Jr = {}, vt = {}, Xs = {}, ot = {}, Lo;
function ss() {
    if (Lo)
        return ot;
    Lo = 1,
    Object.defineProperty(ot, "__esModule", {
        value: !0
    }),
    ot.output = ot.exists = ot.hash = ot.bytes = ot.bool = ot.number = void 0;
    function e(m) {
        if (!Number.isSafeInteger(m) || m < 0)
            throw new Error(`Wrong positive integer: ${m}`)
    }
    ot.number = e;
    function t(m) {
        if (typeof m != "boolean")
            throw new Error(`Expected boolean, not ${m}`)
    }
    ot.bool = t;
    function s(m, ...f) {
        if (!(m instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
        if (f.length > 0 && !f.includes(m.length))
            throw new Error(`Expected Uint8Array of length ${f}, not of length=${m.length}`)
    }
    ot.bytes = s;
    function r(m) {
        if (typeof m != "function" || typeof m.create != "function")
            throw new Error("Hash should be wrapped by utils.wrapConstructor");
        e(m.outputLen),
        e(m.blockLen)
    }
    ot.hash = r;
    function n(m, f=!0) {
        if (m.destroyed)
            throw new Error("Hash instance has been destroyed");
        if (f && m.finished)
            throw new Error("Hash#digest() has already been called")
    }
    ot.exists = n;
    function d(m, f) {
        s(m);
        const i = f.outputLen;
        if (m.length < i)
            throw new Error(`digestInto() expects output buffer of length at least ${i}`)
    }
    ot.output = d;
    const h = {
        number: e,
        bool: t,
        bytes: s,
        hash: r,
        exists: n,
        output: d
    };
    return ot.default = h,
    ot
}
var ei = {}, Qr = {}, Uo;
function Bd() {
    return Uo || (Uo = 1,
    Object.defineProperty(Qr, "__esModule", {
        value: !0
    }),
    Qr.crypto = void 0,
    Qr.crypto = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0),
    Qr
}
var Fo;
function It() {
    return Fo || (Fo = 1,
    function(e) {
        /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.randomBytes = e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.checkOpts = e.Hash = e.concatBytes = e.toBytes = e.utf8ToBytes = e.asyncLoop = e.nextTick = e.hexToBytes = e.bytesToHex = e.isLE = e.rotr = e.createView = e.u32 = e.u8 = void 0;
        const t = Bd()
          , s = w => w instanceof Uint8Array
          , r = w => new Uint8Array(w.buffer,w.byteOffset,w.byteLength);
        e.u8 = r;
        const n = w => new Uint32Array(w.buffer,w.byteOffset,Math.floor(w.byteLength / 4));
        e.u32 = n;
        const d = w => new DataView(w.buffer,w.byteOffset,w.byteLength);
        e.createView = d;
        const h = (w, S) => w << 32 - S | w >>> S;
        if (e.rotr = h,
        e.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68,
        !e.isLE)
            throw new Error("Non little-endian hardware is not supported");
        const m = Array.from({
            length: 256
        }, (w, S) => S.toString(16).padStart(2, "0"));
        function f(w) {
            if (!s(w))
                throw new Error("Uint8Array expected");
            let S = "";
            for (let T = 0; T < w.length; T++)
                S += m[w[T]];
            return S
        }
        e.bytesToHex = f;
        function i(w) {
            if (typeof w != "string")
                throw new Error("hex string expected, got " + typeof w);
            const S = w.length;
            if (S % 2)
                throw new Error("padded hex string expected, got unpadded hex of length " + S);
            const T = new Uint8Array(S / 2);
            for (let C = 0; C < T.length; C++) {
                const N = C * 2
                  , A = w.slice(N, N + 2)
                  , R = Number.parseInt(A, 16);
                if (Number.isNaN(R) || R < 0)
                    throw new Error("Invalid byte sequence");
                T[C] = R
            }
            return T
        }
        e.hexToBytes = i;
        const l = async () => {}
        ;
        e.nextTick = l;
        async function p(w, S, T) {
            let C = Date.now();
            for (let N = 0; N < w; N++) {
                T(N);
                const A = Date.now() - C;
                A >= 0 && A < S || (await (0,
                e.nextTick)(),
                C += A)
            }
        }
        e.asyncLoop = p;
        function o(w) {
            if (typeof w != "string")
                throw new Error(`utf8ToBytes expected string, got ${typeof w}`);
            return new Uint8Array(new TextEncoder().encode(w))
        }
        e.utf8ToBytes = o;
        function c(w) {
            if (typeof w == "string" && (w = o(w)),
            !s(w))
                throw new Error(`expected Uint8Array, got ${typeof w}`);
            return w
        }
        e.toBytes = c;
        function u(...w) {
            const S = new Uint8Array(w.reduce( (C, N) => C + N.length, 0));
            let T = 0;
            return w.forEach(C => {
                if (!s(C))
                    throw new Error("Uint8Array expected");
                S.set(C, T),
                T += C.length
            }
            ),
            S
        }
        e.concatBytes = u;
        class g {
            clone() {
                return this._cloneInto()
            }
        }
        e.Hash = g;
        const P = {}.toString;
        function v(w, S) {
            if (S !== void 0 && P.call(S) !== "[object Object]")
                throw new Error("Options should be object or undefined");
            return Object.assign(w, S)
        }
        e.checkOpts = v;
        function b(w) {
            const S = C => w().update(c(C)).digest()
              , T = w();
            return S.outputLen = T.outputLen,
            S.blockLen = T.blockLen,
            S.create = () => w(),
            S
        }
        e.wrapConstructor = b;
        function x(w) {
            const S = (C, N) => w(N).update(c(C)).digest()
              , T = w({});
            return S.outputLen = T.outputLen,
            S.blockLen = T.blockLen,
            S.create = C => w(C),
            S
        }
        e.wrapConstructorWithOpts = x;
        function a(w) {
            const S = (C, N) => w(N).update(c(C)).digest()
              , T = w({});
            return S.outputLen = T.outputLen,
            S.blockLen = T.blockLen,
            S.create = C => w(C),
            S
        }
        e.wrapXOFConstructorWithOpts = a;
        function E(w=32) {
            if (t.crypto && typeof t.crypto.getRandomValues == "function")
                return t.crypto.getRandomValues(new Uint8Array(w));
            throw new Error("crypto.getRandomValues must be defined")
        }
        e.randomBytes = E
    }(ei)),
    ei
}
var Do;
function zi() {
    return Do || (Do = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.hmac = e.HMAC = void 0;
        const t = ss()
          , s = It();
        class r extends s.Hash {
            constructor(h, m) {
                super(),
                this.finished = !1,
                this.destroyed = !1,
                (0,
                t.hash)(h);
                const f = (0,
                s.toBytes)(m);
                if (this.iHash = h.create(),
                typeof this.iHash.update != "function")
                    throw new Error("Expected instance of class which extends utils.Hash");
                this.blockLen = this.iHash.blockLen,
                this.outputLen = this.iHash.outputLen;
                const i = this.blockLen
                  , l = new Uint8Array(i);
                l.set(f.length > i ? h.create().update(f).digest() : f);
                for (let p = 0; p < l.length; p++)
                    l[p] ^= 54;
                this.iHash.update(l),
                this.oHash = h.create();
                for (let p = 0; p < l.length; p++)
                    l[p] ^= 106;
                this.oHash.update(l),
                l.fill(0)
            }
            update(h) {
                return (0,
                t.exists)(this),
                this.iHash.update(h),
                this
            }
            digestInto(h) {
                (0,
                t.exists)(this),
                (0,
                t.bytes)(h, this.outputLen),
                this.finished = !0,
                this.iHash.digestInto(h),
                this.oHash.update(h),
                this.oHash.digestInto(h),
                this.destroy()
            }
            digest() {
                const h = new Uint8Array(this.oHash.outputLen);
                return this.digestInto(h),
                h
            }
            _cloneInto(h) {
                h || (h = Object.create(Object.getPrototypeOf(this), {}));
                const {oHash: m, iHash: f, finished: i, destroyed: l, blockLen: p, outputLen: o} = this;
                return h = h,
                h.finished = i,
                h.destroyed = l,
                h.blockLen = p,
                h.outputLen = o,
                h.oHash = m._cloneInto(h.oHash),
                h.iHash = f._cloneInto(h.iHash),
                h
            }
            destroy() {
                this.destroyed = !0,
                this.oHash.destroy(),
                this.iHash.destroy()
            }
        }
        e.HMAC = r;
        const n = (d, h, m) => new r(d,h).update(m).digest();
        e.hmac = n,
        e.hmac.create = (d, h) => new r(d,h)
    }(Xs)),
    Xs
}
var tr = {}, Ho;
function Hu() {
    if (Ho)
        return tr;
    Ho = 1,
    Object.defineProperty(tr, "__esModule", {
        value: !0
    }),
    tr.pbkdf2Async = tr.pbkdf2 = void 0;
    const e = ss()
      , t = zi()
      , s = It();
    function r(m, f, i, l) {
        (0,
        e.hash)(m);
        const p = (0,
        s.checkOpts)({
            dkLen: 32,
            asyncTick: 10
        }, l)
          , {c: o, dkLen: c, asyncTick: u} = p;
        if ((0,
        e.number)(o),
        (0,
        e.number)(c),
        (0,
        e.number)(u),
        o < 1)
            throw new Error("PBKDF2: iterations (c) should be >= 1");
        const g = (0,
        s.toBytes)(f)
          , P = (0,
        s.toBytes)(i)
          , v = new Uint8Array(c)
          , b = t.hmac.create(m, g)
          , x = b._cloneInto().update(P);
        return {
            c: o,
            dkLen: c,
            asyncTick: u,
            DK: v,
            PRF: b,
            PRFSalt: x
        }
    }
    function n(m, f, i, l, p) {
        return m.destroy(),
        f.destroy(),
        l && l.destroy(),
        p.fill(0),
        i
    }
    function d(m, f, i, l) {
        const {c: p, dkLen: o, DK: c, PRF: u, PRFSalt: g} = r(m, f, i, l);
        let P;
        const v = new Uint8Array(4)
          , b = (0,
        s.createView)(v)
          , x = new Uint8Array(u.outputLen);
        for (let a = 1, E = 0; E < o; a++,
        E += u.outputLen) {
            const w = c.subarray(E, E + u.outputLen);
            b.setInt32(0, a, !1),
            (P = g._cloneInto(P)).update(v).digestInto(x),
            w.set(x.subarray(0, w.length));
            for (let S = 1; S < p; S++) {
                u._cloneInto(P).update(x).digestInto(x);
                for (let T = 0; T < w.length; T++)
                    w[T] ^= x[T]
            }
        }
        return n(u, g, c, P, x)
    }
    tr.pbkdf2 = d;
    async function h(m, f, i, l) {
        const {c: p, dkLen: o, asyncTick: c, DK: u, PRF: g, PRFSalt: P} = r(m, f, i, l);
        let v;
        const b = new Uint8Array(4)
          , x = (0,
        s.createView)(b)
          , a = new Uint8Array(g.outputLen);
        for (let E = 1, w = 0; w < o; E++,
        w += g.outputLen) {
            const S = u.subarray(w, w + g.outputLen);
            x.setInt32(0, E, !1),
            (v = P._cloneInto(v)).update(b).digestInto(a),
            S.set(a.subarray(0, S.length)),
            await (0,
            s.asyncLoop)(p - 1, c, () => {
                g._cloneInto(v).update(a).digestInto(a);
                for (let T = 0; T < S.length; T++)
                    S[T] ^= a[T]
            }
            )
        }
        return n(g, P, u, v, a)
    }
return tr.pbkdf2Async = h,
    tr
}
var rr = {}, Wr = {}, Go;
function Ki() {
    if (Go)
        return Wr;
    Go = 1,
    Object.defineProperty(Wr, "__esModule", {
        value: !0
    }),
    Wr.SHA2 = void 0;
    const e = ss()
      , t = It();
    function s(n, d, h, m) {
        if (typeof n.setBigUint64 == "function")
            return n.setBigUint64(d, h, m);
        const f = BigInt(32)
          , i = BigInt(4294967295)
          , l = Number(h >> f & i)
          , p = Number(h & i)
          , o = m ? 4 : 0
          , c = m ? 0 : 4;
        n.setUint32(d + o, l, m),
        n.setUint32(d + c, p, m)
    }
    class r extends t.Hash {
        constructor(d, h, m, f) {
            super(),
            this.blockLen = d,
            this.outputLen = h,
            this.padOffset = m,
            this.isLE = f,
            this.finished = !1,
            this.length = 0,
            this.pos = 0,
            this.destroyed = !1,
            this.buffer = new Uint8Array(d),
            this.view = (0,
            t.createView)(this.buffer)
        }
        update(d) {
            (0,
            e.exists)(this);
            const {view: h, buffer: m, blockLen: f} = this;
            d = (0,
            t.toBytes)(d);
            const i = d.length;
            for (let l = 0; l < i; ) {
                const p = Math.min(f - this.pos, i - l);
                if (p === f) {
                    const o = (0,
                    t.createView)(d);
                    for (; f <= i - l; l += f)
                        this.process(o, l);
                    continue
                }
                m.set(d.subarray(l, l + p), this.pos),
                this.pos += p,
                l += p,
                this.pos === f && (this.process(h, 0),
                this.pos = 0)
            }
            return this.length += d.length,
            this.roundClean(),
            this
        }
        digestInto(d) {
            (0,
            e.exists)(this),
            (0,
            e.output)(d, this),
            this.finished = !0;
            const {buffer: h, view: m, blockLen: f, isLE: i} = this;
            let {pos: l} = this;
            h[l++] = 128,
            this.buffer.subarray(l).fill(0),
            this.padOffset > f - l && (this.process(m, 0),
            l = 0);
            for (let g = l; g < f; g++)
                h[g] = 0;
            s(m, f - 8, BigInt(this.length * 8), i),
            this.process(m, 0);
            const p = (0,
            t.createView)(d)
              , o = this.outputLen;
            if (o % 4)
                throw new Error("_sha2: outputLen should be aligned to 32bit");
            const c = o / 4
              , u = this.get();
            if (c > u.length)
                throw new Error("_sha2: outputLen bigger than state");
            for (let g = 0; g < c; g++)
                p.setUint32(4 * g, u[g], i)
        }
        digest() {
            const {buffer: d, outputLen: h} = this;
            this.digestInto(d);
            const m = d.slice(0, h);
            return this.destroy(),
            m
        }
        _cloneInto(d) {
            d || (d = new this.constructor),
            d.set(...this.get());
            const {blockLen: h, buffer: m, length: f, finished: i, destroyed: l, pos: p} = this;
            return d.length = f,
            d.pos = p,
            d.finished = i,
            d.destroyed = l,
            f % h && d.buffer.set(m),
            d
        }
    }
    return Wr.SHA2 = r,
    Wr
}
var $o;
function Vi() {
    if ($o)
        return rr;
    $o = 1,
    Object.defineProperty(rr, "__esModule", {
        value: !0
    }),
    rr.sha224 = rr.sha256 = void 0;
    const e = Ki()
      , t = It()
      , s = (i, l, p) => i & l ^ ~i & p
      , r = (i, l, p) => i & l ^ i & p ^ l & p
      , n = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
      , d = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
      , h = new Uint32Array(64);
    class m extends e.SHA2 {
        constructor() {
            super(64, 32, 8, !1),
            this.A = d[0] | 0,
            this.B = d[1] | 0,
            this.C = d[2] | 0,
            this.D = d[3] | 0,
            this.E = d[4] | 0,
            this.F = d[5] | 0,
            this.G = d[6] | 0,
            this.H = d[7] | 0
        }
        get() {
            const {A: l, B: p, C: o, D: c, E: u, F: g, G: P, H: v} = this;
            return [l, p, o, c, u, g, P, v]
        }
        set(l, p, o, c, u, g, P, v) {
            this.A = l | 0,
            this.B = p | 0,
            this.C = o | 0,
            this.D = c | 0,
            this.E = u | 0,
            this.F = g | 0,
            this.G = P | 0,
            this.H = v | 0
        }
        process(l, p) {
            for (let a = 0; a < 16; a++,
            p += 4)
                h[a] = l.getUint32(p, !1);
            for (let a = 16; a < 64; a++) {
                const E = h[a - 15]
                  , w = h[a - 2]
                  , S = (0,
                t.rotr)(E, 7) ^ (0,
                t.rotr)(E, 18) ^ E >>> 3
                  , T = (0,
                t.rotr)(w, 17) ^ (0,
                t.rotr)(w, 19) ^ w >>> 10;
                h[a] = T + h[a - 7] + S + h[a - 16] | 0
            }
            let {A: o, B: c, C: u, D: g, E: P, F: v, G: b, H: x} = this;
            for (let a = 0; a < 64; a++) {
                const E = (0,
                t.rotr)(P, 6) ^ (0,
                t.rotr)(P, 11) ^ (0,
                t.rotr)(P, 25)
                  , w = x + E + s(P, v, b) + n[a] + h[a] | 0
                  , T = ((0,
                t.rotr)(o, 2) ^ (0,
                t.rotr)(o, 13) ^ (0,
                t.rotr)(o, 22)) + r(o, c, u) | 0;
                x = b,
                b = v,
                v = P,
                P = g + w | 0,
                g = u,
                u = c,
                c = o,
                o = w + T | 0
            }
            o = o + this.A | 0,
            c = c + this.B | 0,
            u = u + this.C | 0,
            g = g + this.D | 0,
            P = P + this.E | 0,
            v = v + this.F | 0,
            b = b + this.G | 0,
            x = x + this.H | 0,
            this.set(o, c, u, g, P, v, b, x)
        }
        roundClean() {
            h.fill(0)
        }
        destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0),
            this.buffer.fill(0)
        }
    }
    class f extends m {
        constructor() {
            super(),
            this.A = -1056596264,
            this.B = 914150663,
            this.C = 812702999,
            this.D = -150054599,
            this.E = -4191439,
            this.F = 1750603025,
            this.G = 1694076839,
            this.H = -1090891868,
            this.outputLen = 28
        }
    }
    return rr.sha256 = (0,
    t.wrapConstructor)( () => new m),
    rr.sha224 = (0,
    t.wrapConstructor)( () => new f),
    rr
}
var ft = {}, Re = {}, qo;
function Gu() {
    if (qo)
        return Re;
    qo = 1,
    Object.defineProperty(Re, "__esModule", {
        value: !0
    }),
    Re.add5L = Re.add5H = Re.add4H = Re.add4L = Re.add3H = Re.add3L = Re.add = Re.rotlBL = Re.rotlBH = Re.rotlSL = Re.rotlSH = Re.rotr32L = Re.rotr32H = Re.rotrBL = Re.rotrBH = Re.rotrSL = Re.rotrSH = Re.shrSL = Re.shrSH = Re.toBig = Re.split = Re.fromBig = void 0;
    const e = BigInt(2 ** 32 - 1)
      , t = BigInt(32);
    function s(C, N=!1) {
        return N ? {
            h: Number(C & e),
            l: Number(C >> t & e)
        } : {
            h: Number(C >> t & e) | 0,
            l: Number(C & e) | 0
        }
    }
    Re.fromBig = s;
    function r(C, N=!1) {
        let A = new Uint32Array(C.length)
          , R = new Uint32Array(C.length);
        for (let y = 0; y < C.length; y++) {
            const {h: k, l: _} = s(C[y], N);
            [A[y],R[y]] = [k, _]
        }
        return [A, R]
    }
    Re.split = r;
    const n = (C, N) => BigInt(C >>> 0) << t | BigInt(N >>> 0);
    Re.toBig = n;
    const d = (C, N, A) => C >>> A;
    Re.shrSH = d;
    const h = (C, N, A) => C << 32 - A | N >>> A;
    Re.shrSL = h;
    const m = (C, N, A) => C >>> A | N << 32 - A;
    Re.rotrSH = m;
    const f = (C, N, A) => C << 32 - A | N >>> A;
    Re.rotrSL = f;
    const i = (C, N, A) => C << 64 - A | N >>> A - 32;
    Re.rotrBH = i;
    const l = (C, N, A) => C >>> A - 32 | N << 64 - A;
    Re.rotrBL = l;
    const p = (C, N) => N;
    Re.rotr32H = p;
    const o = (C, N) => C;
    Re.rotr32L = o;
    const c = (C, N, A) => C << A | N >>> 32 - A;
    Re.rotlSH = c;
    const u = (C, N, A) => N << A | C >>> 32 - A;
    Re.rotlSL = u;
    const g = (C, N, A) => N << A - 32 | C >>> 64 - A;
    Re.rotlBH = g;
    const P = (C, N, A) => C << A - 32 | N >>> 64 - A;
    Re.rotlBL = P;
    function v(C, N, A, R) {
        const y = (N >>> 0) + (R >>> 0);
        return {
            h: C + A + (y / 2 ** 32 | 0) | 0,
            l: y | 0
        }
    }
    Re.add = v;
    const b = (C, N, A) => (C >>> 0) + (N >>> 0) + (A >>> 0);
    Re.add3L = b;
    const x = (C, N, A, R) => N + A + R + (C / 2 ** 32 | 0) | 0;
    Re.add3H = x;
    const a = (C, N, A, R) => (C >>> 0) + (N >>> 0) + (A >>> 0) + (R >>> 0);
    Re.add4L = a;
    const E = (C, N, A, R, y) => N + A + R + y + (C / 2 ** 32 | 0) | 0;
    Re.add4H = E;
    const w = (C, N, A, R, y) => (C >>> 0) + (N >>> 0) + (A >>> 0) + (R >>> 0) + (y >>> 0);
    Re.add5L = w;
    const S = (C, N, A, R, y, k) => N + A + R + y + k + (C / 2 ** 32 | 0) | 0;
    Re.add5H = S;
    const T = {
        fromBig: s,
        split: r,
        toBig: n,
        shrSH: d,
        shrSL: h,
        rotrSH: m,
        rotrSL: f,
        rotrBH: i,
        rotrBL: l,
        rotr32H: p,
        rotr32L: o,
        rotlSH: c,
        rotlSL: u,
        rotlBH: g,
        rotlBL: P,
        add: v,
        add3L: b,
        add3H: x,
        add4L: a,
        add4H: E,
        add5H: S,
        add5L: w
    };
    return Re.default = T,
    Re
}
var zo;
function Sd() {
    if (zo)
        return ft;
    zo = 1,
    Object.defineProperty(ft, "__esModule", {
        value: !0
    }),
    ft.sha384 = ft.sha512_256 = ft.sha512_224 = ft.sha512 = ft.SHA512 = void 0;
    const e = Ki()
      , t = Gu()
      , s = It()
      , [r,n] = t.default.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(p => BigInt(p)))
      , d = new Uint32Array(80)
      , h = new Uint32Array(80);
    class m extends e.SHA2 {
        constructor() {
            super(128, 64, 16, !1),
            this.Ah = 1779033703,
            this.Al = -205731576,
            this.Bh = -1150833019,
            this.Bl = -2067093701,
            this.Ch = 1013904242,
            this.Cl = -23791573,
            this.Dh = -1521486534,
            this.Dl = 1595750129,
            this.Eh = 1359893119,
            this.El = -1377402159,
            this.Fh = -1694144372,
            this.Fl = 725511199,
            this.Gh = 528734635,
            this.Gl = -79577749,
            this.Hh = 1541459225,
            this.Hl = 327033209
        }
        get() {
            const {Ah: o, Al: c, Bh: u, Bl: g, Ch: P, Cl: v, Dh: b, Dl: x, Eh: a, El: E, Fh: w, Fl: S, Gh: T, Gl: C, Hh: N, Hl: A} = this;
            return [o, c, u, g, P, v, b, x, a, E, w, S, T, C, N, A]
        }
        set(o, c, u, g, P, v, b, x, a, E, w, S, T, C, N, A) {
            this.Ah = o | 0,
            this.Al = c | 0,
            this.Bh = u | 0,
            this.Bl = g | 0,
            this.Ch = P | 0,
            this.Cl = v | 0,
            this.Dh = b | 0,
            this.Dl = x | 0,
            this.Eh = a | 0,
            this.El = E | 0,
            this.Fh = w | 0,
            this.Fl = S | 0,
            this.Gh = T | 0,
            this.Gl = C | 0,
            this.Hh = N | 0,
            this.Hl = A | 0
        }
        process(o, c) {
            for (let k = 0; k < 16; k++,
            c += 4)
                d[k] = o.getUint32(c),
                h[k] = o.getUint32(c += 4);
            for (let k = 16; k < 80; k++) {
                const _ = d[k - 15] | 0
                  , O = h[k - 15] | 0
                  , L = t.default.rotrSH(_, O, 1) ^ t.default.rotrSH(_, O, 8) ^ t.default.shrSH(_, O, 7)
                  , U = t.default.rotrSL(_, O, 1) ^ t.default.rotrSL(_, O, 8) ^ t.default.shrSL(_, O, 7)
                  , $ = d[k - 2] | 0
                  , B = h[k - 2] | 0
                  , I = t.default.rotrSH($, B, 19) ^ t.default.rotrBH($, B, 61) ^ t.default.shrSH($, B, 6)
                  , F = t.default.rotrSL($, B, 19) ^ t.default.rotrBL($, B, 61) ^ t.default.shrSL($, B, 6)
                  , z = t.default.add4L(U, F, h[k - 7], h[k - 16])
                  , Y = t.default.add4H(z, L, I, d[k - 7], d[k - 16]);
                d[k] = Y | 0,
                h[k] = z | 0
            }
            let {Ah: u, Al: g, Bh: P, Bl: v, Ch: b, Cl: x, Dh: a, Dl: E, Eh: w, El: S, Fh: T, Fl: C, Gh: N, Gl: A, Hh: R, Hl: y} = this;
            for (let k = 0; k < 80; k++) {
                const _ = t.default.rotrSH(w, S, 14) ^ t.default.rotrSH(w, S, 18) ^ t.default.rotrBH(w, S, 41)
                  , O = t.default.rotrSL(w, S, 14) ^ t.default.rotrSL(w, S, 18) ^ t.default.rotrBL(w, S, 41)
                  , L = w & T ^ ~w & N
                  , U = S & C ^ ~S & A
                  , $ = t.default.add5L(y, O, U, n[k], h[k])
                  , B = t.default.add5H($, R, _, L, r[k], d[k])
                  , I = $ | 0
                  , F = t.default.rotrSH(u, g, 28) ^ t.default.rotrBH(u, g, 34) ^ t.default.rotrBH(u, g, 39)
                  , z = t.default.rotrSL(u, g, 28) ^ t.default.rotrBL(u, g, 34) ^ t.default.rotrBL(u, g, 39)
                  , Y = u & P ^ u & b ^ P & b
                  , ie = g & v ^ g & x ^ v & x;
                R = N | 0,
                y = A | 0,
                N = T | 0,
                A = C | 0,
                T = w | 0,
                C = S | 0,
                {h: w, l: S} = t.default.add(a | 0, E | 0, B | 0, I | 0),
                a = b | 0,
                E = x | 0,
                b = P | 0,
                x = v | 0,
                P = u | 0,
                v = g | 0;
                const ne = t.default.add3L(I, z, ie);
                u = t.default.add3H(ne, B, F, Y),
                g = ne | 0
            }
            ({h: u, l: g} = t.default.add(this.Ah | 0, this.Al | 0, u | 0, g | 0)),
            {h: P, l: v} = t.default.add(this.Bh | 0, this.Bl | 0, P | 0, v | 0),
            {h: b, l: x} = t.default.add(this.Ch | 0, this.Cl | 0, b | 0, x | 0),
            {h: a, l: E} = t.default.add(this.Dh | 0, this.Dl | 0, a | 0, E | 0),
            {h: w, l: S} = t.default.add(this.Eh | 0, this.El | 0, w | 0, S | 0),
            {h: T, l: C} = t.default.add(this.Fh | 0, this.Fl | 0, T | 0, C | 0),
            {h: N, l: A} = t.default.add(this.Gh | 0, this.Gl | 0, N | 0, A | 0),
            {h: R, l: y} = t.default.add(this.Hh | 0, this.Hl | 0, R | 0, y | 0),
            this.set(u, g, P, v, b, x, a, E, w, S, T, C, N, A, R, y)
        }
        roundClean() {
            d.fill(0),
            h.fill(0)
        }
        destroy() {
            this.buffer.fill(0),
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
        }
    }
    ft.SHA512 = m;
    class f extends m {
        constructor() {
            super(),
            this.Ah = -1942145080,
            this.Al = 424955298,
            this.Bh = 1944164710,
            this.Bl = -1982016298,
            this.Ch = 502970286,
            this.Cl = 855612546,
            this.Dh = 1738396948,
            this.Dl = 1479516111,
            this.Eh = 258812777,
            this.El = 2077511080,
            this.Fh = 2011393907,
            this.Fl = 79989058,
            this.Gh = 1067287976,
            this.Gl = 1780299464,
            this.Hh = 286451373,
            this.Hl = -1848208735,
            this.outputLen = 28
        }
    }
    class i extends m {
        constructor() {
            super(),
            this.Ah = 573645204,
            this.Al = -64227540,
            this.Bh = -1621794909,
            this.Bl = -934517566,
            this.Ch = 596883563,
            this.Cl = 1867755857,
            this.Dh = -1774684391,
            this.Dl = 1497426621,
            this.Eh = -1775747358,
            this.El = -1467023389,
            this.Fh = -1101128155,
            this.Fl = 1401305490,
            this.Gh = 721525244,
            this.Gl = 746961066,
            this.Hh = 246885852,
            this.Hl = -2117784414,
            this.outputLen = 32
        }
    }
    class l extends m {
        constructor() {
            super(),
            this.Ah = -876896931,
            this.Al = -1056596264,
            this.Bh = 1654270250,
            this.Bl = 914150663,
            this.Ch = -1856437926,
            this.Cl = 812702999,
            this.Dh = 355462360,
            this.Dl = -150054599,
            this.Eh = 1731405415,
            this.El = -4191439,
            this.Fh = -1900787065,
            this.Fl = 1750603025,
            this.Gh = -619958771,
            this.Gl = 1694076839,
            this.Hh = 1203062813,
            this.Hl = -1090891868,
            this.outputLen = 48
        }
    }
    return ft.sha512 = (0,
    s.wrapConstructor)( () => new m),
    ft.sha512_224 = (0,
    s.wrapConstructor)( () => new f),
    ft.sha512_256 = (0,
    s.wrapConstructor)( () => new i),
    ft.sha384 = (0,
    s.wrapConstructor)( () => new l),
    ft
}
var Ko;
function Bs() {
    if (Ko)
        return vt;
    Ko = 1,
    Object.defineProperty(vt, "__esModule", {
        value: !0
    }),
    vt.randomBytes = vt.pbkdf2Sync = vt.createHmac = vt.createHash = void 0;
    const e = zi()
      , t = Hu()
      , s = Vi()
      , r = Sd()
      , n = Be();
    function d() {
        if (typeof self < "u")
            return self;
        if (typeof window < "u")
            return window;
        if (typeof He < "u")
            return He;
        throw new Error("unable to locate global object")
    }
    const h = d()
      , m = h.crypto || h.msCrypto;
    function f(o) {
        switch (o) {
        case "sha256":
            return s.sha256.create();
        case "sha512":
            return r.sha512.create()
        }
        (0,
        n.assertArgument)(!1, "invalid hashing algorithm name", "algorithm", o)
    }
    vt.createHash = f;
    function i(o, c) {
        const u = {
            sha256: s.sha256,
            sha512: r.sha512
        }[o];
        return (0,
        n.assertArgument)(u != null, "invalid hmac algorithm", "algorithm", o),
        e.hmac.create(u, c)
    }
    vt.createHmac = i;
    function l(o, c, u, g, P) {
        const v = {
            sha256: s.sha256,
            sha512: r.sha512
        }[P];
        return (0,
        n.assertArgument)(v != null, "invalid pbkdf2 algorithm", "algorithm", P),
        (0,
        t.pbkdf2)(v, o, c, {
            c: u,
            dkLen: g
        })
    }
    vt.pbkdf2Sync = l;
    function p(o) {
        (0,
        n.assert)(m != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
            operation: "randomBytes"
        }),
        (0,
        n.assertArgument)(Number.isInteger(o) && o > 0 && o <= 1024, "invalid length", "length", o);
        const c = new Uint8Array(o);
        return m.getRandomValues(c),
        c
    }
    return vt.randomBytes = p,
    vt
}
var Vo;
function Cd() {
    if (Vo)
        return Jr;
    Vo = 1,
    Object.defineProperty(Jr, "__esModule", {
        value: !0
    }),
    Jr.computeHmac = void 0;
    const e = Bs()
      , t = Be();
    let s = !1;
    const r = function(h, m, f) {
        return (0,
        e.createHmac)(h, m).update(f).digest()
    };
    let n = r;
    function d(h, m, f) {
        const i = (0,
        t.getBytes)(m, "key")
          , l = (0,
        t.getBytes)(f, "data");
        return (0,
        t.hexlify)(n(h, i, l))
    }
    return Jr.computeHmac = d,
    d._ = r,
    d.lock = function() {
        s = !0
    }
    ,
    d.register = function(h) {
        if (s)
            throw new Error("computeHmac is locked");
        n = h
    }
    ,
    Object.freeze(d),
    Jr
}
var Yr = {}, Ke = {}, Jo;
function Nd() {
    if (Jo)
        return Ke;
    Jo = 1,
    Object.defineProperty(Ke, "__esModule", {
        value: !0
    }),
    Ke.shake256 = Ke.shake128 = Ke.keccak_512 = Ke.keccak_384 = Ke.keccak_256 = Ke.keccak_224 = Ke.sha3_512 = Ke.sha3_384 = Ke.sha3_256 = Ke.sha3_224 = Ke.Keccak = Ke.keccakP = void 0;
    const e = ss()
      , t = Gu()
      , s = It()
      , [r,n,d] = [[], [], []]
      , h = BigInt(0)
      , m = BigInt(1)
      , f = BigInt(2)
      , i = BigInt(7)
      , l = BigInt(256)
      , p = BigInt(113);
    for (let a = 0, E = m, w = 1, S = 0; a < 24; a++) {
        [w,S] = [S, (2 * w + 3 * S) % 5],
        r.push(2 * (5 * S + w)),
        n.push((a + 1) * (a + 2) / 2 % 64);
        let T = h;
        for (let C = 0; C < 7; C++)
            E = (E << m ^ (E >> i) * p) % l,
            E & f && (T ^= m << (m << BigInt(C)) - m);
        d.push(T)
    }
    const [o,c] = (0,
    t.split)(d, !0)
      , u = (a, E, w) => w > 32 ? (0,
    t.rotlBH)(a, E, w) : (0,
    t.rotlSH)(a, E, w)
      , g = (a, E, w) => w > 32 ? (0,
    t.rotlBL)(a, E, w) : (0,
    t.rotlSL)(a, E, w);
    function P(a, E=24) {
        const w = new Uint32Array(10);
        for (let S = 24 - E; S < 24; S++) {
            for (let N = 0; N < 10; N++)
                w[N] = a[N] ^ a[N + 10] ^ a[N + 20] ^ a[N + 30] ^ a[N + 40];
            for (let N = 0; N < 10; N += 2) {
                const A = (N + 8) % 10
                  , R = (N + 2) % 10
                  , y = w[R]
                  , k = w[R + 1]
                  , _ = u(y, k, 1) ^ w[A]
                  , O = g(y, k, 1) ^ w[A + 1];
                for (let L = 0; L < 50; L += 10)
                    a[N + L] ^= _,
                    a[N + L + 1] ^= O
            }
            let T = a[2]
              , C = a[3];
            for (let N = 0; N < 24; N++) {
                const A = n[N]
                  , R = u(T, C, A)
                  , y = g(T, C, A)
                  , k = r[N];
                T = a[k],
                C = a[k + 1],
                a[k] = R,
                a[k + 1] = y
            }
            for (let N = 0; N < 50; N += 10) {
                for (let A = 0; A < 10; A++)
                    w[A] = a[N + A];
                for (let A = 0; A < 10; A++)
                    a[N + A] ^= ~w[(A + 2) % 10] & w[(A + 4) % 10]
            }
            a[0] ^= o[S],
            a[1] ^= c[S]
        }
        w.fill(0)
    }
    Ke.keccakP = P;
    class v extends s.Hash {
        constructor(E, w, S, T=!1, C=24) {
            if (super(),
            this.blockLen = E,
            this.suffix = w,
            this.outputLen = S,
            this.enableXOF = T,
            this.rounds = C,
            this.pos = 0,
            this.posOut = 0,
            this.finished = !1,
            this.destroyed = !1,
            (0,
            e.number)(S),
            0 >= this.blockLen || this.blockLen >= 200)
                throw new Error("Sha3 supports only keccak-f1600 function");
            this.state = new Uint8Array(200),
            this.state32 = (0,
            s.u32)(this.state)
        }
        keccak() {
            P(this.state32, this.rounds),
            this.posOut = 0,
            this.pos = 0
        }
        update(E) {
            (0,
            e.exists)(this);
            const {blockLen: w, state: S} = this;
            E = (0,
            s.toBytes)(E);
            const T = E.length;
            for (let C = 0; C < T; ) {
                const N = Math.min(w - this.pos, T - C);
                for (let A = 0; A < N; A++)
                    S[this.pos++] ^= E[C++];
                this.pos === w && this.keccak()
            }
            return this
        }
        finish() {
            if (this.finished)
                return;
            this.finished = !0;
            const {state: E, suffix: w, pos: S, blockLen: T} = this;
            E[S] ^= w,
            w & 128 && S === T - 1 && this.keccak(),
            E[T - 1] ^= 128,
            this.keccak()
        }
        writeInto(E) {
            (0,
            e.exists)(this, !1),
            (0,
            e.bytes)(E),
            this.finish();
            const w = this.state
              , {blockLen: S} = this;
            for (let T = 0, C = E.length; T < C; ) {
                this.posOut >= S && this.keccak();
                const N = Math.min(S - this.posOut, C - T);
                E.set(w.subarray(this.posOut, this.posOut + N), T),
                this.posOut += N,
                T += N
            }
            return E
        }
        xofInto(E) {
            if (!this.enableXOF)
                throw new Error("XOF is not possible for this instance");
            return this.writeInto(E)
        }
        xof(E) {
            return (0,
            e.number)(E),
            this.xofInto(new Uint8Array(E))
        }
        digestInto(E) {
            if ((0,
            e.output)(E, this),
            this.finished)
                throw new Error("digest() was already called");
            return this.writeInto(E),
            this.destroy(),
            E
        }
        digest() {
            return this.digestInto(new Uint8Array(this.outputLen))
        }
        destroy() {
            this.destroyed = !0,
            this.state.fill(0)
        }
        _cloneInto(E) {
            const {blockLen: w, suffix: S, outputLen: T, rounds: C, enableXOF: N} = this;
            return E || (E = new v(w,S,T,N,C)),
            E.state32.set(this.state32),
            E.pos = this.pos,
            E.posOut = this.posOut,
            E.finished = this.finished,
            E.rounds = C,
            E.suffix = S,
            E.outputLen = T,
            E.enableXOF = N,
            E.destroyed = this.destroyed,
            E
        }
    }
    Ke.Keccak = v;
    const b = (a, E, w) => (0,
    s.wrapConstructor)( () => new v(E,a,w));
    Ke.sha3_224 = b(6, 144, 224 / 8),
    Ke.sha3_256 = b(6, 136, 256 / 8),
    Ke.sha3_384 = b(6, 104, 384 / 8),
    Ke.sha3_512 = b(6, 72, 512 / 8),
    Ke.keccak_224 = b(1, 144, 224 / 8),
    Ke.keccak_256 = b(1, 136, 256 / 8),
    Ke.keccak_384 = b(1, 104, 384 / 8),
    Ke.keccak_512 = b(1, 72, 512 / 8);
    const x = (a, E, w) => (0,
    s.wrapXOFConstructorWithOpts)( (S={}) => new v(E,a,S.dkLen === void 0 ? w : S.dkLen,!0));
    return Ke.shake128 = x(31, 168, 128 / 8),
    Ke.shake256 = x(31, 136, 256 / 8),
    Ke
}
var Qo;
function Rd() {
    if (Qo)
        return Yr;
    Qo = 1,
    Object.defineProperty(Yr, "__esModule", {
        value: !0
    }),
    Yr.keccak256 = void 0;
    const e = Nd()
      , t = Be();
    let s = !1;
    const r = function(h) {
        return (0,
        e.keccak_256)(h)
    };
    let n = r;
    function d(h) {
        const m = (0,
        t.getBytes)(h, "data");
        return (0,
        t.hexlify)(n(m))
    }
    return Yr.keccak256 = d,
    d._ = r,
    d.lock = function() {
        s = !0
    }
    ,
    d.register = function(h) {
        if (s)
            throw new TypeError("keccak256 is locked");
        n = h
    }
    ,
    Object.freeze(d),
    Yr
}
var Zr = {}, nr = {}, Wo;
function Id() {
    if (Wo)
        return nr;
    Wo = 1,
    Object.defineProperty(nr, "__esModule", {
        value: !0
    }),
    nr.ripemd160 = nr.RIPEMD160 = void 0;
    const e = Ki()
      , t = It()
      , s = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8])
      , r = Uint8Array.from({
        length: 16
    }, (P, v) => v)
      , n = r.map(P => (9 * P + 5) % 16);
    let d = [r]
      , h = [n];
    for (let P = 0; P < 4; P++)
        for (let v of [d, h])
            v.push(v[P].map(b => s[b]));
    const m = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(P => new Uint8Array(P))
      , f = d.map( (P, v) => P.map(b => m[v][b]))
      , i = h.map( (P, v) => P.map(b => m[v][b]))
      , l = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838])
      , p = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0])
      , o = (P, v) => P << v | P >>> 32 - v;
    function c(P, v, b, x) {
        return P === 0 ? v ^ b ^ x : P === 1 ? v & b | ~v & x : P === 2 ? (v | ~b) ^ x : P === 3 ? v & x | b & ~x : v ^ (b | ~x)
    }
    const u = new Uint32Array(16);
    class g extends e.SHA2 {
        constructor() {
            super(64, 20, 8, !0),
            this.h0 = 1732584193,
            this.h1 = -271733879,
            this.h2 = -1732584194,
            this.h3 = 271733878,
            this.h4 = -1009589776
        }
        get() {
            const {h0: v, h1: b, h2: x, h3: a, h4: E} = this;
            return [v, b, x, a, E]
        }
        set(v, b, x, a, E) {
            this.h0 = v | 0,
            this.h1 = b | 0,
            this.h2 = x | 0,
            this.h3 = a | 0,
            this.h4 = E | 0
        }
        process(v, b) {
            for (let y = 0; y < 16; y++,
            b += 4)
                u[y] = v.getUint32(b, !0);
            let x = this.h0 | 0
              , a = x
              , E = this.h1 | 0
              , w = E
              , S = this.h2 | 0
              , T = S
              , C = this.h3 | 0
              , N = C
              , A = this.h4 | 0
              , R = A;
            for (let y = 0; y < 5; y++) {
                const k = 4 - y
                  , _ = l[y]
                  , O = p[y]
                  , L = d[y]
                  , U = h[y]
                  , $ = f[y]
                  , B = i[y];
                for (let I = 0; I < 16; I++) {
                    const F = o(x + c(y, E, S, C) + u[L[I]] + _, $[I]) + A | 0;
                    x = A,
                    A = C,
                    C = o(S, 10) | 0,
                    S = E,
                    E = F
                }
                for (let I = 0; I < 16; I++) {
                    const F = o(a + c(k, w, T, N) + u[U[I]] + O, B[I]) + R | 0;
                    a = R,
                    R = N,
                    N = o(T, 10) | 0,
                    T = w,
                    w = F
                }
            }
            this.set(this.h1 + S + N | 0, this.h2 + C + R | 0, this.h3 + A + a | 0, this.h4 + x + w | 0, this.h0 + E + T | 0)
        }
        roundClean() {
            u.fill(0)
        }
        destroy() {
            this.destroyed = !0,
            this.buffer.fill(0),
            this.set(0, 0, 0, 0, 0)
        }
    }
    return nr.RIPEMD160 = g,
    nr.ripemd160 = (0,
    t.wrapConstructor)( () => new g),
    nr
}
var Yo;
function jd() {
    if (Yo)
        return Zr;
    Yo = 1,
    Object.defineProperty(Zr, "__esModule", {
        value: !0
    }),
    Zr.ripemd160 = void 0;
    const e = Id()
      , t = Be();
    let s = !1;
    const r = function(h) {
        return (0,
        e.ripemd160)(h)
    };
    let n = r;
    function d(h) {
        const m = (0,
        t.getBytes)(h, "data");
        return (0,
        t.hexlify)(n(m))
    }
    return Zr.ripemd160 = d,
    d._ = r,
    d.lock = function() {
        s = !0
    }
    ,
    d.register = function(h) {
        if (s)
            throw new TypeError("ripemd160 is locked");
        n = h
    }
    ,
    Object.freeze(d),
    Zr
}
var Xr = {}, Zo;
function Md() {
    if (Zo)
        return Xr;
    Zo = 1,
    Object.defineProperty(Xr, "__esModule", {
        value: !0
    }),
    Xr.pbkdf2 = void 0;
    const e = Bs()
      , t = Be();
    let s = !1;
    const r = function(h, m, f, i, l) {
        return (0,
        e.pbkdf2Sync)(h, m, f, i, l)
    };
    let n = r;
    function d(h, m, f, i, l) {
        const p = (0,
        t.getBytes)(h, "password")
          , o = (0,
        t.getBytes)(m, "salt");
        return (0,
        t.hexlify)(n(p, o, f, i, l))
    }
    return Xr.pbkdf2 = d,
    d._ = r,
    d.lock = function() {
        s = !0
    }
    ,
    d.register = function(h) {
        if (s)
            throw new Error("pbkdf2 is locked");
        n = h
    }
    ,
    Object.freeze(d),
    Xr
}
var en = {}, Xo;
function Ld() {
    if (Xo)
        return en;
    Xo = 1,
    Object.defineProperty(en, "__esModule", {
        value: !0
    }),
    en.randomBytes = void 0;
    const e = Bs();
    let t = !1;
    const s = function(d) {
        return new Uint8Array((0,
        e.randomBytes)(d))
    };
    let r = s;
    function n(d) {
        return r(d)
    }
    return en.randomBytes = n,
    n._ = s,
    n.lock = function() {
        t = !0
    }
    ,
    n.register = function(d) {
        if (t)
            throw new Error("randomBytes is locked");
        r = d
    }
    ,
    Object.freeze(n),
    en
}
var sr = {}, ir = {}, ea;
function Ud() {
    if (ea)
        return ir;
    ea = 1,
    Object.defineProperty(ir, "__esModule", {
        value: !0
    }),
    ir.scryptAsync = ir.scrypt = void 0;
    const e = ss()
      , t = Vi()
      , s = Hu()
      , r = It()
      , n = (p, o) => p << o | p >>> 32 - o;
    function d(p, o, c, u, g, P) {
        let v = p[o++] ^ c[u++]
          , b = p[o++] ^ c[u++]
          , x = p[o++] ^ c[u++]
          , a = p[o++] ^ c[u++]
          , E = p[o++] ^ c[u++]
          , w = p[o++] ^ c[u++]
          , S = p[o++] ^ c[u++]
          , T = p[o++] ^ c[u++]
          , C = p[o++] ^ c[u++]
          , N = p[o++] ^ c[u++]
          , A = p[o++] ^ c[u++]
          , R = p[o++] ^ c[u++]
          , y = p[o++] ^ c[u++]
          , k = p[o++] ^ c[u++]
          , _ = p[o++] ^ c[u++]
          , O = p[o++] ^ c[u++]
          , L = v
          , U = b
          , $ = x
          , B = a
          , I = E
          , F = w
          , z = S
          , Y = T
          , ie = C
          , ne = N
          , xe = A
          , W = R
          , ee = y
          , te = k
          , fe = _
          , be = O;
        for (let le = 0; le < 8; le += 2)
            I ^= n(L + ee | 0, 7),
            ie ^= n(I + L | 0, 9),
            ee ^= n(ie + I | 0, 13),
            L ^= n(ee + ie | 0, 18),
            ne ^= n(F + U | 0, 7),
            te ^= n(ne + F | 0, 9),
            U ^= n(te + ne | 0, 13),
            F ^= n(U + te | 0, 18),
            fe ^= n(xe + z | 0, 7),
            $ ^= n(fe + xe | 0, 9),
            z ^= n($ + fe | 0, 13),
            xe ^= n(z + $ | 0, 18),
            B ^= n(be + W | 0, 7),
            Y ^= n(B + be | 0, 9),
            W ^= n(Y + B | 0, 13),
            be ^= n(W + Y | 0, 18),
            U ^= n(L + B | 0, 7),
            $ ^= n(U + L | 0, 9),
            B ^= n($ + U | 0, 13),
            L ^= n(B + $ | 0, 18),
            z ^= n(F + I | 0, 7),
            Y ^= n(z + F | 0, 9),
            I ^= n(Y + z | 0, 13),
            F ^= n(I + Y | 0, 18),
            W ^= n(xe + ne | 0, 7),
            ie ^= n(W + xe | 0, 9),
            ne ^= n(ie + W | 0, 13),
            xe ^= n(ne + ie | 0, 18),
            ee ^= n(be + fe | 0, 7),
            te ^= n(ee + be | 0, 9),
            fe ^= n(te + ee | 0, 13),
            be ^= n(fe + te | 0, 18);
        g[P++] = v + L | 0,
        g[P++] = b + U | 0,
        g[P++] = x + $ | 0,
        g[P++] = a + B | 0,
        g[P++] = E + I | 0,
        g[P++] = w + F | 0,
        g[P++] = S + z | 0,
        g[P++] = T + Y | 0,
        g[P++] = C + ie | 0,
        g[P++] = N + ne | 0,
        g[P++] = A + xe | 0,
        g[P++] = R + W | 0,
        g[P++] = y + ee | 0,
        g[P++] = k + te | 0,
        g[P++] = _ + fe | 0,
        g[P++] = O + be | 0
    }
    function h(p, o, c, u, g) {
        let P = u + 0
          , v = u + 16 * g;
        for (let b = 0; b < 16; b++)
            c[v + b] = p[o + (2 * g - 1) * 16 + b];
        for (let b = 0; b < g; b++,
        P += 16,
        o += 16)
            d(c, v, p, o, c, P),
            b > 0 && (v += 16),
            d(c, P, p, o += 16, c, v)
    }
    function m(p, o, c) {
        const u = (0,
        r.checkOpts)({
            dkLen: 32,
            asyncTick: 10,
            maxmem: 1073742848
        }, c)
          , {N: g, r: P, p: v, dkLen: b, asyncTick: x, maxmem: a, onProgress: E} = u;
        if ((0,
        e.number)(g),
        (0,
        e.number)(P),
        (0,
        e.number)(v),
        (0,
        e.number)(b),
        (0,
        e.number)(x),
        (0,
        e.number)(a),
        E !== void 0 && typeof E != "function")
            throw new Error("progressCb should be function");
        const w = 128 * P
          , S = w / 4;
        if (g <= 1 || g & g - 1 || g >= 2 ** (w / 8) || g > 2 ** 32)
            throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
        if (v < 0 || v > (2 ** 32 - 1) * 32 / w)
            throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
        if (b < 0 || b > (2 ** 32 - 1) * 32)
            throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
        const T = w * (g + v);
        if (T > a)
            throw new Error(`Scrypt: parameters too large, ${T} (128 * r * (N + p)) > ${a} (maxmem)`);
        const C = (0,
        s.pbkdf2)(t.sha256, p, o, {
            c: 1,
            dkLen: w * v
        })
          , N = (0,
        r.u32)(C)
          , A = (0,
        r.u32)(new Uint8Array(w * g))
          , R = (0,
        r.u32)(new Uint8Array(w));
        let y = () => {}
        ;
        if (E) {
            const k = 2 * g * v
              , _ = Math.max(Math.floor(k / 1e4), 1);
            let O = 0;
            y = () => {
                O++,
                E && (!(O % _) || O === k) && E(O / k)
            }
        }
        return {
            N: g,
            r: P,
            p: v,
            dkLen: b,
            blockSize32: S,
            V: A,
            B32: N,
            B: C,
            tmp: R,
            blockMixCb: y,
            asyncTick: x
        }
    }
    function f(p, o, c, u, g) {
        const P = (0,
        s.pbkdf2)(t.sha256, p, c, {
            c: 1,
            dkLen: o
        });
        return c.fill(0),
        u.fill(0),
        g.fill(0),
        P
    }
    function i(p, o, c) {
        const {N: u, r: g, p: P, dkLen: v, blockSize32: b, V: x, B32: a, B: E, tmp: w, blockMixCb: S} = m(p, o, c);
        for (let T = 0; T < P; T++) {
            const C = b * T;
            for (let N = 0; N < b; N++)
                x[N] = a[C + N];
            for (let N = 0, A = 0; N < u - 1; N++)
                h(x, A, x, A += b, g),
                S();
            h(x, (u - 1) * b, a, C, g),
            S();
            for (let N = 0; N < u; N++) {
                const A = a[C + b - 16] % u;
                for (let R = 0; R < b; R++)
                    w[R] = a[C + R] ^ x[A * b + R];
                h(w, 0, a, C, g),
                S()
            }
        }
        return f(p, v, E, x, w)
    }
    ir.scrypt = i;
    async function l(p, o, c) {
        const {N: u, r: g, p: P, dkLen: v, blockSize32: b, V: x, B32: a, B: E, tmp: w, blockMixCb: S, asyncTick: T} = m(p, o, c);
        for (let C = 0; C < P; C++) {
            const N = b * C;
            for (let R = 0; R < b; R++)
                x[R] = a[N + R];
            let A = 0;
            await (0,
            r.asyncLoop)(u - 1, T, () => {
                h(x, A, x, A += b, g),
                S()
            }
            ),
            h(x, (u - 1) * b, a, N, g),
            S(),
            await (0,
            r.asyncLoop)(u, T, () => {
                const R = a[N + b - 16] % u;
                for (let y = 0; y < b; y++)
                    w[y] = a[N + y] ^ x[R * b + y];
                h(w, 0, a, N, g),
                S()
            }
            )
        }
        return f(p, v, E, x, w)
    }
    return ir.scryptAsync = l,
    ir
}
var ta;
function Fd() {
    if (ta)
        return sr;
    ta = 1,
    Object.defineProperty(sr, "__esModule", {
        value: !0
    }),
    sr.scryptSync = sr.scrypt = void 0;
    const e = Ud()
      , t = Be();
    let s = !1
      , r = !1;
    const n = async function(l, p, o, c, u, g, P) {
        return await (0,
        e.scryptAsync)(l, p, {
            N: o,
            r: c,
            p: u,
            dkLen: g,
            onProgress: P
        })
    }
      , d = function(l, p, o, c, u, g) {
        return (0,
        e.scrypt)(l, p, {
            N: o,
            r: c,
            p: u,
            dkLen: g
        })
    };
    let h = n
      , m = d;
    async function f(l, p, o, c, u, g, P) {
        const v = (0,
        t.getBytes)(l, "passwd")
          , b = (0,
        t.getBytes)(p, "salt");
        return (0,
        t.hexlify)(await h(v, b, o, c, u, g, P))
    }
    sr.scrypt = f,
    f._ = n,
    f.lock = function() {
        r = !0
    }
    ,
    f.register = function(l) {
        if (r)
            throw new Error("scrypt is locked");
        h = l
    }
    ,
    Object.freeze(f);
    function i(l, p, o, c, u, g) {
        const P = (0,
        t.getBytes)(l, "passwd")
          , v = (0,
        t.getBytes)(p, "salt");
        return (0,
        t.hexlify)(m(P, v, o, c, u, g))
    }
    return sr.scryptSync = i,
    i._ = d,
    i.lock = function() {
        s = !0
    }
    ,
    i.register = function(l) {
        if (s)
            throw new Error("scryptSync is locked");
        m = l
    }
    ,
    Object.freeze(i),
    sr
}
var or = {}, ra;
function Dd() {
    if (ra)
        return or;
    ra = 1,
    Object.defineProperty(or, "__esModule", {
        value: !0
    }),
    or.sha512 = or.sha256 = void 0;
    const e = Bs()
      , t = Be()
      , s = function(l) {
        return (0,
        e.createHash)("sha256").update(l).digest()
    }
      , r = function(l) {
        return (0,
        e.createHash)("sha512").update(l).digest()
    };
    let n = s
      , d = r
      , h = !1
      , m = !1;
    function f(l) {
        const p = (0,
        t.getBytes)(l, "data");
        return (0,
        t.hexlify)(n(p))
    }
    or.sha256 = f,
    f._ = s,
    f.lock = function() {
        h = !0
    }
    ,
    f.register = function(l) {
        if (h)
            throw new Error("sha256 is locked");
        n = l
    }
    ,
    Object.freeze(f);
    function i(l) {
        const p = (0,
        t.getBytes)(l, "data");
        return (0,
        t.hexlify)(d(p))
    }
    return or.sha512 = i,
    i._ = r,
    i.lock = function() {
        m = !0
    }
    ,
    i.register = function(l) {
        if (m)
            throw new Error("sha512 is locked");
        d = l
    }
    ,
    Object.freeze(f),
    or
}
var tn = {}, ti = {}, Ie = {}, Me = {}, na;
function Ir() {
    if (na)
        return Me;
    na = 1,
    Object.defineProperty(Me, "__esModule", {
        value: !0
    }),
    Me.validateObject = Me.createHmacDrbg = Me.bitMask = Me.bitSet = Me.bitGet = Me.bitLen = Me.utf8ToBytes = Me.equalBytes = Me.concatBytes = Me.ensureBytes = Me.numberToVarBytesBE = Me.numberToBytesLE = Me.numberToBytesBE = Me.bytesToNumberLE = Me.bytesToNumberBE = Me.hexToBytes = Me.hexToNumber = Me.numberToHexUnpadded = Me.bytesToHex = void 0;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const e = BigInt(0)
      , t = BigInt(1)
      , s = BigInt(2)
      , r = A => A instanceof Uint8Array
      , n = Array.from({
        length: 256
    }, (A, R) => R.toString(16).padStart(2, "0"));
    function d(A) {
        if (!r(A))
            throw new Error("Uint8Array expected");
        let R = "";
        for (let y = 0; y < A.length; y++)
            R += n[A[y]];
        return R
    }
    Me.bytesToHex = d;
    function h(A) {
        const R = A.toString(16);
        return R.length & 1 ? `0${R}` : R
    }
    Me.numberToHexUnpadded = h;
    function m(A) {
        if (typeof A != "string")
            throw new Error("hex string expected, got " + typeof A);
        return BigInt(A === "" ? "0" : `0x${A}`)
    }
    Me.hexToNumber = m;
    function f(A) {
        if (typeof A != "string")
            throw new Error("hex string expected, got " + typeof A);
        const R = A.length;
        if (R % 2)
            throw new Error("padded hex string expected, got unpadded hex of length " + R);
        const y = new Uint8Array(R / 2);
        for (let k = 0; k < y.length; k++) {
            const _ = k * 2
              , O = A.slice(_, _ + 2)
              , L = Number.parseInt(O, 16);
            if (Number.isNaN(L) || L < 0)
                throw new Error("Invalid byte sequence");
            y[k] = L
        }
        return y
    }
    Me.hexToBytes = f;
    function i(A) {
        return m(d(A))
    }
    Me.bytesToNumberBE = i;
    function l(A) {
        if (!r(A))
            throw new Error("Uint8Array expected");
        return m(d(Uint8Array.from(A).reverse()))
    }
    Me.bytesToNumberLE = l;
    function p(A, R) {
        return f(A.toString(16).padStart(R * 2, "0"))
    }
    Me.numberToBytesBE = p;
    function o(A, R) {
        return p(A, R).reverse()
    }
    Me.numberToBytesLE = o;
    function c(A) {
        return f(h(A))
    }
    Me.numberToVarBytesBE = c;
    function u(A, R, y) {
        let k;
        if (typeof R == "string")
            try {
                k = f(R)
            } catch (O) {
                throw new Error(`${A} must be valid hex string, got "${R}". Cause: ${O}`)
            }
        else if (r(R))
            k = Uint8Array.from(R);
        else
            throw new Error(`${A} must be hex string or Uint8Array`);
        const _ = k.length;
        if (typeof y == "number" && _ !== y)
            throw new Error(`${A} expected ${y} bytes, got ${_}`);
        return k
    }
    Me.ensureBytes = u;
    function g(...A) {
        const R = new Uint8Array(A.reduce( (k, _) => k + _.length, 0));
        let y = 0;
        return A.forEach(k => {
            if (!r(k))
                throw new Error("Uint8Array expected");
            R.set(k, y),
            y += k.length
        }
        ),
        R
    }
    Me.concatBytes = g;
    function P(A, R) {
        if (A.length !== R.length)
            return !1;
        for (let y = 0; y < A.length; y++)
            if (A[y] !== R[y])
                return !1;
        return !0
    }
    Me.equalBytes = P;
    function v(A) {
        if (typeof A != "string")
            throw new Error(`utf8ToBytes expected string, got ${typeof A}`);
        return new Uint8Array(new TextEncoder().encode(A))
    }
    Me.utf8ToBytes = v;
    function b(A) {
        let R;
        for (R = 0; A > e; A >>= t,
        R += 1)
            ;
        return R
    }
    Me.bitLen = b;
    function x(A, R) {
        return A >> BigInt(R) & t
    }
    Me.bitGet = x;
    const a = (A, R, y) => A | (y ? t : e) << BigInt(R);
    Me.bitSet = a;
    const E = A => (s << BigInt(A - 1)) - t;
    Me.bitMask = E;
    const w = A => new Uint8Array(A)
      , S = A => Uint8Array.from(A);
    function T(A, R, y) {
        if (typeof A != "number" || A < 2)
            throw new Error("hashLen must be a number");
        if (typeof R != "number" || R < 2)
            throw new Error("qByteLen must be a number");
        if (typeof y != "function")
            throw new Error("hmacFn must be a function");
        let k = w(A)
          , _ = w(A)
          , O = 0;
        const L = () => {
            k.fill(1),
            _.fill(0),
            O = 0
        }
          , U = (...F) => y(_, k, ...F)
          , $ = (F=w()) => {
            _ = U(S([0]), F),
            k = U(),
            F.length !== 0 && (_ = U(S([1]), F),
            k = U())
        }
          , B = () => {
            if (O++ >= 1e3)
                throw new Error("drbg: tried 1000 values");
            let F = 0;
            const z = [];
            for (; F < R; ) {
                k = U();
                const Y = k.slice();
                z.push(Y),
                F += k.length
            }
            return g(...z)
        }
        ;
        return (F, z) => {
            L(),
            $(F);
            let Y;
            for (; !(Y = z(B())); )
                $();
            return L(),
            Y
        }
    }
    Me.createHmacDrbg = T;
    const C = {
        bigint: A => typeof A == "bigint",
        function: A => typeof A == "function",
        boolean: A => typeof A == "boolean",
        string: A => typeof A == "string",
        stringOrUint8Array: A => typeof A == "string" || A instanceof Uint8Array,
        isSafeInteger: A => Number.isSafeInteger(A),
        array: A => Array.isArray(A),
        field: (A, R) => R.Fp.isValid(A),
        hash: A => typeof A == "function" && Number.isSafeInteger(A.outputLen)
    };
    function N(A, R, y={}) {
        const k = (_, O, L) => {
            const U = C[O];
            if (typeof U != "function")
                throw new Error(`Invalid validator "${O}", expected function`);
            const $ = A[_];
            if (!(L && $ === void 0) && !U($, A))
                throw new Error(`Invalid param ${String(_)}=${$} (${typeof $}), expected ${O}`)
        }
        ;
        for (const [_,O] of Object.entries(R))
            k(_, O, !1);
        for (const [_,O] of Object.entries(y))
            k(_, O, !0);
        return A
    }
    return Me.validateObject = N,
    Me
}
var sa;
function Ss() {
    if (sa)
        return Ie;
    sa = 1,
    Object.defineProperty(Ie, "__esModule", {
        value: !0
    }),
    Ie.mapHashToField = Ie.getMinHashLength = Ie.getFieldBytesLength = Ie.hashToPrivateScalar = Ie.FpSqrtEven = Ie.FpSqrtOdd = Ie.Field = Ie.nLength = Ie.FpIsSquare = Ie.FpDiv = Ie.FpInvertBatch = Ie.FpPow = Ie.validateField = Ie.isNegativeLE = Ie.FpSqrt = Ie.tonelliShanks = Ie.invert = Ie.pow2 = Ie.pow = Ie.mod = void 0;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const e = Ir()
      , t = BigInt(0)
      , s = BigInt(1)
      , r = BigInt(2)
      , n = BigInt(3)
      , d = BigInt(4)
      , h = BigInt(5)
      , m = BigInt(8);
    BigInt(9),
    BigInt(16);
    function f(y, k) {
        const _ = y % k;
        return _ >= t ? _ : k + _
    }
    Ie.mod = f;
    function i(y, k, _) {
        if (_ <= t || k < t)
            throw new Error("Expected power/modulo > 0");
        if (_ === s)
            return t;
        let O = s;
        for (; k > t; )
            k & s && (O = O * y % _),
            y = y * y % _,
            k >>= s;
        return O
    }
    Ie.pow = i;
    function l(y, k, _) {
        let O = y;
        for (; k-- > t; )
            O *= O,
            O %= _;
        return O
    }
    Ie.pow2 = l;
    function p(y, k) {
        if (y === t || k <= t)
            throw new Error(`invert: expected positive integers, got n=${y} mod=${k}`);
        let _ = f(y, k)
          , O = k
          , L = t
          , U = s;
        for (; _ !== t; ) {
            const B = O / _
              , I = O % _
              , F = L - U * B;
            O = _,
            _ = I,
            L = U,
            U = F
        }
        if (O !== s)
            throw new Error("invert: does not exist");
        return f(L, k)
    }
    Ie.invert = p;
    function o(y) {
        const k = (y - s) / r;
        let _, O, L;
        for (_ = y - s,
        O = 0; _ % r === t; _ /= r,
        O++)
            ;
        for (L = r; L < y && i(L, k, y) !== y - s; L++)
            ;
        if (O === 1) {
            const $ = (y + s) / d;
            return function(I, F) {
                const z = I.pow(F, $);
                if (!I.eql(I.sqr(z), F))
                    throw new Error("Cannot find square root");
                return z
            }
        }
        const U = (_ + s) / r;
        return function(B, I) {
            if (B.pow(I, k) === B.neg(B.ONE))
                throw new Error("Cannot find square root");
            let F = O
              , z = B.pow(B.mul(B.ONE, L), _)
              , Y = B.pow(I, U)
              , ie = B.pow(I, _);
            for (; !B.eql(ie, B.ONE); ) {
                if (B.eql(ie, B.ZERO))
                    return B.ZERO;
                let ne = 1;
                for (let W = B.sqr(ie); ne < F && !B.eql(W, B.ONE); ne++)
                    W = B.sqr(W);
                const xe = B.pow(z, s << BigInt(F - ne - 1));
                z = B.sqr(xe),
                Y = B.mul(Y, xe),
                ie = B.mul(ie, z),
                F = ne
            }
            return Y
        }
    }
    Ie.tonelliShanks = o;
    function c(y) {
        if (y % d === n) {
            const k = (y + s) / d;
            return function(O, L) {
                const U = O.pow(L, k);
                if (!O.eql(O.sqr(U), L))
                    throw new Error("Cannot find square root");
                return U
            }
        }
        if (y % m === h) {
            const k = (y - h) / m;
            return function(O, L) {
                const U = O.mul(L, r)
                  , $ = O.pow(U, k)
                  , B = O.mul(L, $)
                  , I = O.mul(O.mul(B, r), $)
                  , F = O.mul(B, O.sub(I, O.ONE));
                if (!O.eql(O.sqr(F), L))
                    throw new Error("Cannot find square root");
                return F
            }
        }
        return o(y)
    }
    Ie.FpSqrt = c;
    const u = (y, k) => (f(y, k) & s) === s;
    Ie.isNegativeLE = u;
    const g = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
    function P(y) {
        const k = {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger"
        }
          , _ = g.reduce( (O, L) => (O[L] = "function",
        O), k);
        return (0,
        e.validateObject)(y, _)
    }
    Ie.validateField = P;
    function v(y, k, _) {
        if (_ < t)
            throw new Error("Expected power > 0");
        if (_ === t)
            return y.ONE;
        if (_ === s)
            return k;
        let O = y.ONE
          , L = k;
        for (; _ > t; )
            _ & s && (O = y.mul(O, L)),
            L = y.sqr(L),
            _ >>= s;
        return O
    }
    Ie.FpPow = v;
    function b(y, k) {
        const _ = new Array(k.length)
          , O = k.reduce( (U, $, B) => y.is0($) ? U : (_[B] = U,
        y.mul(U, $)), y.ONE)
          , L = y.inv(O);
        return k.reduceRight( (U, $, B) => y.is0($) ? U : (_[B] = y.mul(U, _[B]),
        y.mul(U, $)), L),
        _
    }
    Ie.FpInvertBatch = b;
    function x(y, k, _) {
        return y.mul(k, typeof _ == "bigint" ? p(_, y.ORDER) : y.inv(_))
    }
    Ie.FpDiv = x;
    function a(y) {
        const k = (y.ORDER - s) / r;
        return _ => {
            const O = y.pow(_, k);
            return y.eql(O, y.ZERO) || y.eql(O, y.ONE)
        }
    }
    Ie.FpIsSquare = a;
    function E(y, k) {
        const _ = k !== void 0 ? k : y.toString(2).length
          , O = Math.ceil(_ / 8);
        return {
            nBitLength: _,
            nByteLength: O
        }
    }
    Ie.nLength = E;
    function w(y, k, _=!1, O={}) {
        if (y <= t)
            throw new Error(`Expected Field ORDER > 0, got ${y}`);
        const {nBitLength: L, nByteLength: U} = E(y, k);
        if (U > 2048)
            throw new Error("Field lengths over 2048 bytes are not supported");
        const $ = c(y)
          , B = Object.freeze({
            ORDER: y,
            BITS: L,
            BYTES: U,
            MASK: (0,
            e.bitMask)(L),
            ZERO: t,
            ONE: s,
            create: I => f(I, y),
            isValid: I => {
                if (typeof I != "bigint")
                    throw new Error(`Invalid field element: expected bigint, got ${typeof I}`);
                return t <= I && I < y
            }
            ,
            is0: I => I === t,
            isOdd: I => (I & s) === s,
            neg: I => f(-I, y),
            eql: (I, F) => I === F,
            sqr: I => f(I * I, y),
            add: (I, F) => f(I + F, y),
            sub: (I, F) => f(I - F, y),
            mul: (I, F) => f(I * F, y),
            pow: (I, F) => v(B, I, F),
            div: (I, F) => f(I * p(F, y), y),
            sqrN: I => I * I,
            addN: (I, F) => I + F,
            subN: (I, F) => I - F,
            mulN: (I, F) => I * F,
            inv: I => p(I, y),
            sqrt: O.sqrt || (I => $(B, I)),
            invertBatch: I => b(B, I),
            cmov: (I, F, z) => z ? F : I,
            toBytes: I => _ ? (0,
            e.numberToBytesLE)(I, U) : (0,
            e.numberToBytesBE)(I, U),
            fromBytes: I => {
                if (I.length !== U)
                    throw new Error(`Fp.fromBytes: expected ${U}, got ${I.length}`);
                return _ ? (0,
                e.bytesToNumberLE)(I) : (0,
                e.bytesToNumberBE)(I)
            }
        });
        return Object.freeze(B)
    }
    Ie.Field = w;
    function S(y, k) {
        if (!y.isOdd)
            throw new Error("Field doesn't have isOdd");
        const _ = y.sqrt(k);
        return y.isOdd(_) ? _ : y.neg(_)
    }
    Ie.FpSqrtOdd = S;
    function T(y, k) {
        if (!y.isOdd)
            throw new Error("Field doesn't have isOdd");
        const _ = y.sqrt(k);
        return y.isOdd(_) ? y.neg(_) : _
    }
    Ie.FpSqrtEven = T;
    function C(y, k, _=!1) {
        y = (0,
        e.ensureBytes)("privateHash", y);
        const O = y.length
          , L = E(k).nByteLength + 8;
        if (L < 24 || O < L || O > 1024)
            throw new Error(`hashToPrivateScalar: expected ${L}-1024 bytes of input, got ${O}`);
        const U = _ ? (0,
        e.bytesToNumberLE)(y) : (0,
        e.bytesToNumberBE)(y);
        return f(U, k - s) + s
    }
    Ie.hashToPrivateScalar = C;
    function N(y) {
        if (typeof y != "bigint")
            throw new Error("field order must be bigint");
        const k = y.toString(2).length;
        return Math.ceil(k / 8)
    }
    Ie.getFieldBytesLength = N;
    function A(y) {
        const k = N(y);
        return k + Math.ceil(k / 2)
    }
    Ie.getMinHashLength = A;
    function R(y, k, _=!1) {
        const O = y.length
          , L = N(k)
          , U = A(k);
        if (O < 16 || O < U || O > 1024)
            throw new Error(`expected ${U}-1024 bytes of input, got ${O}`);
        const $ = _ ? (0,
        e.bytesToNumberBE)(y) : (0,
        e.bytesToNumberLE)(y)
          , B = f($, k - s) + s;
        return _ ? (0,
        e.numberToBytesLE)(B, L) : (0,
        e.numberToBytesBE)(B, L)
    }
    return Ie.mapHashToField = R,
    Ie
}
var ri = {}, ar = {}, ia;
function Hd() {
    if (ia)
        return ar;
    ia = 1,
    Object.defineProperty(ar, "__esModule", {
        value: !0
    }),
    ar.validateBasic = ar.wNAF = void 0;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const e = Ss()
      , t = Ir()
      , s = BigInt(0)
      , r = BigInt(1);
    function n(h, m) {
        const f = (l, p) => {
            const o = p.negate();
            return l ? o : p
        }
          , i = l => {
            const p = Math.ceil(m / l) + 1
              , o = 2 ** (l - 1);
            return {
                windows: p,
                windowSize: o
            }
        }
        ;
        return {
            constTimeNegate: f,
            unsafeLadder(l, p) {
                let o = h.ZERO
                  , c = l;
                for (; p > s; )
                    p & r && (o = o.add(c)),
                    c = c.double(),
                    p >>= r;
                return o
            },
            precomputeWindow(l, p) {
                const {windows: o, windowSize: c} = i(p)
                  , u = [];
                let g = l
                  , P = g;
                for (let v = 0; v < o; v++) {
                    P = g,
                    u.push(P);
                    for (let b = 1; b < c; b++)
                        P = P.add(g),
                        u.push(P);
                    g = P.double()
                }
                return u
            },
            wNAF(l, p, o) {
                const {windows: c, windowSize: u} = i(l);
                let g = h.ZERO
                  , P = h.BASE;
                const v = BigInt(2 ** l - 1)
                  , b = 2 ** l
                  , x = BigInt(l);
                for (let a = 0; a < c; a++) {
                    const E = a * u;
                    let w = Number(o & v);
                    o >>= x,
                    w > u && (w -= b,
                    o += r);
                    const S = E
                      , T = E + Math.abs(w) - 1
                      , C = a % 2 !== 0
                      , N = w < 0;
                    w === 0 ? P = P.add(f(C, p[S])) : g = g.add(f(N, p[T]))
                }
                return {
                    p: g,
                    f: P
                }
            },
            wNAFCached(l, p, o, c) {
                const u = l._WINDOW_SIZE || 1;
                let g = p.get(l);
                return g || (g = this.precomputeWindow(l, u),
                u !== 1 && p.set(l, c(g))),
                this.wNAF(u, g, o)
            }
        }
    }
    ar.wNAF = n;
    function d(h) {
        return (0,
        e.validateField)(h.Fp),
        (0,
        t.validateObject)(h, {
            n: "bigint",
            h: "bigint",
            Gx: "field",
            Gy: "field"
        }, {
            nBitLength: "isSafeInteger",
            nByteLength: "isSafeInteger"
        }),
        Object.freeze({
            ...(0,
            e.nLength)(h.n, h.nBitLength),
            ...h,
            p: h.Fp.ORDER
        })
    }
    return ar.validateBasic = d,
    ar
}
var oa;
function $u() {
    return oa || (oa = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.mapToCurveSimpleSWU = e.SWUFpSqrtRatio = e.weierstrass = e.weierstrassPoints = e.DER = void 0;
        /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
        const t = Ss()
          , s = Ir()
          , r = Ir()
          , n = Hd();
        function d(b) {
            const x = (0,
            n.validateBasic)(b);
            s.validateObject(x, {
                a: "field",
                b: "field"
            }, {
                allowedPrivateKeyLengths: "array",
                wrapPrivateKey: "boolean",
                isTorsionFree: "function",
                clearCofactor: "function",
                allowInfinityPoint: "boolean",
                fromBytes: "function",
                toBytes: "function"
            });
            const {endo: a, Fp: E, a: w} = x;
            if (a) {
                if (!E.eql(w, E.ZERO))
                    throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                if (typeof a != "object" || typeof a.beta != "bigint" || typeof a.splitScalar != "function")
                    throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")
            }
            return Object.freeze({
                ...x
            })
        }
        const {bytesToNumberBE: h, hexToBytes: m} = s;
        e.DER = {
            Err: class extends Error {
                constructor(x="") {
                    super(x)
                }
            }
            ,
            _parseInt(b) {
                const {Err: x} = e.DER;
                if (b.length < 2 || b[0] !== 2)
                    throw new x("Invalid signature integer tag");
                const a = b[1]
                  , E = b.subarray(2, a + 2);
                if (!a || E.length !== a)
                    throw new x("Invalid signature integer: wrong length");
                if (E[0] & 128)
                    throw new x("Invalid signature integer: negative");
                if (E[0] === 0 && !(E[1] & 128))
                    throw new x("Invalid signature integer: unnecessary leading zero");
                return {
                    d: h(E),
                    l: b.subarray(a + 2)
                }
            },
            toSig(b) {
                const {Err: x} = e.DER
                  , a = typeof b == "string" ? m(b) : b;
                if (!(a instanceof Uint8Array))
                    throw new Error("ui8a expected");
                let E = a.length;
                if (E < 2 || a[0] != 48)
                    throw new x("Invalid signature tag");
                if (a[1] !== E - 2)
                    throw new x("Invalid signature: incorrect length");
                const {d: w, l: S} = e.DER._parseInt(a.subarray(2))
                  , {d: T, l: C} = e.DER._parseInt(S);
                if (C.length)
                    throw new x("Invalid signature: left bytes after parsing");
                return {
                    r: w,
                    s: T
                }
            },
            hexFromSig(b) {
                const x = A => Number.parseInt(A[0], 16) & 8 ? "00" + A : A
                  , a = A => {
                    const R = A.toString(16);
                    return R.length & 1 ? `0${R}` : R
                }
                  , E = x(a(b.s))
                  , w = x(a(b.r))
                  , S = E.length / 2
                  , T = w.length / 2
                  , C = a(S)
                  , N = a(T);
                return `30${a(T + S + 4)}02${N}${w}02${C}${E}`
            }
        };
        const f = BigInt(0)
          , i = BigInt(1)
          , l = BigInt(2)
          , p = BigInt(3)
          , o = BigInt(4);
        function c(b) {
            const x = d(b)
              , {Fp: a} = x
              , E = x.toBytes || ( (O, L, U) => {
                const $ = L.toAffine();
                return s.concatBytes(Uint8Array.from([4]), a.toBytes($.x), a.toBytes($.y))
            }
            )
              , w = x.fromBytes || (O => {
                const L = O.subarray(1)
                  , U = a.fromBytes(L.subarray(0, a.BYTES))
                  , $ = a.fromBytes(L.subarray(a.BYTES, 2 * a.BYTES));
                return {
                    x: U,
                    y: $
                }
            }
            );
            function S(O) {
                const {a: L, b: U} = x
                  , $ = a.sqr(O)
                  , B = a.mul($, O);
                return a.add(a.add(B, a.mul(O, L)), U)
            }
            if (!a.eql(a.sqr(x.Gy), S(x.Gx)))
                throw new Error("bad generator point: equation left != right");
            function T(O) {
                return typeof O == "bigint" && f < O && O < x.n
            }
            function C(O) {
                if (!T(O))
                    throw new Error("Expected valid bigint: 0 < bigint < curve.n")
            }
            function N(O) {
                const {allowedPrivateKeyLengths: L, nByteLength: U, wrapPrivateKey: $, n: B} = x;
                if (L && typeof O != "bigint") {
                    if (O instanceof Uint8Array && (O = s.bytesToHex(O)),
                    typeof O != "string" || !L.includes(O.length))
                        throw new Error("Invalid key");
                    O = O.padStart(U * 2, "0")
                }
                let I;
                try {
                    I = typeof O == "bigint" ? O : s.bytesToNumberBE((0,
                    r.ensureBytes)("private key", O, U))
                } catch {
                    throw new Error(`private key must be ${U} bytes, hex or bigint, not ${typeof O}`)
                }
                return $ && (I = t.mod(I, B)),
                C(I),
                I
            }
            const A = new Map;
            function R(O) {
                if (!(O instanceof y))
                    throw new Error("ProjectivePoint expected")
            }
            class y {
                constructor(L, U, $) {
                    if (this.px = L,
                    this.py = U,
                    this.pz = $,
                    L == null || !a.isValid(L))
                        throw new Error("x required");
                    if (U == null || !a.isValid(U))
                        throw new Error("y required");
                    if ($ == null || !a.isValid($))
                        throw new Error("z required")
                }
                static fromAffine(L) {
                    const {x: U, y: $} = L || {};
                    if (!L || !a.isValid(U) || !a.isValid($))
                        throw new Error("invalid affine point");
                    if (L instanceof y)
                        throw new Error("projective point not allowed");
                    const B = I => a.eql(I, a.ZERO);
                    return B(U) && B($) ? y.ZERO : new y(U,$,a.ONE)
                }
                get x() {
                    return this.toAffine().x
                }
                get y() {
                    return this.toAffine().y
                }
                static normalizeZ(L) {
                    const U = a.invertBatch(L.map($ => $.pz));
                    return L.map( ($, B) => $.toAffine(U[B])).map(y.fromAffine)
                }
                static fromHex(L) {
                    const U = y.fromAffine(w((0,
                    r.ensureBytes)("pointHex", L)));
                    return U.assertValidity(),
                    U
                }
                static fromPrivateKey(L) {
                    return y.BASE.multiply(N(L))
                }
                _setWindowSize(L) {
                    this._WINDOW_SIZE = L,
                    A.delete(this)
                }
                assertValidity() {
                    if (this.is0()) {
                        if (x.allowInfinityPoint && !a.is0(this.py))
                            return;
                        throw new Error("bad point: ZERO")
                    }
                    const {x: L, y: U} = this.toAffine();
                    if (!a.isValid(L) || !a.isValid(U))
                        throw new Error("bad point: x or y not FE");
                    const $ = a.sqr(U)
                      , B = S(L);
                    if (!a.eql($, B))
                        throw new Error("bad point: equation left != right");
                    if (!this.isTorsionFree())
                        throw new Error("bad point: not in prime-order subgroup")
                }
                hasEvenY() {
                    const {y: L} = this.toAffine();
                    if (a.isOdd)
                        return !a.isOdd(L);
                    throw new Error("Field doesn't support isOdd")
                }
                equals(L) {
                    R(L);
                    const {px: U, py: $, pz: B} = this
                      , {px: I, py: F, pz: z} = L
                      , Y = a.eql(a.mul(U, z), a.mul(I, B))
                      , ie = a.eql(a.mul($, z), a.mul(F, B));
                    return Y && ie
                }
                negate() {
                    return new y(this.px,a.neg(this.py),this.pz)
                }
                double() {
                    const {a: L, b: U} = x
                      , $ = a.mul(U, p)
                      , {px: B, py: I, pz: F} = this;
                    let z = a.ZERO
                      , Y = a.ZERO
                      , ie = a.ZERO
                      , ne = a.mul(B, B)
                      , xe = a.mul(I, I)
                      , W = a.mul(F, F)
                      , ee = a.mul(B, I);
                    return ee = a.add(ee, ee),
                    ie = a.mul(B, F),
                    ie = a.add(ie, ie),
                    z = a.mul(L, ie),
                    Y = a.mul($, W),
                    Y = a.add(z, Y),
                    z = a.sub(xe, Y),
                    Y = a.add(xe, Y),
                    Y = a.mul(z, Y),
                    z = a.mul(ee, z),
                    ie = a.mul($, ie),
                    W = a.mul(L, W),
                    ee = a.sub(ne, W),
                    ee = a.mul(L, ee),
                    ee = a.add(ee, ie),
                    ie = a.add(ne, ne),
                    ne = a.add(ie, ne),
                    ne = a.add(ne, W),
                    ne = a.mul(ne, ee),
                    Y = a.add(Y, ne),
                    W = a.mul(I, F),
                    W = a.add(W, W),
                    ne = a.mul(W, ee),
                    z = a.sub(z, ne),
                    ie = a.mul(W, xe),
                    ie = a.add(ie, ie),
                    ie = a.add(ie, ie),
                    new y(z,Y,ie)
                }
                add(L) {
                    R(L);
                    const {px: U, py: $, pz: B} = this
                      , {px: I, py: F, pz: z} = L;
                    let Y = a.ZERO
                      , ie = a.ZERO
                      , ne = a.ZERO;
                    const xe = x.a
                      , W = a.mul(x.b, p);
                    let ee = a.mul(U, I)
                      , te = a.mul($, F)
                      , fe = a.mul(B, z)
                      , be = a.add(U, $)
                      , le = a.add(I, F);
                    be = a.mul(be, le),
                    le = a.add(ee, te),
                    be = a.sub(be, le),
                    le = a.add(U, B);
                    let re = a.add(I, z);
                    return le = a.mul(le, re),
                    re = a.add(ee, fe),
                    le = a.sub(le, re),
                    re = a.add($, B),
                    Y = a.add(F, z),
                    re = a.mul(re, Y),
                    Y = a.add(te, fe),
                    re = a.sub(re, Y),
                    ne = a.mul(xe, le),
                    Y = a.mul(W, fe),
                    ne = a.add(Y, ne),
                    Y = a.sub(te, ne),
                    ne = a.add(te, ne),
                    ie = a.mul(Y, ne),
                    te = a.add(ee, ee),
                    te = a.add(te, ee),
                    fe = a.mul(xe, fe),
                    le = a.mul(W, le),
                    te = a.add(te, fe),
                    fe = a.sub(ee, fe),
                    fe = a.mul(xe, fe),
                    le = a.add(le, fe),
                    ee = a.mul(te, le),
                    ie = a.add(ie, ee),
                    ee = a.mul(re, le),
                    Y = a.mul(be, Y),
                    Y = a.sub(Y, ee),
                    ee = a.mul(be, te),
                    ne = a.mul(re, ne),
                    ne = a.add(ne, ee),
                    new y(Y,ie,ne)
                }
                subtract(L) {
                    return this.add(L.negate())
                }
                is0() {
                    return this.equals(y.ZERO)
                }
                wNAF(L) {
                    return _.wNAFCached(this, A, L, U => {
                        const $ = a.invertBatch(U.map(B => B.pz));
                        return U.map( (B, I) => B.toAffine($[I])).map(y.fromAffine)
                    }
                    )
                }
                multiplyUnsafe(L) {
                    const U = y.ZERO;
                    if (L === f)
                        return U;
                    if (C(L),
                    L === i)
                        return this;
                    const {endo: $} = x;
                    if (!$)
                        return _.unsafeLadder(this, L);
                    let {k1neg: B, k1: I, k2neg: F, k2: z} = $.splitScalar(L)
                      , Y = U
                      , ie = U
                      , ne = this;
                    for (; I > f || z > f; )
                        I & i && (Y = Y.add(ne)),
                        z & i && (ie = ie.add(ne)),
                        ne = ne.double(),
                        I >>= i,
                        z >>= i;
                    return B && (Y = Y.negate()),
                    F && (ie = ie.negate()),
                    ie = new y(a.mul(ie.px, $.beta),ie.py,ie.pz),
                    Y.add(ie)
                }
                multiply(L) {
                    C(L);
                    let U = L, $, B;
                    const {endo: I} = x;
                    if (I) {
                        const {k1neg: F, k1: z, k2neg: Y, k2: ie} = I.splitScalar(U);
                        let {p: ne, f: xe} = this.wNAF(z)
                          , {p: W, f: ee} = this.wNAF(ie);
                        ne = _.constTimeNegate(F, ne),
                        W = _.constTimeNegate(Y, W),
                        W = new y(a.mul(W.px, I.beta),W.py,W.pz),
                        $ = ne.add(W),
                        B = xe.add(ee)
                    } else {
                        const {p: F, f: z} = this.wNAF(U);
                        $ = F,
                        B = z
                    }
                    return y.normalizeZ([$, B])[0]
                }
                multiplyAndAddUnsafe(L, U, $) {
                    const B = y.BASE
                      , I = (z, Y) => Y === f || Y === i || !z.equals(B) ? z.multiplyUnsafe(Y) : z.multiply(Y)
                      , F = I(this, U).add(I(L, $));
                    return F.is0() ? void 0 : F
                }
                toAffine(L) {
                    const {px: U, py: $, pz: B} = this
                      , I = this.is0();
                    L == null && (L = I ? a.ONE : a.inv(B));
                    const F = a.mul(U, L)
                      , z = a.mul($, L)
                      , Y = a.mul(B, L);
                    if (I)
                        return {
                            x: a.ZERO,
                            y: a.ZERO
                        };
                    if (!a.eql(Y, a.ONE))
                        throw new Error("invZ was invalid");
                    return {
                        x: F,
                        y: z
                    }
                }
                isTorsionFree() {
                    const {h: L, isTorsionFree: U} = x;
                    if (L === i)
                        return !0;
                    if (U)
                        return U(y, this);
                    throw new Error("isTorsionFree() has not been declared for the elliptic curve")
                }
                clearCofactor() {
                    const {h: L, clearCofactor: U} = x;
                    return L === i ? this : U ? U(y, this) : this.multiplyUnsafe(x.h)
                }
                toRawBytes(L=!0) {
                    return this.assertValidity(),
                    E(y, this, L)
                }
                toHex(L=!0) {
                    return s.bytesToHex(this.toRawBytes(L))
                }
            }
            y.BASE = new y(x.Gx,x.Gy,a.ONE),
            y.ZERO = new y(a.ZERO,a.ONE,a.ZERO);
            const k = x.nBitLength
              , _ = (0,
            n.wNAF)(y, x.endo ? Math.ceil(k / 2) : k);
            return {
                CURVE: x,
                ProjectivePoint: y,
                normPrivateKeyToScalar: N,
                weierstrassEquation: S,
                isWithinCurveOrder: T
            }
        }
        e.weierstrassPoints = c;
        function u(b) {
            const x = (0,
            n.validateBasic)(b);
            return s.validateObject(x, {
                hash: "hash",
                hmac: "function",
                randomBytes: "function"
            }, {
                bits2int: "function",
                bits2int_modN: "function",
                lowS: "boolean"
            }),
            Object.freeze({
                lowS: !0,
                ...x
            })
        }
        function g(b) {
            const x = u(b)
              , {Fp: a, n: E} = x
              , w = a.BYTES + 1
              , S = 2 * a.BYTES + 1;
            function T(le) {
                return f < le && le < a.ORDER
            }
            function C(le) {
                return t.mod(le, E)
            }
            function N(le) {
                return t.invert(le, E)
            }
            const {ProjectivePoint: A, normPrivateKeyToScalar: R, weierstrassEquation: y, isWithinCurveOrder: k} = c({
                ...x,
                toBytes(le, re, M) {
                    const K = re.toAffine()
                      , V = a.toBytes(K.x)
                      , oe = s.concatBytes;
                    return M ? oe(Uint8Array.from([re.hasEvenY() ? 2 : 3]), V) : oe(Uint8Array.from([4]), V, a.toBytes(K.y))
                },
                fromBytes(le) {
                    const re = le.length
                      , M = le[0]
                      , K = le.subarray(1);
                    if (re === w && (M === 2 || M === 3)) {
                        const V = s.bytesToNumberBE(K);
                        if (!T(V))
                            throw new Error("Point is not on curve");
                        const oe = y(V);
                        let me = a.sqrt(oe);
                        const Pe = (me & i) === i;
                        return (M & 1) === 1 !== Pe && (me = a.neg(me)),
                        {
                            x: V,
                            y: me
                        }
                    } else if (re === S && M === 4) {
                        const V = a.fromBytes(K.subarray(0, a.BYTES))
                          , oe = a.fromBytes(K.subarray(a.BYTES, 2 * a.BYTES));
                        return {
                            x: V,
                            y: oe
                        }
                    } else
                        throw new Error(`Point of length ${re} was invalid. Expected ${w} compressed bytes or ${S} uncompressed bytes`)
                }
            })
              , _ = le => s.bytesToHex(s.numberToBytesBE(le, x.nByteLength));
            function O(le) {
                const re = E >> i;
                return le > re
            }
            function L(le) {
                return O(le) ? C(-le) : le
            }
            const U = (le, re, M) => s.bytesToNumberBE(le.slice(re, M));
            class $ {
                constructor(re, M, K) {
                    this.r = re,
                    this.s = M,
                    this.recovery = K,
                    this.assertValidity()
                }
                static fromCompact(re) {
                    const M = x.nByteLength;
                    return re = (0,
                    r.ensureBytes)("compactSignature", re, M * 2),
                    new $(U(re, 0, M),U(re, M, 2 * M))
                }
                static fromDER(re) {
                    const {r: M, s: K} = e.DER.toSig((0,
                    r.ensureBytes)("DER", re));
                    return new $(M,K)
                }
                assertValidity() {
                    if (!k(this.r))
                        throw new Error("r must be 0 < r < CURVE.n");
                    if (!k(this.s))
                        throw new Error("s must be 0 < s < CURVE.n")
                }
                addRecoveryBit(re) {
                    return new $(this.r,this.s,re)
                }
                recoverPublicKey(re) {
                    const {r: M, s: K, recovery: V} = this
                      , oe = ie((0,
                    r.ensureBytes)("msgHash", re));
                    if (V == null || ![0, 1, 2, 3].includes(V))
                        throw new Error("recovery id invalid");
                    const me = V === 2 || V === 3 ? M + x.n : M;
                    if (me >= a.ORDER)
                        throw new Error("recovery id 2 or 3 invalid");
                    const Pe = V & 1 ? "03" : "02"
                      , se = A.fromHex(Pe + _(me))
                      , H = N(me)
                      , G = C(-oe * H)
                      , q = C(K * H)
                      , ae = A.BASE.multiplyAndAddUnsafe(se, G, q);
                    if (!ae)
                        throw new Error("point at infinify");
                    return ae.assertValidity(),
                    ae
                }
                hasHighS() {
                    return O(this.s)
                }
                normalizeS() {
                    return this.hasHighS() ? new $(this.r,C(-this.s),this.recovery) : this
                }
                toDERRawBytes() {
                    return s.hexToBytes(this.toDERHex())
                }
                toDERHex() {
                    return e.DER.hexFromSig({
                        r: this.r,
                        s: this.s
                    })
                }
                toCompactRawBytes() {
                    return s.hexToBytes(this.toCompactHex())
                }
                toCompactHex() {
                    return _(this.r) + _(this.s)
                }
            }
            const B = {
                isValidPrivateKey(le) {
                    try {
                        return R(le),
                        !0
                    } catch {
                        return !1
                    }
                },
                normPrivateKeyToScalar: R,
                randomPrivateKey: () => {
                    const le = t.getMinHashLength(x.n);
                    return t.mapHashToField(x.randomBytes(le), x.n)
                }
                ,
                precompute(le=8, re=A.BASE) {
                    return re._setWindowSize(le),
                    re.multiply(BigInt(3)),
                    re
                }
            };
            function I(le, re=!0) {
                return A.fromPrivateKey(le).toRawBytes(re)
            }
            function F(le) {
                const re = le instanceof Uint8Array
                  , M = typeof le == "string"
                  , K = (re || M) && le.length;
                return re ? K === w || K === S : M ? K === 2 * w || K === 2 * S : le instanceof A
            }
            function z(le, re, M=!0) {
                if (F(le))
                    throw new Error("first arg must be private key");
                if (!F(re))
                    throw new Error("second arg must be public key");
                return A.fromHex(re).multiply(R(le)).toRawBytes(M)
            }
            const Y = x.bits2int || function(le) {
                const re = s.bytesToNumberBE(le)
                  , M = le.length * 8 - x.nBitLength;
                return M > 0 ? re >> BigInt(M) : re
            }
              , ie = x.bits2int_modN || function(le) {
                return C(Y(le))
            }
              , ne = s.bitMask(x.nBitLength);
            function xe(le) {
                if (typeof le != "bigint")
                    throw new Error("bigint expected");
                if (!(f <= le && le < ne))
                    throw new Error(`bigint expected < 2^${x.nBitLength}`);
                return s.numberToBytesBE(le, x.nByteLength)
            }
            function W(le, re, M=ee) {
                if (["recovered", "canonical"].some(J => J in M))
                    throw new Error("sign() legacy options not supported");
                const {hash: K, randomBytes: V} = x;
                let {lowS: oe, prehash: me, extraEntropy: Pe} = M;
                oe == null && (oe = !0),
                le = (0,
                r.ensureBytes)("msgHash", le),
                me && (le = (0,
                r.ensureBytes)("prehashed msgHash", K(le)));
                const se = ie(le)
                  , H = R(re)
                  , G = [xe(H), xe(se)];
                if (Pe != null) {
                    const J = Pe === !0 ? V(a.BYTES) : Pe;
                    G.push((0,
                    r.ensureBytes)("extraEntropy", J))
                }
                const q = s.concatBytes(...G)
                  , ae = se;
                function Z(J) {
                    const D = Y(J);
                    if (!k(D))
                        return;
                    const X = N(D)
                      , ce = A.BASE.multiply(D).toAffine()
                      , pe = C(ce.x);
                    if (pe === f)
                        return;
                    const ve = C(X * C(ae + pe * H));
                    if (ve === f)
                        return;
                    let Oe = (ce.x === pe ? 0 : 2) | Number(ce.y & i)
                      , Ge = ve;
                    return oe && O(ve) && (Ge = L(ve),
                    Oe ^= 1),
                    new $(pe,Ge,Oe)
                }
                return {
                    seed: q,
                    k2sig: Z
                }
            }
            const ee = {
                lowS: x.lowS,
                prehash: !1
            }
              , te = {
                lowS: x.lowS,
                prehash: !1
            };
            function fe(le, re, M=ee) {
                const {seed: K, k2sig: V} = W(le, re, M)
                  , oe = x;
                return s.createHmacDrbg(oe.hash.outputLen, oe.nByteLength, oe.hmac)(K, V)
            }
            A.BASE._setWindowSize(8);
            function be(le, re, M, K=te) {
                var ce;
                const V = le;
                if (re = (0,
                r.ensureBytes)("msgHash", re),
                M = (0,
                r.ensureBytes)("publicKey", M),
                "strict"in K)
                    throw new Error("options.strict was renamed to lowS");
                const {lowS: oe, prehash: me} = K;
                let Pe, se;
                try {
                    if (typeof V == "string" || V instanceof Uint8Array)
                        try {
                            Pe = $.fromDER(V)
                        } catch (pe) {
                            if (!(pe instanceof e.DER.Err))
                                throw pe;
                            Pe = $.fromCompact(V)
                        }
                    else if (typeof V == "object" && typeof V.r == "bigint" && typeof V.s == "bigint") {
                        const {r: pe, s: ve} = V;
                        Pe = new $(pe,ve)
                    } else
                        throw new Error("PARSE");
                    se = A.fromHex(M)
                } catch (pe) {
                    if (pe.message === "PARSE")
                        throw new Error("signature must be Signature instance, Uint8Array or hex string");
                    return !1
                }
                if (oe && Pe.hasHighS())
                    return !1;
                me && (re = x.hash(re));
                const {r: H, s: G} = Pe
                  , q = ie(re)
                  , ae = N(G)
                  , Z = C(q * ae)
                  , J = C(H * ae)
                  , D = (ce = A.BASE.multiplyAndAddUnsafe(se, Z, J)) == null ? void 0 : ce.toAffine();
                return D ? C(D.x) === H : !1
            }
            return {
                CURVE: x,
                getPublicKey: I,
                getSharedSecret: z,
                sign: fe,
                verify: be,
                ProjectivePoint: A,
                Signature: $,
                utils: B
            }
        }
        e.weierstrass = g;
        function P(b, x) {
            const a = b.ORDER;
            let E = f;
            for (let O = a - i; O % l === f; O /= l)
                E += i;
            const w = E
              , S = l << w - i - i
              , T = S * l
              , C = (a - i) / T
              , N = (C - i) / l
              , A = T - i
              , R = S
              , y = b.pow(x, C)
              , k = b.pow(x, (C + i) / l);
            let _ = (O, L) => {
                let U = y
                  , $ = b.pow(L, A)
                  , B = b.sqr($);
                B = b.mul(B, L);
                let I = b.mul(O, B);
                I = b.pow(I, N),
                I = b.mul(I, $),
                $ = b.mul(I, L),
                B = b.mul(I, O);
                let F = b.mul(B, $);
                I = b.pow(F, R);
                let z = b.eql(I, b.ONE);
                $ = b.mul(B, k),
                I = b.mul(F, U),
                B = b.cmov($, B, z),
                F = b.cmov(I, F, z);
                for (let Y = w; Y > i; Y--) {
                    let ie = Y - l;
                    ie = l << ie - i;
                    let ne = b.pow(F, ie);
                    const xe = b.eql(ne, b.ONE);
                    $ = b.mul(B, U),
                    U = b.mul(U, U),
                    ne = b.mul(F, U),
                    B = b.cmov($, B, xe),
                    F = b.cmov(ne, F, xe)
                }
                return {
                    isValid: z,
                    value: B
                }
            }
            ;
            if (b.ORDER % o === p) {
                const O = (b.ORDER - p) / o
                  , L = b.sqrt(b.neg(x));
                _ = (U, $) => {
                    let B = b.sqr($);
                    const I = b.mul(U, $);
                    B = b.mul(B, I);
                    let F = b.pow(B, O);
                    F = b.mul(F, I);
                    const z = b.mul(F, L)
                      , Y = b.mul(b.sqr(F), $)
                      , ie = b.eql(Y, U);
                    let ne = b.cmov(z, F, ie);
                    return {
                        isValid: ie,
                        value: ne
                    }
                }
            }
            return _
        }
        e.SWUFpSqrtRatio = P;
        function v(b, x) {
            if (t.validateField(b),
            !b.isValid(x.A) || !b.isValid(x.B) || !b.isValid(x.Z))
                throw new Error("mapToCurveSimpleSWU: invalid opts");
            const a = P(b, x.Z);
            if (!b.isOdd)
                throw new Error("Fp.isOdd is not implemented!");
            return E => {
                let w, S, T, C, N, A, R, y;
                w = b.sqr(E),
                w = b.mul(w, x.Z),
                S = b.sqr(w),
                S = b.add(S, w),
                T = b.add(S, b.ONE),
                T = b.mul(T, x.B),
                C = b.cmov(x.Z, b.neg(S), !b.eql(S, b.ZERO)),
                C = b.mul(C, x.A),
                S = b.sqr(T),
                A = b.sqr(C),
                N = b.mul(A, x.A),
                S = b.add(S, N),
                S = b.mul(S, T),
                A = b.mul(A, C),
                N = b.mul(A, x.B),
                S = b.add(S, N),
                R = b.mul(w, T);
                const {isValid: k, value: _} = a(S, A);
                y = b.mul(w, E),
                y = b.mul(y, _),
                R = b.cmov(R, T, k),
                y = b.cmov(y, _, k);
                const O = b.isOdd(E) === b.isOdd(y);
                return y = b.cmov(b.neg(y), y, O),
                R = b.div(R, C),
                {
                    x: R,
                    y
                }
            }
        }
        e.mapToCurveSimpleSWU = v
    }(ri)),
    ri
}
var ht = {}, aa;
function Gd() {
    if (aa)
        return ht;
    aa = 1,
    Object.defineProperty(ht, "__esModule", {
        value: !0
    }),
    ht.createHasher = ht.isogenyMap = ht.hash_to_field = ht.expand_message_xof = ht.expand_message_xmd = void 0;
    const e = Ss()
      , t = Ir();
    function s(c) {
        if (c instanceof Uint8Array)
            return c;
        if (typeof c == "string")
            return (0,
            t.utf8ToBytes)(c);
        throw new Error("DST must be Uint8Array or string")
    }
    const r = t.bytesToNumberBE;
    function n(c, u) {
        if (c < 0 || c >= 1 << 8 * u)
            throw new Error(`bad I2OSP call: value=${c} length=${u}`);
        const g = Array.from({
            length: u
        }).fill(0);
        for (let P = u - 1; P >= 0; P--)
            g[P] = c & 255,
            c >>>= 8;
        return new Uint8Array(g)
    }
    function d(c, u) {
        const g = new Uint8Array(c.length);
        for (let P = 0; P < c.length; P++)
            g[P] = c[P] ^ u[P];
        return g
    }
    function h(c) {
        if (!(c instanceof Uint8Array))
            throw new Error("Uint8Array expected")
    }
    function m(c) {
        if (!Number.isSafeInteger(c))
            throw new Error("number expected")
    }
    function f(c, u, g, P) {
        h(c),
        h(u),
        m(g),
        u.length > 255 && (u = P((0,
        t.concatBytes)((0,
        t.utf8ToBytes)("H2C-OVERSIZE-DST-"), u)));
        const {outputLen: v, blockLen: b} = P
          , x = Math.ceil(g / v);
        if (x > 255)
            throw new Error("Invalid xmd length");
        const a = (0,
        t.concatBytes)(u, n(u.length, 1))
          , E = n(0, b)
          , w = n(g, 2)
          , S = new Array(x)
          , T = P((0,
        t.concatBytes)(E, c, w, n(0, 1), a));
        S[0] = P((0,
        t.concatBytes)(T, n(1, 1), a));
        for (let N = 1; N <= x; N++) {
            const A = [d(T, S[N - 1]), n(N + 1, 1), a];
            S[N] = P((0,
            t.concatBytes)(...A))
        }
        return (0,
        t.concatBytes)(...S).slice(0, g)
    }
    ht.expand_message_xmd = f;
    function i(c, u, g, P, v) {
        if (h(c),
        h(u),
        m(g),
        u.length > 255) {
            const b = Math.ceil(2 * P / 8);
            u = v.create({
                dkLen: b
            }).update((0,
            t.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(u).digest()
        }
        if (g > 65535 || u.length > 255)
            throw new Error("expand_message_xof: invalid lenInBytes");
        return v.create({
            dkLen: g
        }).update(c).update(n(g, 2)).update(u).update(n(u.length, 1)).digest()
    }
    ht.expand_message_xof = i;
    function l(c, u, g) {
        (0,
        t.validateObject)(g, {
            DST: "stringOrUint8Array",
            p: "bigint",
            m: "isSafeInteger",
            k: "isSafeInteger",
            hash: "hash"
        });
        const {p: P, k: v, m: b, hash: x, expand: a, DST: E} = g;
        h(c),
        m(u);
        const w = s(E)
          , S = P.toString(2).length
          , T = Math.ceil((S + v) / 8)
          , C = u * b * T;
        let N;
        if (a === "xmd")
            N = f(c, w, C, x);
        else if (a === "xof")
            N = i(c, w, C, v, x);
        else if (a === "_internal_pass")
            N = c;
        else
            throw new Error('expand must be "xmd" or "xof"');
        const A = new Array(u);
        for (let R = 0; R < u; R++) {
            const y = new Array(b);
            for (let k = 0; k < b; k++) {
                const _ = T * (k + R * b)
                  , O = N.subarray(_, _ + T);
                y[k] = (0,
                e.mod)(r(O), P)
            }
            A[R] = y
        }
        return A
    }
    ht.hash_to_field = l;
    function p(c, u) {
        const g = u.map(P => Array.from(P).reverse());
        return (P, v) => {
            const [b,x,a,E] = g.map(w => w.reduce( (S, T) => c.add(c.mul(S, P), T)));
            return P = c.div(b, x),
            v = c.mul(v, c.div(a, E)),
            {
                x: P,
                y: v
            }
        }
    }
    ht.isogenyMap = p;
    function o(c, u, g) {
        if (typeof u != "function")
            throw new Error("mapToCurve() must be defined");
        return {
            hashToCurve(P, v) {
                const b = l(P, 2, {
                    ...g,
                    DST: g.DST,
                    ...v
                })
                  , x = c.fromAffine(u(b[0]))
                  , a = c.fromAffine(u(b[1]))
                  , E = x.add(a).clearCofactor();
                return E.assertValidity(),
                E
            },
            encodeToCurve(P, v) {
                const b = l(P, 1, {
                    ...g,
                    DST: g.encodeDST,
                    ...v
                })
                  , x = c.fromAffine(u(b[0])).clearCofactor();
                return x.assertValidity(),
                x
            }
        }
    }
    return ht.createHasher = o,
    ht
}
var cr = {}, ca;
function $d() {
    if (ca)
        return cr;
    ca = 1,
    Object.defineProperty(cr, "__esModule", {
        value: !0
    }),
    cr.createCurve = cr.getHash = void 0;
    /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
    const e = zi()
      , t = It()
      , s = $u();
    function r(d) {
        return {
            hash: d,
            hmac: (h, ...m) => (0,
            e.hmac)(d, h, (0,
            t.concatBytes)(...m)),
            randomBytes: t.randomBytes
        }
    }
    cr.getHash = r;
    function n(d, h) {
        const m = f => (0,
        s.weierstrass)({
            ...d,
            ...r(f)
        });
        return Object.freeze({
            ...m(h),
            create: m
        })
    }
    return cr.createCurve = n,
    cr
}
var ua;
function qd() {
    return ua || (ua = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0;
        /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
        const t = Vi()
          , s = It()
          , r = Ss()
          , n = $u()
          , d = Ir()
          , h = Gd()
          , m = $d()
          , f = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
          , i = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
          , l = BigInt(1)
          , p = BigInt(2)
          , o = ($, B) => ($ + B / p) / B;
        function c($) {
            const B = f
              , I = BigInt(3)
              , F = BigInt(6)
              , z = BigInt(11)
              , Y = BigInt(22)
              , ie = BigInt(23)
              , ne = BigInt(44)
              , xe = BigInt(88)
              , W = $ * $ * $ % B
              , ee = W * W * $ % B
              , te = (0,
            r.pow2)(ee, I, B) * ee % B
              , fe = (0,
            r.pow2)(te, I, B) * ee % B
              , be = (0,
            r.pow2)(fe, p, B) * W % B
              , le = (0,
            r.pow2)(be, z, B) * be % B
              , re = (0,
            r.pow2)(le, Y, B) * le % B
              , M = (0,
            r.pow2)(re, ne, B) * re % B
              , K = (0,
            r.pow2)(M, xe, B) * M % B
              , V = (0,
            r.pow2)(K, ne, B) * re % B
              , oe = (0,
            r.pow2)(V, I, B) * ee % B
              , me = (0,
            r.pow2)(oe, ie, B) * le % B
              , Pe = (0,
            r.pow2)(me, F, B) * W % B
              , se = (0,
            r.pow2)(Pe, p, B);
            if (!u.eql(u.sqr(se), $))
                throw new Error("Cannot find square root");
            return se
        }
        const u = (0,
        r.Field)(f, void 0, void 0, {
            sqrt: c
        });
        e.secp256k1 = (0,
        m.createCurve)({
            a: BigInt(0),
            b: BigInt(7),
            Fp: u,
            n: i,
            Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
            Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
            h: BigInt(1),
            lowS: !0,
            endo: {
                beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
                splitScalar: $ => {
                    const B = i
                      , I = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
                      , F = -l * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
                      , z = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
                      , Y = I
                      , ie = BigInt("0x100000000000000000000000000000000")
                      , ne = o(Y * $, B)
                      , xe = o(-F * $, B);
                    let W = (0,
                    r.mod)($ - ne * I - xe * z, B)
                      , ee = (0,
                    r.mod)(-ne * F - xe * Y, B);
                    const te = W > ie
                      , fe = ee > ie;
                    if (te && (W = B - W),
                    fe && (ee = B - ee),
                    W > ie || ee > ie)
                        throw new Error("splitScalar: Endomorphism failed, k=" + $);
                    return {
                        k1neg: te,
                        k1: W,
                        k2neg: fe,
                        k2: ee
                    }
                }
            }
        }, t.sha256);
        const g = BigInt(0)
          , P = $ => typeof $ == "bigint" && g < $ && $ < f
          , v = $ => typeof $ == "bigint" && g < $ && $ < i
          , b = {};
        function x($, ...B) {
            let I = b[$];
            if (I === void 0) {
                const F = (0,
                t.sha256)(Uint8Array.from($, z => z.charCodeAt(0)));
                I = (0,
                d.concatBytes)(F, F),
                b[$] = I
            }
            return (0,
            t.sha256)((0,
            d.concatBytes)(I, ...B))
        }
        const a = $ => $.toRawBytes(!0).slice(1)
          , E = $ => (0,
        d.numberToBytesBE)($, 32)
          , w = $ => (0,
        r.mod)($, f)
          , S = $ => (0,
        r.mod)($, i)
          , T = e.secp256k1.ProjectivePoint
          , C = ($, B, I) => T.BASE.multiplyAndAddUnsafe($, B, I);
        function N($) {
            let B = e.secp256k1.utils.normPrivateKeyToScalar($)
              , I = T.fromPrivateKey(B);
            return {
                scalar: I.hasEvenY() ? B : S(-B),
                bytes: a(I)
            }
        }
        function A($) {
            if (!P($))
                throw new Error("bad x: need 0 < x < p");
            const B = w($ * $)
              , I = w(B * $ + BigInt(7));
            let F = c(I);
            F % p !== g && (F = w(-F));
            const z = new T($,F,l);
            return z.assertValidity(),
            z
        }
        function R(...$) {
            return S((0,
            d.bytesToNumberBE)(x("BIP0340/challenge", ...$)))
        }
        function y($) {
            return N($).bytes
        }
        function k($, B, I=(0,
        s.randomBytes)(32)) {
            const F = (0,
            d.ensureBytes)("message", $)
              , {bytes: z, scalar: Y} = N(B)
              , ie = (0,
            d.ensureBytes)("auxRand", I, 32)
              , ne = E(Y ^ (0,
            d.bytesToNumberBE)(x("BIP0340/aux", ie)))
              , xe = x("BIP0340/nonce", ne, z, F)
              , W = S((0,
            d.bytesToNumberBE)(xe));
            if (W === g)
                throw new Error("sign failed: k is zero");
            const {bytes: ee, scalar: te} = N(W)
              , fe = R(ee, z, F)
              , be = new Uint8Array(64);
            if (be.set(ee, 0),
            be.set(E(S(te + fe * Y)), 32),
            !_(be, F, z))
                throw new Error("sign: Invalid signature produced");
            return be
        }
        function _($, B, I) {
            const F = (0,
            d.ensureBytes)("signature", $, 64)
              , z = (0,
            d.ensureBytes)("message", B)
              , Y = (0,
            d.ensureBytes)("publicKey", I, 32);
            try {
                const ie = A((0,
                d.bytesToNumberBE)(Y))
                  , ne = (0,
                d.bytesToNumberBE)(F.subarray(0, 32));
                if (!P(ne))
                    return !1;
                const xe = (0,
                d.bytesToNumberBE)(F.subarray(32, 64));
                if (!v(xe))
                    return !1;
                const W = R(E(ne), a(ie), z)
                  , ee = C(ie, xe, S(-W));
                return !(!ee || !ee.hasEvenY() || ee.toAffine().x !== ne)
            } catch {
                return !1
            }
        }
        e.schnorr = {
            getPublicKey: y,
            sign: k,
            verify: _,
            utils: {
                randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
                lift_x: A,
                pointToBytes: a,
                numberToBytesBE: d.numberToBytesBE,
                bytesToNumberBE: d.bytesToNumberBE,
                taggedHash: x,
                mod: r.mod
            }
        };
        const O = (0,
        h.isogenyMap)(u, [["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"], ["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", "0x0000000000000000000000000000000000000000000000000000000000000001"], ["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"], ["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", "0x0000000000000000000000000000000000000000000000000000000000000001"]].map($ => $.map(B => BigInt(B))))
          , L = (0,
        n.mapToCurveSimpleSWU)(u, {
            A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
            B: BigInt("1771"),
            Z: u.create(BigInt("-11"))
        })
          , U = (0,
        h.createHasher)(e.secp256k1.ProjectivePoint, $ => {
            const {x: B, y: I} = L(u.create($[0]));
            return O(B, I)
        }
        , {
            DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
            encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
            p: u.ORDER,
            m: 1,
            k: 128,
            expand: "xmd",
            hash: t.sha256
        });
        e.hashToCurve = U.hashToCurve,
        e.encodeToCurve = U.encodeToCurve
    }(ti)),
    ti
}
var rn = {}, ni = {}, nn = {}, la;
function qu() {
    return la || (la = 1,
    Object.defineProperty(nn, "__esModule", {
        value: !0
    }),
    nn.ZeroAddress = void 0,
    nn.ZeroAddress = "0x0000000000000000000000000000000000000000"),
    nn
}
var sn = {}, da;
function zd() {
    return da || (da = 1,
    Object.defineProperty(sn, "__esModule", {
        value: !0
    }),
    sn.ZeroHash = void 0,
    sn.ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000"),
    sn
}
var pt = {}, fa;
function Kd() {
    return fa || (fa = 1,
    Object.defineProperty(pt, "__esModule", {
        value: !0
    }),
    pt.MaxInt256 = pt.MinInt256 = pt.MaxUint256 = pt.WeiPerEther = pt.N = void 0,
    pt.N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    pt.WeiPerEther = BigInt("1000000000000000000"),
    pt.MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
    pt.MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1),
    pt.MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")),
    pt
}
var ur = {}, ha;
function Vd() {
    return ha || (ha = 1,
    Object.defineProperty(ur, "__esModule", {
        value: !0
    }),
    ur.MessagePrefix = ur.EtherSymbol = void 0,
    ur.EtherSymbol = "",
    ur.MessagePrefix = `Ethereum Signed Message:
`),
    ur
}
var pa;
function is() {
    return pa || (pa = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.MessagePrefix = e.EtherSymbol = e.MaxInt256 = e.MinInt256 = e.MaxUint256 = e.WeiPerEther = e.N = e.ZeroHash = e.ZeroAddress = void 0;
        var t = qu();
        Object.defineProperty(e, "ZeroAddress", {
            enumerable: !0,
            get: function() {
                return t.ZeroAddress
            }
        });
        var s = zd();
        Object.defineProperty(e, "ZeroHash", {
            enumerable: !0,
            get: function() {
                return s.ZeroHash
            }
        });
        var r = Kd();
        Object.defineProperty(e, "N", {
            enumerable: !0,
            get: function() {
                return r.N
            }
        }),
        Object.defineProperty(e, "WeiPerEther", {
            enumerable: !0,
            get: function() {
                return r.WeiPerEther
            }
        }),
        Object.defineProperty(e, "MaxUint256", {
            enumerable: !0,
            get: function() {
                return r.MaxUint256
            }
        }),
        Object.defineProperty(e, "MinInt256", {
            enumerable: !0,
            get: function() {
                return r.MinInt256
            }
        }),
        Object.defineProperty(e, "MaxInt256", {
            enumerable: !0,
            get: function() {
                return r.MaxInt256
            }
        });
        var n = Vd();
        Object.defineProperty(e, "EtherSymbol", {
            enumerable: !0,
            get: function() {
                return n.EtherSymbol
            }
        }),
        Object.defineProperty(e, "MessagePrefix", {
            enumerable: !0,
            get: function() {
                return n.MessagePrefix
            }
        })
    }(ni)),
    ni
}
var ba;
function zu() {
    var p, o, c, u;
    if (ba)
        return rn;
    ba = 1,
    Object.defineProperty(rn, "__esModule", {
        value: !0
    }),
    rn.Signature = void 0;
    const e = is()
      , t = Be()
      , s = BigInt(0)
      , r = BigInt(1)
      , n = BigInt(2)
      , d = BigInt(27)
      , h = BigInt(28)
      , m = BigInt(35)
      , f = {};
    function i(P) {
        return (0,
        t.zeroPadValue)((0,
        t.toBeArray)(P), 32)
    }
    const g = class g {
        constructor(v, b, x, a) {
            he(this, p);
            he(this, o);
            he(this, c);
            he(this, u);
            (0,
            t.assertPrivate)(v, f, "Signature"),
            Q(this, p, b),
            Q(this, o, x),
            Q(this, c, a),
            Q(this, u, null)
        }
        get r() {
            return j(this, p)
        }
        set r(v) {
            (0,
            t.assertArgument)((0,
            t.dataLength)(v) === 32, "invalid r", "value", v),
            Q(this, p, (0,
            t.hexlify)(v))
        }
        get s() {
            return (0,
            t.assertArgument)(parseInt(j(this, o).substring(0, 3)) < 8, "non-canonical s; use ._s", "s", j(this, o)),
            j(this, o)
        }
        set s(v) {
            (0,
            t.assertArgument)((0,
            t.dataLength)(v) === 32, "invalid s", "value", v),
            Q(this, o, (0,
            t.hexlify)(v))
        }
        get _s() {
            return j(this, o)
        }
        isValid() {
            return parseInt(j(this, o).substring(0, 3)) < 8
        }
        get v() {
            return j(this, c)
        }
        set v(v) {
            const b = (0,
            t.getNumber)(v, "value");
            (0,
            t.assertArgument)(b === 27 || b === 28, "invalid v", "v", v),
            Q(this, c, b)
        }
        get networkV() {
            return j(this, u)
        }
        get legacyChainId() {
            const v = this.networkV;
            return v == null ? null : g.getChainId(v)
        }
        get yParity() {
            return this.v === 27 ? 0 : 1
        }
        get yParityAndS() {
            const v = (0,
            t.getBytes)(this.s);
            return this.yParity && (v[0] |= 128),
            (0,
            t.hexlify)(v)
        }
        get compactSerialized() {
            return (0,
            t.concat)([this.r, this.yParityAndS])
        }
        get serialized() {
            return (0,
            t.concat)([this.r, this.s, this.yParity ? "0x1c" : "0x1b"])
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
            return `Signature { r: "${this.r}", s: "${this._s}"${this.isValid() ? "" : ', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`
        }
        clone() {
            const v = new g(f,this.r,this._s,this.v);
            return this.networkV && Q(v, u, this.networkV),
            v
        }
        toJSON() {
            const v = this.networkV;
            return {
                _type: "signature",
                networkV: v != null ? v.toString() : null,
                r: this.r,
                s: this._s,
                v: this.v
            }
        }
        static getChainId(v) {
            const b = (0,
            t.getBigInt)(v, "v");
            return b == d || b == h ? s : ((0,
            t.assertArgument)(b >= m, "invalid EIP-155 v", "v", v),
            (b - m) / n)
        }
        static getChainIdV(v, b) {
            return (0,
            t.getBigInt)(v) * n + BigInt(35 + b - 27)
        }
        static getNormalizedV(v) {
            const b = (0,
            t.getBigInt)(v);
            return b === s || b === d ? 27 : b === r || b === h ? 28 : ((0,
            t.assertArgument)(b >= m, "invalid v", "v", v),
            b & r ? 27 : 28)
        }
        static from(v) {
            function b(C, N) {
                (0,
                t.assertArgument)(C, N, "signature", v)
            }
            if (v == null)
                return new g(f,e.ZeroHash,e.ZeroHash,27);
            if (typeof v == "string") {
                const C = (0,
                t.getBytes)(v, "signature");
                if (C.length === 64) {
                    const N = (0,
                    t.hexlify)(C.slice(0, 32))
                      , A = C.slice(32, 64)
                      , R = A[0] & 128 ? 28 : 27;
                    return A[0] &= 127,
                    new g(f,N,(0,
                    t.hexlify)(A),R)
                }
                if (C.length === 65) {
                    const N = (0,
                    t.hexlify)(C.slice(0, 32))
                      , A = (0,
                    t.hexlify)(C.slice(32, 64))
                      , R = g.getNormalizedV(C[64]);
                    return new g(f,N,A,R)
                }
                b(!1, "invalid raw signature length")
            }
            if (v instanceof g)
                return v.clone();
            const x = v.r;
            b(x != null, "missing r");
            const a = i(x)
              , E = function(C, N) {
                if (C != null)
                    return i(C);
                if (N != null) {
                    b((0,
                    t.isHexString)(N, 32), "invalid yParityAndS");
                    const A = (0,
                    t.getBytes)(N);
                    return A[0] &= 127,
                    (0,
                    t.hexlify)(A)
                }
                b(!1, "missing s")
            }(v.s, v.yParityAndS)
              , {networkV: w, v: S} = function(C, N, A) {
                if (C != null) {
                    const R = (0,
                    t.getBigInt)(C);
                    return {
                        networkV: R >= m ? R : void 0,
                        v: g.getNormalizedV(R)
                    }
                }
                if (N != null)
                    return b((0,
                    t.isHexString)(N, 32), "invalid yParityAndS"),
                    {
                        v: (0,
                        t.getBytes)(N)[0] & 128 ? 28 : 27
                    };
                if (A != null) {
                    switch ((0,
                    t.getNumber)(A, "sig.yParity")) {
                    case 0:
                        return {
                            v: 27
                        };
                    case 1:
                        return {
                            v: 28
                        }
                    }
                    b(!1, "invalid yParity")
                }
                b(!1, "missing v")
            }(v.v, v.yParityAndS, v.yParity)
              , T = new g(f,a,E,S);
            return w && Q(T, u, w),
            b(v.yParity == null || (0,
            t.getNumber)(v.yParity, "sig.yParity") === T.yParity, "yParity mismatch"),
            b(v.yParityAndS == null || v.yParityAndS === T.yParityAndS, "yParityAndS mismatch"),
            T
        }
    }
    ;
    p = new WeakMap,
    o = new WeakMap,
    c = new WeakMap,
    u = new WeakMap;
    let l = g;
    return rn.Signature = l,
    rn
}
var ga;
function Jd() {
    var n;
    if (ga)
        return tn;
    ga = 1,
    Object.defineProperty(tn, "__esModule", {
        value: !0
    }),
    tn.SigningKey = void 0;
    const e = qd()
      , t = Be()
      , s = zu()
      , d = class d {
        constructor(m) {
            he(this, n);
            (0,
            t.assertArgument)((0,
            t.dataLength)(m) === 32, "invalid private key", "privateKey", "[REDACTED]"),
            Q(this, n, (0,
            t.hexlify)(m))
        }
        get privateKey() {
            return j(this, n)
        }
        get publicKey() {
            return d.computePublicKey(j(this, n))
        }
        get compressedPublicKey() {
            return d.computePublicKey(j(this, n), !0)
        }
        sign(m) {
            (0,
            t.assertArgument)((0,
            t.dataLength)(m) === 32, "invalid digest length", "digest", m);
            const f = e.secp256k1.sign((0,
            t.getBytesCopy)(m), (0,
            t.getBytesCopy)(j(this, n)), {
                lowS: !0
            });
            return s.Signature.from({
                r: (0,
                t.toBeHex)(f.r, 32),
                s: (0,
                t.toBeHex)(f.s, 32),
                v: f.recovery ? 28 : 27
            })
        }
        computeSharedSecret(m) {
            const f = d.computePublicKey(m);
            return (0,
            t.hexlify)(e.secp256k1.getSharedSecret((0,
            t.getBytesCopy)(j(this, n)), (0,
            t.getBytes)(f), !1))
        }
        static computePublicKey(m, f) {
            let i = (0,
            t.getBytes)(m, "key");
            if (i.length === 32) {
                const p = e.secp256k1.getPublicKey(i, !!f);
                return (0,
                t.hexlify)(p)
            }
            if (i.length === 64) {
                const p = new Uint8Array(65);
                p[0] = 4,
                p.set(i, 1),
                i = p
            }
            const l = e.secp256k1.ProjectivePoint.fromHex(i);
            return (0,
            t.hexlify)(l.toRawBytes(f))
        }
        static recoverPublicKey(m, f) {
            (0,
            t.assertArgument)((0,
            t.dataLength)(m) === 32, "invalid digest length", "digest", m);
            const i = s.Signature.from(f);
            let l = e.secp256k1.Signature.fromCompact((0,
            t.getBytesCopy)((0,
            t.concat)([i.r, i.s])));
            l = l.addRecoveryBit(i.yParity);
            const p = l.recoverPublicKey((0,
            t.getBytesCopy)(m));
            return (0,
            t.assertArgument)(p != null, "invalid signature for digest", "signature", f),
            "0x" + p.toHex(!1)
        }
        static addPoints(m, f, i) {
            const l = e.secp256k1.ProjectivePoint.fromHex(d.computePublicKey(m).substring(2))
              , p = e.secp256k1.ProjectivePoint.fromHex(d.computePublicKey(f).substring(2));
            return "0x" + l.add(p).toHex(!!i)
        }
    }
    ;
    n = new WeakMap;
    let r = d;
    return tn.SigningKey = r,
    tn
}
var ma;
function st() {
    return ma || (ma = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.lock = e.Signature = e.SigningKey = e.scryptSync = e.scrypt = e.pbkdf2 = e.sha512 = e.sha256 = e.ripemd160 = e.keccak256 = e.randomBytes = e.computeHmac = void 0;
        const t = Cd();
        Object.defineProperty(e, "computeHmac", {
            enumerable: !0,
            get: function() {
                return t.computeHmac
            }
        });
        const s = Rd();
        Object.defineProperty(e, "keccak256", {
            enumerable: !0,
            get: function() {
                return s.keccak256
            }
        });
        const r = jd();
        Object.defineProperty(e, "ripemd160", {
            enumerable: !0,
            get: function() {
                return r.ripemd160
            }
        });
        const n = Md();
        Object.defineProperty(e, "pbkdf2", {
            enumerable: !0,
            get: function() {
                return n.pbkdf2
            }
        });
        const d = Ld();
        Object.defineProperty(e, "randomBytes", {
            enumerable: !0,
            get: function() {
                return d.randomBytes
            }
        });
        const h = Fd();
        Object.defineProperty(e, "scrypt", {
            enumerable: !0,
            get: function() {
                return h.scrypt
            }
        }),
        Object.defineProperty(e, "scryptSync", {
            enumerable: !0,
            get: function() {
                return h.scryptSync
            }
        });
        const m = Dd();
        Object.defineProperty(e, "sha256", {
            enumerable: !0,
            get: function() {
                return m.sha256
            }
        }),
        Object.defineProperty(e, "sha512", {
            enumerable: !0,
            get: function() {
                return m.sha512
            }
        });
        var f = Jd();
        Object.defineProperty(e, "SigningKey", {
            enumerable: !0,
            get: function() {
                return f.SigningKey
            }
        });
        var i = zu();
        Object.defineProperty(e, "Signature", {
            enumerable: !0,
            get: function() {
                return i.Signature
            }
        });
        function l() {
            t.computeHmac.lock(),
            s.keccak256.lock(),
            n.pbkdf2.lock(),
            d.randomBytes.lock(),
            r.ripemd160.lock(),
            h.scrypt.lock(),
            h.scryptSync.lock(),
            m.sha256.lock(),
            m.sha512.lock(),
            d.randomBytes.lock()
        }
        e.lock = l
    }(Zs)),
    Zs
}
var ya;
function Ji() {
    if (ya)
        return er;
    ya = 1,
    Object.defineProperty(er, "__esModule", {
        value: !0
    }),
    er.getIcapAddress = er.getAddress = void 0;
    const e = st()
      , t = Be()
      , s = BigInt(0)
      , r = BigInt(36);
    function n(o) {
        o = o.toLowerCase();
        const c = o.substring(2).split("")
          , u = new Uint8Array(40);
        for (let P = 0; P < 40; P++)
            u[P] = c[P].charCodeAt(0);
        const g = (0,
        t.getBytes)((0,
        e.keccak256)(u));
        for (let P = 0; P < 40; P += 2)
            g[P >> 1] >> 4 >= 8 && (c[P] = c[P].toUpperCase()),
            (g[P >> 1] & 15) >= 8 && (c[P + 1] = c[P + 1].toUpperCase());
        return "0x" + c.join("")
    }
    const d = {};
    for (let o = 0; o < 10; o++)
        d[String(o)] = String(o);
    for (let o = 0; o < 26; o++)
        d[String.fromCharCode(65 + o)] = String(10 + o);
    const h = 15;
    function m(o) {
        o = o.toUpperCase(),
        o = o.substring(4) + o.substring(0, 2) + "00";
        let c = o.split("").map(g => d[g]).join("");
        for (; c.length >= h; ) {
            let g = c.substring(0, h);
            c = parseInt(g, 10) % 97 + c.substring(g.length)
        }
        let u = String(98 - parseInt(c, 10) % 97);
        for (; u.length < 2; )
            u = "0" + u;
        return u
    }
    const f = function() {
        const o = {};
        for (let c = 0; c < 36; c++) {
            const u = "0123456789abcdefghijklmnopqrstuvwxyz"[c];
            o[u] = BigInt(c)
        }
        return o
    }();
    function i(o) {
        o = o.toLowerCase();
        let c = s;
        for (let u = 0; u < o.length; u++)
            c = c * r + f[o[u]];
        return c
    }
    function l(o) {
        if ((0,
        t.assertArgument)(typeof o == "string", "invalid address", "address", o),
        o.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
            o.startsWith("0x") || (o = "0x" + o);
            const c = n(o);
            return (0,
            t.assertArgument)(!o.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || c === o, "bad address checksum", "address", o),
            c
        }
        if (o.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
            (0,
            t.assertArgument)(o.substring(2, 4) === m(o), "bad icap checksum", "address", o);
            let c = i(o.substring(4)).toString(16);
            for (; c.length < 40; )
                c = "0" + c;
            return n("0x" + c)
        }
        (0,
        t.assertArgument)(!1, "invalid address", "address", o)
    }
    er.getAddress = l;
    function p(o) {
        let c = BigInt(l(o)).toString(36).toUpperCase();
        for (; c.length < 30; )
            c = "0" + c;
        return "XE" + m("XE00" + c) + c
    }
    return er.getIcapAddress = p,
    er
}
var lr = {}, xa;
function Qd() {
    if (xa)
        return lr;
    xa = 1,
    Object.defineProperty(lr, "__esModule", {
        value: !0
    }),
    lr.getCreate2Address = lr.getCreateAddress = void 0;
    const e = st()
      , t = Be()
      , s = Ji();
    function r(d) {
        const h = (0,
        s.getAddress)(d.from);
        let f = (0,
        t.getBigInt)(d.nonce, "tx.nonce").toString(16);
        return f === "0" ? f = "0x" : f.length % 2 ? f = "0x0" + f : f = "0x" + f,
        (0,
        s.getAddress)((0,
        t.dataSlice)((0,
        e.keccak256)((0,
        t.encodeRlp)([h, f])), 12))
    }
    lr.getCreateAddress = r;
    function n(d, h, m) {
        const f = (0,
        s.getAddress)(d)
          , i = (0,
        t.getBytes)(h, "salt")
          , l = (0,
        t.getBytes)(m, "initCodeHash");
        return (0,
        t.assertArgument)(i.length === 32, "salt must be 32 bytes", "salt", h),
        (0,
        t.assertArgument)(l.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", m),
        (0,
        s.getAddress)((0,
        t.dataSlice)((0,
        e.keccak256)((0,
        t.concat)(["0xff", f, i, l])), 12))
    }
    return lr.getCreate2Address = n,
    lr
}
var Mt = {}, wa;
function Wd() {
    if (wa)
        return Mt;
    wa = 1,
    Object.defineProperty(Mt, "__esModule", {
        value: !0
    }),
    Mt.resolveAddress = Mt.isAddress = Mt.isAddressable = void 0;
    const e = Be()
      , t = Ji();
    function s(h) {
        return h && typeof h.getAddress == "function"
    }
    Mt.isAddressable = s;
    function r(h) {
        try {
            return (0,
            t.getAddress)(h),
            !0
        } catch {}
        return !1
    }
    Mt.isAddress = r;
    async function n(h, m) {
        const f = await m;
        return (f == null || f === "0x0000000000000000000000000000000000000000") && ((0,
        e.assert)(typeof h != "string", "unconfigured name", "UNCONFIGURED_NAME", {
            value: h
        }),
        (0,
        e.assertArgument)(!1, "invalid AddressLike value; did not resolve to a value address", "target", h)),
        (0,
        t.getAddress)(f)
    }
    function d(h, m) {
        if (typeof h == "string")
            return h.match(/^0x[0-9a-f]{40}$/i) ? (0,
            t.getAddress)(h) : ((0,
            e.assert)(m != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
                operation: "resolveName"
            }),
            n(h, m.resolveName(h)));
        if (s(h))
            return n(h, h.getAddress());
        if (h && typeof h.then == "function")
            return n(h, h);
        (0,
        e.assertArgument)(!1, "unsupported addressable value", "target", h)
    }
    return Mt.resolveAddress = d,
    Mt
}
var Aa;
function tt() {
    return Aa || (Aa = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.resolveAddress = e.isAddress = e.isAddressable = e.getCreate2Address = e.getCreateAddress = e.getIcapAddress = e.getAddress = void 0;
        var t = Ji();
        Object.defineProperty(e, "getAddress", {
            enumerable: !0,
            get: function() {
                return t.getAddress
            }
        }),
        Object.defineProperty(e, "getIcapAddress", {
            enumerable: !0,
            get: function() {
                return t.getIcapAddress
            }
        });
        var s = Qd();
        Object.defineProperty(e, "getCreateAddress", {
            enumerable: !0,
            get: function() {
                return s.getCreateAddress
            }
        }),
        Object.defineProperty(e, "getCreate2Address", {
            enumerable: !0,
            get: function() {
                return s.getCreate2Address
            }
        });
        var r = Wd();
        Object.defineProperty(e, "isAddressable", {
            enumerable: !0,
            get: function() {
                return r.isAddressable
            }
        }),
        Object.defineProperty(e, "isAddress", {
            enumerable: !0,
            get: function() {
                return r.isAddress
            }
        }),
        Object.defineProperty(e, "resolveAddress", {
            enumerable: !0,
            get: function() {
                return r.resolveAddress
            }
        })
    }(Ys)),
    Ys
}
var on = {}, va;
function $t() {
    var h;
    if (va)
        return on;
    va = 1,
    Object.defineProperty(on, "__esModule", {
        value: !0
    }),
    on.Typed = void 0;
    const e = Be()
      , t = {};
    function s(f, i) {
        let l = !1;
        return i < 0 && (l = !0,
        i *= -1),
        new d(t,`${l ? "" : "u"}int${i}`,f,{
            signed: l,
            width: i
        })
    }
    function r(f, i) {
        return new d(t,`bytes${i || ""}`,f,{
            size: i
        })
    }
    const n = Symbol.for("_ethers_typed")
      , m = class m {
        constructor(i, l, p, o) {
            ue(this, "type");
            ue(this, "value");
            he(this, h);
            ue(this, "_typedSymbol");
            o == null && (o = null),
            (0,
            e.assertPrivate)(t, i, "Typed"),
            (0,
            e.defineProperties)(this, {
                _typedSymbol: n,
                type: l,
                value: p
            }),
            Q(this, h, o),
            this.format()
        }
        format() {
            if (this.type === "array")
                throw new Error("");
            if (this.type === "dynamicArray")
                throw new Error("");
            return this.type === "tuple" ? `tuple(${this.value.map(i => i.format()).join(",")})` : this.type
        }
        defaultValue() {
            return 0
        }
        minValue() {
            return 0
        }
        maxValue() {
            return 0
        }
        isBigInt() {
            return !!this.type.match(/^u?int[0-9]+$/)
        }
        isData() {
            return this.type.startsWith("bytes")
        }
        isString() {
            return this.type === "string"
        }
        get tupleName() {
            if (this.type !== "tuple")
                throw TypeError("not a tuple");
            return j(this, h)
        }
        get arrayLength() {
            if (this.type !== "array")
                throw TypeError("not an array");
            return j(this, h) === !0 ? -1 : j(this, h) === !1 ? this.value.length : null
        }
        static from(i, l) {
            return new m(t,i,l)
        }
        static uint8(i) {
            return s(i, 8)
        }
        static uint16(i) {
            return s(i, 16)
        }
        static uint24(i) {
            return s(i, 24)
        }
        static uint32(i) {
            return s(i, 32)
        }
        static uint40(i) {
            return s(i, 40)
        }
        static uint48(i) {
            return s(i, 48)
        }
        static uint56(i) {
            return s(i, 56)
        }
        static uint64(i) {
            return s(i, 64)
        }
        static uint72(i) {
            return s(i, 72)
        }
        static uint80(i) {
            return s(i, 80)
        }
        static uint88(i) {
            return s(i, 88)
        }
        static uint96(i) {
            return s(i, 96)
        }
        static uint104(i) {
            return s(i, 104)
        }
        static uint112(i) {
            return s(i, 112)
        }
        static uint120(i) {
            return s(i, 120)
        }
        static uint128(i) {
            return s(i, 128)
        }
        static uint136(i) {
            return s(i, 136)
        }
        static uint144(i) {
            return s(i, 144)
        }
        static uint152(i) {
            return s(i, 152)
        }
        static uint160(i) {
            return s(i, 160)
        }
        static uint168(i) {
            return s(i, 168)
        }
        static uint176(i) {
            return s(i, 176)
        }
        static uint184(i) {
            return s(i, 184)
        }
        static uint192(i) {
            return s(i, 192)
        }
        static uint200(i) {
            return s(i, 200)
        }
        static uint208(i) {
            return s(i, 208)
        }
        static uint216(i) {
            return s(i, 216)
        }
        static uint224(i) {
            return s(i, 224)
        }
        static uint232(i) {
            return s(i, 232)
        }
        static uint240(i) {
            return s(i, 240)
        }
        static uint248(i) {
            return s(i, 248)
        }
        static uint256(i) {
            return s(i, 256)
        }
        static uint(i) {
            return s(i, 256)
        }
        static int8(i) {
            return s(i, -8)
        }
        static int16(i) {
            return s(i, -16)
        }
        static int24(i) {
            return s(i, -24)
        }
        static int32(i) {
            return s(i, -32)
        }
        static int40(i) {
            return s(i, -40)
        }
        static int48(i) {
            return s(i, -48)
        }
        static int56(i) {
            return s(i, -56)
        }
        static int64(i) {
            return s(i, -64)
        }
        static int72(i) {
            return s(i, -72)
        }
        static int80(i) {
            return s(i, -80)
        }
        static int88(i) {
            return s(i, -88)
        }
        static int96(i) {
            return s(i, -96)
        }
        static int104(i) {
            return s(i, -104)
        }
        static int112(i) {
            return s(i, -112)
        }
        static int120(i) {
            return s(i, -120)
        }
        static int128(i) {
            return s(i, -128)
        }
        static int136(i) {
            return s(i, -136)
        }
        static int144(i) {
            return s(i, -144)
        }
        static int152(i) {
            return s(i, -152)
        }
        static int160(i) {
            return s(i, -160)
        }
        static int168(i) {
            return s(i, -168)
        }
        static int176(i) {
            return s(i, -176)
        }
        static int184(i) {
            return s(i, -184)
        }
        static int192(i) {
            return s(i, -192)
        }
        static int200(i) {
            return s(i, -200)
        }
        static int208(i) {
            return s(i, -208)
        }
        static int216(i) {
            return s(i, -216)
        }
        static int224(i) {
            return s(i, -224)
        }
        static int232(i) {
            return s(i, -232)
        }
        static int240(i) {
            return s(i, -240)
        }
        static int248(i) {
            return s(i, -248)
        }
        static int256(i) {
            return s(i, -256)
        }
        static int(i) {
            return s(i, -256)
        }
        static bytes1(i) {
            return r(i, 1)
        }
        static bytes2(i) {
            return r(i, 2)
        }
        static bytes3(i) {
            return r(i, 3)
        }
        static bytes4(i) {
            return r(i, 4)
        }
        static bytes5(i) {
            return r(i, 5)
        }
        static bytes6(i) {
            return r(i, 6)
        }
        static bytes7(i) {
            return r(i, 7)
        }
        static bytes8(i) {
            return r(i, 8)
        }
        static bytes9(i) {
            return r(i, 9)
        }
        static bytes10(i) {
            return r(i, 10)
        }
        static bytes11(i) {
            return r(i, 11)
        }
        static bytes12(i) {
            return r(i, 12)
        }
        static bytes13(i) {
            return r(i, 13)
        }
        static bytes14(i) {
            return r(i, 14)
        }
        static bytes15(i) {
            return r(i, 15)
        }
        static bytes16(i) {
            return r(i, 16)
        }
        static bytes17(i) {
            return r(i, 17)
        }
        static bytes18(i) {
            return r(i, 18)
        }
        static bytes19(i) {
            return r(i, 19)
        }
        static bytes20(i) {
            return r(i, 20)
        }
        static bytes21(i) {
            return r(i, 21)
        }
        static bytes22(i) {
            return r(i, 22)
        }
        static bytes23(i) {
            return r(i, 23)
        }
        static bytes24(i) {
            return r(i, 24)
        }
        static bytes25(i) {
            return r(i, 25)
        }
        static bytes26(i) {
            return r(i, 26)
        }
        static bytes27(i) {
            return r(i, 27)
        }
        static bytes28(i) {
            return r(i, 28)
        }
        static bytes29(i) {
            return r(i, 29)
        }
        static bytes30(i) {
            return r(i, 30)
        }
        static bytes31(i) {
            return r(i, 31)
        }
        static bytes32(i) {
            return r(i, 32)
        }
        static address(i) {
            return new m(t,"address",i)
        }
        static bool(i) {
            return new m(t,"bool",!!i)
        }
        static bytes(i) {
            return new m(t,"bytes",i)
        }
        static string(i) {
            return new m(t,"string",i)
        }
        static array(i, l) {
            throw new Error("not implemented yet")
        }
        static tuple(i, l) {
            throw new Error("not implemented yet")
        }
        static overrides(i) {
            return new m(t,"overrides",Object.assign({}, i))
        }
        static isTyped(i) {
            return i && typeof i == "object" && "_typedSymbol"in i && i._typedSymbol === n
        }
        static dereference(i, l) {
            if (m.isTyped(i)) {
                if (i.type !== l)
                    throw new Error(`invalid type: expecetd ${l}, got ${i.type}`);
                return i.value
            }
            return i
        }
    }
    ;
    h = new WeakMap;
    let d = m;
    return on.Typed = d,
    on
}
var Ea;
function Yd() {
    if (Ea)
        return Vr;
    Ea = 1,
    Object.defineProperty(Vr, "__esModule", {
        value: !0
    }),
    Vr.AddressCoder = void 0;
    const e = tt()
      , t = ns()
      , s = $t()
      , r = Bt();
    class n extends r.Coder {
        constructor(h) {
            super("address", "address", h, !1)
        }
        defaultValue() {
            return "0x0000000000000000000000000000000000000000"
        }
        encode(h, m) {
            let f = s.Typed.dereference(m, "string");
            try {
                f = (0,
                e.getAddress)(f)
            } catch (i) {
                return this._throwError(i.message, m)
            }
            return h.writeValue(f)
        }
        decode(h) {
            return (0,
            e.getAddress)((0,
            t.toBeHex)(h.readValue(), 20))
        }
    }
    return Vr.AddressCoder = n,
    Vr
}
var Lt = {}, an = {}, Pa;
function Zd() {
    if (Pa)
        return an;
    Pa = 1,
    Object.defineProperty(an, "__esModule", {
        value: !0
    }),
    an.AnonymousCoder = void 0;
    const e = Bt();
    class t extends e.Coder {
        constructor(n) {
            super(n.name, n.type, "_", n.dynamic);
            ue(this, "coder");
            this.coder = n
        }
        defaultValue() {
            return this.coder.defaultValue()
        }
        encode(n, d) {
            return this.coder.encode(n, d)
        }
        decode(n) {
            return this.coder.decode(n)
        }
    }
    return an.AnonymousCoder = t,
    an
}
var ka;
function Ku() {
    if (ka)
        return Lt;
    ka = 1,
    Object.defineProperty(Lt, "__esModule", {
        value: !0
    }),
    Lt.ArrayCoder = Lt.unpack = Lt.pack = void 0;
    const e = Be()
      , t = $t()
      , s = Bt()
      , r = Zd();
    function n(m, f, i) {
        let l = [];
        if (Array.isArray(i))
            l = i;
        else if (i && typeof i == "object") {
            let g = {};
            l = f.map(P => {
                const v = P.localName;
                return (0,
                e.assert)(v, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
                    argument: "values",
                    info: {
                        coder: P
                    },
                    value: i
                }),
                (0,
                e.assert)(!g[v], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
                    argument: "values",
                    info: {
                        coder: P
                    },
                    value: i
                }),
                g[v] = !0,
                i[v]
            }
            )
        } else
            (0,
            e.assertArgument)(!1, "invalid tuple value", "tuple", i);
        (0,
        e.assertArgument)(f.length === l.length, "types/value length mismatch", "tuple", i);
        let p = new s.Writer
          , o = new s.Writer
          , c = [];
        f.forEach( (g, P) => {
            let v = l[P];
            if (g.dynamic) {
                let b = o.length;
                g.encode(o, v);
                let x = p.writeUpdatableValue();
                c.push(a => {
                    x(a + b)
                }
                )
            } else
                g.encode(p, v)
        }
        ),
        c.forEach(g => {
            g(p.length)
        }
        );
        let u = m.appendWriter(p);
        return u += m.appendWriter(o),
        u
    }
    Lt.pack = n;
    function d(m, f) {
        let i = []
          , l = []
          , p = m.subReader(0);
        return f.forEach(o => {
            let c = null;
            if (o.dynamic) {
                let u = m.readIndex()
                  , g = p.subReader(u);
                try {
                    c = o.decode(g)
                } catch (P) {
                    if ((0,
                    e.isError)(P, "BUFFER_OVERRUN"))
                        throw P;
                    c = P,
                    c.baseType = o.name,
                    c.name = o.localName,
                    c.type = o.type
                }
            } else
                try {
                    c = o.decode(m)
                } catch (u) {
                    if ((0,
                    e.isError)(u, "BUFFER_OVERRUN"))
                        throw u;
                    c = u,
                    c.baseType = o.name,
                    c.name = o.localName,
                    c.type = o.type
                }
            if (c == null)
                throw new Error("investigate");
            i.push(c),
            l.push(o.localName || null)
        }
        ),
        s.Result.fromItems(i, l)
    }
    Lt.unpack = d;
    class h extends s.Coder {
        constructor(i, l, p) {
            const o = i.type + "[" + (l >= 0 ? l : "") + "]"
              , c = l === -1 || i.dynamic;
            super("array", o, p, c);
            ue(this, "coder");
            ue(this, "length");
            (0,
            e.defineProperties)(this, {
                coder: i,
                length: l
            })
        }
        defaultValue() {
            const i = this.coder.defaultValue()
              , l = [];
            for (let p = 0; p < this.length; p++)
                l.push(i);
            return l
        }
        encode(i, l) {
            const p = t.Typed.dereference(l, "array");
            Array.isArray(p) || this._throwError("expected array value", p);
            let o = this.length;
            o === -1 && (o = p.length,
            i.writeValue(p.length)),
            (0,
            e.assertArgumentCount)(p.length, o, "coder array" + (this.localName ? " " + this.localName : ""));
            let c = [];
            for (let u = 0; u < p.length; u++)
                c.push(this.coder);
            return n(i, c, p)
        }
        decode(i) {
            let l = this.length;
            l === -1 && (l = i.readIndex(),
            (0,
            e.assert)(l * s.WordSize <= i.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
                buffer: i.bytes,
                offset: l * s.WordSize,
                length: i.dataLength
            }));
            let p = [];
            for (let o = 0; o < l; o++)
                p.push(new r.AnonymousCoder(this.coder));
            return d(i, p)
        }
    }
    return Lt.ArrayCoder = h,
    Lt
}
var cn = {}, _a;
function Xd() {
    if (_a)
        return cn;
    _a = 1,
    Object.defineProperty(cn, "__esModule", {
        value: !0
    }),
    cn.BooleanCoder = void 0;
    const e = $t()
      , t = Bt();
    class s extends t.Coder {
        constructor(n) {
            super("bool", "bool", n, !1)
        }
        defaultValue() {
            return !1
        }
        encode(n, d) {
            const h = e.Typed.dereference(d, "bool");
            return n.writeValue(h ? 1 : 0)
        }
        decode(n) {
            return !!n.readValue()
        }
    }
    return cn.BooleanCoder = s,
    cn
}
var dr = {}, Ta;
function Vu() {
    if (Ta)
        return dr;
    Ta = 1,
    Object.defineProperty(dr, "__esModule", {
        value: !0
    }),
    dr.BytesCoder = dr.DynamicBytesCoder = void 0;
    const e = Be()
      , t = Bt();
    class s extends t.Coder {
        constructor(d, h) {
            super(d, d, h, !0)
        }
        defaultValue() {
            return "0x"
        }
        encode(d, h) {
            h = (0,
            e.getBytesCopy)(h);
            let m = d.writeValue(h.length);
            return m += d.writeBytes(h),
            m
        }
        decode(d) {
            return d.readBytes(d.readIndex(), !0)
        }
    }
    dr.DynamicBytesCoder = s;
    class r extends s {
        constructor(d) {
            super("bytes", d)
        }
        decode(d) {
            return (0,
            e.hexlify)(super.decode(d))
        }
    }
    return dr.BytesCoder = r,
    dr
}
var un = {}, Oa;
function ef() {
    if (Oa)
        return un;
    Oa = 1,
    Object.defineProperty(un, "__esModule", {
        value: !0
    }),
    un.FixedBytesCoder = void 0;
    const e = Be()
      , t = $t()
      , s = Bt();
    class r extends s.Coder {
        constructor(h, m) {
            let f = "bytes" + String(h);
            super(f, f, m, !1);
            ue(this, "size");
            (0,
            e.defineProperties)(this, {
                size: h
            }, {
                size: "number"
            })
        }
        defaultValue() {
            return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2)
        }
        encode(h, m) {
            let f = (0,
            e.getBytesCopy)(t.Typed.dereference(m, this.type));
            return f.length !== this.size && this._throwError("incorrect data length", m),
            h.writeBytes(f)
        }
        decode(h) {
            return (0,
            e.hexlify)(h.readBytes(this.size))
        }
    }
    return un.FixedBytesCoder = r,
    un
}
var ln = {}, Ba;
function tf() {
    if (Ba)
        return ln;
    Ba = 1,
    Object.defineProperty(ln, "__esModule", {
        value: !0
    }),
    ln.NullCoder = void 0;
    const e = Bt()
      , t = new Uint8Array([]);
    class s extends e.Coder {
        constructor(n) {
            super("null", "", n, !1)
        }
        defaultValue() {
            return null
        }
        encode(n, d) {
            return d != null && this._throwError("not null", d),
            n.writeBytes(t)
        }
        decode(n) {
            return n.readBytes(0),
            null
        }
    }
    return ln.NullCoder = s,
    ln
}
var dn = {}, Sa;
function rf() {
    if (Sa)
        return dn;
    Sa = 1,
    Object.defineProperty(dn, "__esModule", {
        value: !0
    }),
    dn.NumberCoder = void 0;
    const e = Be()
      , t = $t()
      , s = Bt()
      , r = BigInt(0)
      , n = BigInt(1)
      , d = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    class h extends s.Coder {
        constructor(i, l, p) {
            const o = (l ? "int" : "uint") + i * 8;
            super(o, o, p, !1);
            ue(this, "size");
            ue(this, "signed");
            (0,
            e.defineProperties)(this, {
                size: i,
                signed: l
            }, {
                size: "number",
                signed: "boolean"
            })
        }
        defaultValue() {
            return 0
        }
        encode(i, l) {
            let p = (0,
            e.getBigInt)(t.Typed.dereference(l, this.type))
              , o = (0,
            e.mask)(d, s.WordSize * 8);
            if (this.signed) {
                let c = (0,
                e.mask)(o, this.size * 8 - 1);
                (p > c || p < -(c + n)) && this._throwError("value out-of-bounds", l),
                p = (0,
                e.toTwos)(p, 8 * s.WordSize)
            } else
                (p < r || p > (0,
                e.mask)(o, this.size * 8)) && this._throwError("value out-of-bounds", l);
            return i.writeValue(p)
        }
        decode(i) {
            let l = (0,
            e.mask)(i.readValue(), this.size * 8);
            return this.signed && (l = (0,
            e.fromTwos)(l, this.size * 8)),
            l
        }
    }
    return dn.NumberCoder = h,
    dn
}
var fn = {}, Ca;
function nf() {
    if (Ca)
        return fn;
    Ca = 1,
    Object.defineProperty(fn, "__esModule", {
        value: !0
    }),
    fn.StringCoder = void 0;
    const e = qi()
      , t = $t()
      , s = Vu();
    class r extends s.DynamicBytesCoder {
        constructor(d) {
            super("string", d)
        }
        defaultValue() {
            return ""
        }
        encode(d, h) {
            return super.encode(d, (0,
            e.toUtf8Bytes)(t.Typed.dereference(h, "string")))
        }
        decode(d) {
            return (0,
            e.toUtf8String)(super.decode(d))
        }
    }
    return fn.StringCoder = r,
    fn
}
var hn = {}, Na;
function sf() {
    if (Na)
        return hn;
    Na = 1,
    Object.defineProperty(hn, "__esModule", {
        value: !0
    }),
    hn.TupleCoder = void 0;
    const e = Tr()
      , t = $t()
      , s = Bt()
      , r = Ku();
    class n extends s.Coder {
        constructor(m, f) {
            let i = !1;
            const l = [];
            m.forEach(o => {
                o.dynamic && (i = !0),
                l.push(o.type)
            }
            );
            const p = "tuple(" + l.join(",") + ")";
            super("tuple", p, f, i);
            ue(this, "coders");
            (0,
            e.defineProperties)(this, {
                coders: Object.freeze(m.slice())
            })
        }
        defaultValue() {
            const m = [];
            this.coders.forEach(i => {
                m.push(i.defaultValue())
            }
            );
            const f = this.coders.reduce( (i, l) => {
                const p = l.localName;
                return p && (i[p] || (i[p] = 0),
                i[p]++),
                i
            }
            , {});
            return this.coders.forEach( (i, l) => {
                let p = i.localName;
                !p || f[p] !== 1 || (p === "length" && (p = "_length"),
                m[p] == null && (m[p] = m[l]))
            }
            ),
            Object.freeze(m)
        }
        encode(m, f) {
            const i = t.Typed.dereference(f, "tuple");
            return (0,
            r.pack)(m, this.coders, i)
        }
        decode(m) {
            return (0,
            r.unpack)(m, this.coders)
        }
    }
    return hn.TupleCoder = n,
    hn
}
var Xe = {}, si = {}, fr = {}, ii = {}, pn = {}, Ra;
function Ju() {
    if (Ra)
        return pn;
    Ra = 1,
    Object.defineProperty(pn, "__esModule", {
        value: !0
    }),
    pn.accessListify = void 0;
    const e = tt()
      , t = Be();
    function s(n, d) {
        return {
            address: (0,
            e.getAddress)(n),
            storageKeys: d.map( (h, m) => ((0,
            t.assertArgument)((0,
            t.isHexString)(h, 32), "invalid slot", `storageKeys[${m}]`, h),
            h.toLowerCase()))
        }
    }
    function r(n) {
        if (Array.isArray(n))
            return n.map( (h, m) => Array.isArray(h) ? ((0,
            t.assertArgument)(h.length === 2, "invalid slot set", `value[${m}]`, h),
            s(h[0], h[1])) : ((0,
            t.assertArgument)(h != null && typeof h == "object", "invalid address-slot set", "value", n),
            s(h.address, h.storageKeys)));
        (0,
        t.assertArgument)(n != null && typeof n == "object", "invalid access list", "value", n);
        const d = Object.keys(n).map(h => {
            const m = n[h].reduce( (f, i) => (f[i] = !0,
            f), {});
            return s(h, Object.keys(m).sort())
        }
        );
        return d.sort( (h, m) => h.address.localeCompare(m.address)),
        d
    }
    return pn.accessListify = r,
    pn
}
var bn = {}, Ia;
function Qu() {
    if (Ia)
        return bn;
    Ia = 1,
    Object.defineProperty(bn, "__esModule", {
        value: !0
    }),
    bn.authorizationify = void 0;
    const e = tt()
      , t = st()
      , s = Be();
    function r(n) {
        return {
            address: (0,
            e.getAddress)(n.address),
            nonce: (0,
            s.getBigInt)(n.nonce != null ? n.nonce : 0),
            chainId: (0,
            s.getBigInt)(n.chainId != null ? n.chainId : 0),
            signature: t.Signature.from(n.signature)
        }
    }
    return bn.authorizationify = r,
    bn
}
var hr = {}, ja;
function Wu() {
    if (ja)
        return hr;
    ja = 1,
    Object.defineProperty(hr, "__esModule", {
        value: !0
    }),
    hr.recoverAddress = hr.computeAddress = void 0;
    const e = tt()
      , t = st();
    function s(n) {
        let d;
        return typeof n == "string" ? d = t.SigningKey.computePublicKey(n, !1) : d = n.publicKey,
        (0,
        e.getAddress)((0,
        t.keccak256)("0x" + d.substring(4)).substring(26))
    }
    hr.computeAddress = s;
    function r(n, d) {
        return s(t.SigningKey.recoverPublicKey(n, d))
    }
    return hr.recoverAddress = r,
    hr
}
var gn = {}, Ma;
function of() {
    var I, F, z, Y, ie, ne, xe, W, ee, te, fe, be, le, re, M, K, V, oe, hs;
    if (Ma)
        return gn;
    Ma = 1,
    Object.defineProperty(gn, "__esModule", {
        value: !0
    }),
    gn.Transaction = void 0;
    const e = tt()
      , t = qu()
      , s = st()
      , r = Be()
      , n = Ju()
      , d = Qu()
      , h = Wu()
      , m = BigInt(0)
      , f = BigInt(2)
      , i = BigInt(27)
      , l = BigInt(28)
      , p = BigInt(35)
      , o = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
      , c = 4096 * 32;
    function u(se) {
        return {
            blobToKzgCommitment: q => {
                if ("computeBlobProof"in se) {
                    if ("blobToKzgCommitment"in se && typeof se.blobToKzgCommitment == "function")
                        return (0,
                        r.getBytes)(se.blobToKzgCommitment((0,
                        r.hexlify)(q)))
                } else if ("blobToKzgCommitment"in se && typeof se.blobToKzgCommitment == "function")
                    return (0,
                    r.getBytes)(se.blobToKzgCommitment(q));
                if ("blobToKZGCommitment"in se && typeof se.blobToKZGCommitment == "function")
                    return (0,
                    r.getBytes)(se.blobToKZGCommitment((0,
                    r.hexlify)(q)));
                (0,
                r.assertArgument)(!1, "unsupported KZG library", "kzg", se)
            }
            ,
            computeBlobKzgProof: (q, ae) => {
                if ("computeBlobProof"in se && typeof se.computeBlobProof == "function")
                    return (0,
                    r.getBytes)(se.computeBlobProof((0,
                    r.hexlify)(q), (0,
                    r.hexlify)(ae)));
                if ("computeBlobKzgProof"in se && typeof se.computeBlobKzgProof == "function")
                    return se.computeBlobKzgProof(q, ae);
                if ("computeBlobKZGProof"in se && typeof se.computeBlobKZGProof == "function")
                    return (0,
                    r.getBytes)(se.computeBlobKZGProof((0,
                    r.hexlify)(q), (0,
                    r.hexlify)(ae)));
                (0,
                r.assertArgument)(!1, "unsupported KZG library", "kzg", se)
            }
        }
    }
    function g(se, H) {
        let G = se.toString(16);
        for (; G.length < 2; )
            G = "0" + G;
        return G += (0,
        s.sha256)(H).substring(4),
        "0x" + G
    }
    function P(se) {
        return se === "0x" ? null : (0,
        e.getAddress)(se)
    }
    function v(se, H) {
        try {
            return (0,
            n.accessListify)(se)
        } catch (G) {
            (0,
            r.assertArgument)(!1, G.message, H, se)
        }
    }
    function b(se, H) {
        try {
            if (!Array.isArray(se))
                throw new Error("authorizationList: invalid array");
            const G = [];
            for (let q = 0; q < se.length; q++) {
                const ae = se[q];
                if (!Array.isArray(ae))
                    throw new Error(`authorization[${q}]: invalid array`);
                if (ae.length !== 6)
                    throw new Error(`authorization[${q}]: wrong length`);
                if (!ae[1])
                    throw new Error(`authorization[${q}]: null address`);
                G.push({
                    address: P(ae[1]),
                    nonce: a(ae[2], "nonce"),
                    chainId: a(ae[0], "chainId"),
                    signature: s.Signature.from({
                        yParity: x(ae[3], "yParity"),
                        r: (0,
                        r.zeroPadValue)(ae[4], 32),
                        s: (0,
                        r.zeroPadValue)(ae[5], 32)
                    })
                })
            }
            return G
        } catch (G) {
            (0,
            r.assertArgument)(!1, G.message, H, se)
        }
    }
    function x(se, H) {
        return se === "0x" ? 0 : (0,
        r.getNumber)(se, H)
    }
    function a(se, H) {
        if (se === "0x")
            return m;
        const G = (0,
        r.getBigInt)(se, H);
        return (0,
        r.assertArgument)(G <= o, "value exceeds uint size", H, G),
        G
    }
    function E(se, H) {
        const G = (0,
        r.getBigInt)(se, "value")
          , q = (0,
        r.toBeArray)(G);
        return (0,
        r.assertArgument)(q.length <= 32, "value too large", `tx.${H}`, G),
        q
    }
    function w(se) {
        return (0,
        n.accessListify)(se).map(H => [H.address, H.storageKeys])
    }
    function S(se) {
        return se.map(H => [E(H.chainId, "chainId"), H.address, E(H.nonce, "nonce"), E(H.signature.yParity, "yParity"), (0,
        r.toBeArray)(H.signature.r), (0,
        r.toBeArray)(H.signature.s)])
    }
    function T(se, H) {
        (0,
        r.assertArgument)(Array.isArray(se), `invalid ${H}`, "value", se);
        for (let G = 0; G < se.length; G++)
            (0,
            r.assertArgument)((0,
            r.isHexString)(se[G], 32), "invalid ${ param } hash", `value[${G}]`, se[G]);
        return se
    }
    function C(se) {
        const H = (0,
        r.decodeRlp)(se);
        (0,
        r.assertArgument)(Array.isArray(H) && (H.length === 9 || H.length === 6), "invalid field count for legacy transaction", "data", se);
        const G = {
            type: 0,
            nonce: x(H[0], "nonce"),
            gasPrice: a(H[1], "gasPrice"),
            gasLimit: a(H[2], "gasLimit"),
            to: P(H[3]),
            value: a(H[4], "value"),
            data: (0,
            r.hexlify)(H[5]),
            chainId: m
        };
        if (H.length === 6)
            return G;
        const q = a(H[6], "v")
          , ae = a(H[7], "r")
          , Z = a(H[8], "s");
        if (ae === m && Z === m)
            G.chainId = q;
        else {
            let J = (q - p) / f;
            J < m && (J = m),
            G.chainId = J,
            (0,
            r.assertArgument)(J !== m || q === i || q === l, "non-canonical legacy v", "v", H[6]),
            G.signature = s.Signature.from({
                r: (0,
                r.zeroPadValue)(H[7], 32),
                s: (0,
                r.zeroPadValue)(H[8], 32),
                v: q
            })
        }
        return G
    }
    function N(se, H) {
        const G = [E(se.nonce, "nonce"), E(se.gasPrice || 0, "gasPrice"), E(se.gasLimit, "gasLimit"), se.to || "0x", E(se.value, "value"), se.data];
        let q = m;
        if (se.chainId != m)
            q = (0,
            r.getBigInt)(se.chainId, "tx.chainId"),
            (0,
            r.assertArgument)(!H || H.networkV == null || H.legacyChainId === q, "tx.chainId/sig.v mismatch", "sig", H);
        else if (se.signature) {
            const Z = se.signature.legacyChainId;
            Z != null && (q = Z)
        }
        if (!H)
            return q !== m && (G.push((0,
            r.toBeArray)(q)),
            G.push("0x"),
            G.push("0x")),
            (0,
            r.encodeRlp)(G);
        let ae = BigInt(27 + H.yParity);
        return q !== m ? ae = s.Signature.getChainIdV(q, H.v) : BigInt(H.v) !== ae && (0,
        r.assertArgument)(!1, "tx.chainId/sig.v mismatch", "sig", H),
        G.push((0,
        r.toBeArray)(ae)),
        G.push((0,
        r.toBeArray)(H.r)),
        G.push((0,
        r.toBeArray)(H.s)),
        (0,
        r.encodeRlp)(G)
    }
    function A(se, H) {
        let G;
        try {
            if (G = x(H[0], "yParity"),
            G !== 0 && G !== 1)
                throw new Error("bad yParity")
        } catch {
            (0,
            r.assertArgument)(!1, "invalid yParity", "yParity", H[0])
        }
        const q = (0,
        r.zeroPadValue)(H[1], 32)
          , ae = (0,
        r.zeroPadValue)(H[2], 32)
          , Z = s.Signature.from({
            r: q,
            s: ae,
            yParity: G
        });
        se.signature = Z
    }
    function R(se) {
        const H = (0,
        r.decodeRlp)((0,
        r.getBytes)(se).slice(1));
        (0,
        r.assertArgument)(Array.isArray(H) && (H.length === 9 || H.length === 12), "invalid field count for transaction type: 2", "data", (0,
        r.hexlify)(se));
        const G = {
            type: 2,
            chainId: a(H[0], "chainId"),
            nonce: x(H[1], "nonce"),
            maxPriorityFeePerGas: a(H[2], "maxPriorityFeePerGas"),
            maxFeePerGas: a(H[3], "maxFeePerGas"),
            gasPrice: null,
            gasLimit: a(H[4], "gasLimit"),
            to: P(H[5]),
            value: a(H[6], "value"),
            data: (0,
            r.hexlify)(H[7]),
            accessList: v(H[8], "accessList")
        };
        return H.length === 9 || A(G, H.slice(9)),
        G
    }
    function y(se, H) {
        const G = [E(se.chainId, "chainId"), E(se.nonce, "nonce"), E(se.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), E(se.maxFeePerGas || 0, "maxFeePerGas"), E(se.gasLimit, "gasLimit"), se.to || "0x", E(se.value, "value"), se.data, w(se.accessList || [])];
        return H && (G.push(E(H.yParity, "yParity")),
        G.push((0,
        r.toBeArray)(H.r)),
        G.push((0,
        r.toBeArray)(H.s))),
        (0,
        r.concat)(["0x02", (0,
        r.encodeRlp)(G)])
    }
    function k(se) {
        const H = (0,
        r.decodeRlp)((0,
        r.getBytes)(se).slice(1));
        (0,
        r.assertArgument)(Array.isArray(H) && (H.length === 8 || H.length === 11), "invalid field count for transaction type: 1", "data", (0,
        r.hexlify)(se));
        const G = {
            type: 1,
            chainId: a(H[0], "chainId"),
            nonce: x(H[1], "nonce"),
            gasPrice: a(H[2], "gasPrice"),
            gasLimit: a(H[3], "gasLimit"),
            to: P(H[4]),
            value: a(H[5], "value"),
            data: (0,
            r.hexlify)(H[6]),
            accessList: v(H[7], "accessList")
        };
        return H.length === 8 || A(G, H.slice(8)),
        G
    }
    function _(se, H) {
        const G = [E(se.chainId, "chainId"), E(se.nonce, "nonce"), E(se.gasPrice || 0, "gasPrice"), E(se.gasLimit, "gasLimit"), se.to || "0x", E(se.value, "value"), se.data, w(se.accessList || [])];
        return H && (G.push(E(H.yParity, "recoveryParam")),
        G.push((0,
        r.toBeArray)(H.r)),
        G.push((0,
        r.toBeArray)(H.s))),
        (0,
        r.concat)(["0x01", (0,
        r.encodeRlp)(G)])
    }
    function O(se) {
        let H = (0,
        r.decodeRlp)((0,
        r.getBytes)(se).slice(1))
          , G = "3"
          , q = null;
        if (H.length === 4 && Array.isArray(H[0])) {
            G = "3 (network format)";
            const Z = H[1]
              , J = H[2]
              , D = H[3];
            (0,
            r.assertArgument)(Array.isArray(Z), "invalid network format: blobs not an array", "fields[1]", Z),
            (0,
            r.assertArgument)(Array.isArray(J), "invalid network format: commitments not an array", "fields[2]", J),
            (0,
            r.assertArgument)(Array.isArray(D), "invalid network format: proofs not an array", "fields[3]", D),
            (0,
            r.assertArgument)(Z.length === J.length, "invalid network format: blobs/commitments length mismatch", "fields", H),
            (0,
            r.assertArgument)(Z.length === D.length, "invalid network format: blobs/proofs length mismatch", "fields", H),
            q = [];
            for (let X = 0; X < H[1].length; X++)
                q.push({
                    data: Z[X],
                    commitment: J[X],
                    proof: D[X]
                });
            H = H[0]
        }
        (0,
        r.assertArgument)(Array.isArray(H) && (H.length === 11 || H.length === 14), `invalid field count for transaction type: ${G}`, "data", (0,
        r.hexlify)(se));
        const ae = {
            type: 3,
            chainId: a(H[0], "chainId"),
            nonce: x(H[1], "nonce"),
            maxPriorityFeePerGas: a(H[2], "maxPriorityFeePerGas"),
            maxFeePerGas: a(H[3], "maxFeePerGas"),
            gasPrice: null,
            gasLimit: a(H[4], "gasLimit"),
            to: P(H[5]),
            value: a(H[6], "value"),
            data: (0,
            r.hexlify)(H[7]),
            accessList: v(H[8], "accessList"),
            maxFeePerBlobGas: a(H[9], "maxFeePerBlobGas"),
            blobVersionedHashes: H[10]
        };
        q && (ae.blobs = q),
        (0,
        r.assertArgument)(ae.to != null, `invalid address for transaction type: ${G}`, "data", se),
        (0,
        r.assertArgument)(Array.isArray(ae.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", se);
        for (let Z = 0; Z < ae.blobVersionedHashes.length; Z++)
            (0,
            r.assertArgument)((0,
            r.isHexString)(ae.blobVersionedHashes[Z], 32), `invalid blobVersionedHash at index ${Z}: must be length 32`, "data", se);
        return H.length === 11 || A(ae, H.slice(11)),
        ae
    }
    function L(se, H, G) {
        const q = [E(se.chainId, "chainId"), E(se.nonce, "nonce"), E(se.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), E(se.maxFeePerGas || 0, "maxFeePerGas"), E(se.gasLimit, "gasLimit"), se.to || t.ZeroAddress, E(se.value, "value"), se.data, w(se.accessList || []), E(se.maxFeePerBlobGas || 0, "maxFeePerBlobGas"), T(se.blobVersionedHashes || [], "blobVersionedHashes")];
        return H && (q.push(E(H.yParity, "yParity")),
        q.push((0,
        r.toBeArray)(H.r)),
        q.push((0,
        r.toBeArray)(H.s)),
        G) ? (0,
        r.concat)(["0x03", (0,
        r.encodeRlp)([q, G.map(ae => ae.data), G.map(ae => ae.commitment), G.map(ae => ae.proof)])]) : (0,
        r.concat)(["0x03", (0,
        r.encodeRlp)(q)])
    }
    function U(se) {
        const H = (0,
        r.decodeRlp)((0,
        r.getBytes)(se).slice(1));
        (0,
        r.assertArgument)(Array.isArray(H) && (H.length === 10 || H.length === 13), "invalid field count for transaction type: 4", "data", (0,
        r.hexlify)(se));
        const G = {
            type: 4,
            chainId: a(H[0], "chainId"),
            nonce: x(H[1], "nonce"),
            maxPriorityFeePerGas: a(H[2], "maxPriorityFeePerGas"),
            maxFeePerGas: a(H[3], "maxFeePerGas"),
            gasPrice: null,
            gasLimit: a(H[4], "gasLimit"),
            to: P(H[5]),
            value: a(H[6], "value"),
            data: (0,
            r.hexlify)(H[7]),
            accessList: v(H[8], "accessList"),
            authorizationList: b(H[9], "authorizationList")
        };
        return H.length === 10 || A(G, H.slice(10)),
        G
    }
    function $(se, H) {
        const G = [E(se.chainId, "chainId"), E(se.nonce, "nonce"), E(se.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), E(se.maxFeePerGas || 0, "maxFeePerGas"), E(se.gasLimit, "gasLimit"), se.to || "0x", E(se.value, "value"), se.data, w(se.accessList || []), S(se.authorizationList || [])];
        return H && (G.push(E(H.yParity, "yParity")),
        G.push((0,
        r.toBeArray)(H.r)),
        G.push((0,
        r.toBeArray)(H.s))),
        (0,
        r.concat)(["0x04", (0,
        r.encodeRlp)(G)])
    }
    const Pe = class Pe {
        constructor() {
            he(this, oe);
            he(this, I);
            he(this, F);
            he(this, z);
            he(this, Y);
            he(this, ie);
            he(this, ne);
            he(this, xe);
            he(this, W);
            he(this, ee);
            he(this, te);
            he(this, fe);
            he(this, be);
            he(this, le);
            he(this, re);
            he(this, M);
            he(this, K);
            he(this, V);
            Q(this, I, null),
            Q(this, F, null),
            Q(this, Y, 0),
            Q(this, ie, m),
            Q(this, ne, null),
            Q(this, xe, null),
            Q(this, W, null),
            Q(this, z, "0x"),
            Q(this, ee, m),
            Q(this, te, m),
            Q(this, fe, null),
            Q(this, be, null),
            Q(this, le, null),
            Q(this, re, null),
            Q(this, M, null),
            Q(this, K, null),
            Q(this, V, null)
        }
        get type() {
            return j(this, I)
        }
        set type(H) {
            switch (H) {
            case null:
                Q(this, I, null);
                break;
            case 0:
            case "legacy":
                Q(this, I, 0);
                break;
            case 1:
            case "berlin":
            case "eip-2930":
                Q(this, I, 1);
                break;
            case 2:
            case "london":
            case "eip-1559":
                Q(this, I, 2);
                break;
            case 3:
            case "cancun":
            case "eip-4844":
                Q(this, I, 3);
                break;
            case 4:
            case "pectra":
            case "eip-7702":
                Q(this, I, 4);
                break;
            default:
                (0,
                r.assertArgument)(!1, "unsupported transaction type", "type", H)
            }
        }
        get typeName() {
            switch (this.type) {
            case 0:
                return "legacy";
            case 1:
                return "eip-2930";
            case 2:
                return "eip-1559";
            case 3:
                return "eip-4844";
            case 4:
                return "eip-7702"
            }
            return null
        }
        get to() {
            const H = j(this, F);
            return H == null && this.type === 3 ? t.ZeroAddress : H
        }
        set to(H) {
            Q(this, F, H == null ? null : (0,
            e.getAddress)(H))
        }
        get nonce() {
            return j(this, Y)
        }
        set nonce(H) {
            Q(this, Y, (0,
            r.getNumber)(H, "value"))
        }
        get gasLimit() {
            return j(this, ie)
        }
        set gasLimit(H) {
            Q(this, ie, (0,
            r.getBigInt)(H))
        }
        get gasPrice() {
            const H = j(this, ne);
            return H == null && (this.type === 0 || this.type === 1) ? m : H
        }
        set gasPrice(H) {
            Q(this, ne, H == null ? null : (0,
            r.getBigInt)(H, "gasPrice"))
        }
        get maxPriorityFeePerGas() {
            const H = j(this, xe);
            return H ?? (this.type === 2 || this.type === 3 ? m : null)
        }
        set maxPriorityFeePerGas(H) {
            Q(this, xe, H == null ? null : (0,
            r.getBigInt)(H, "maxPriorityFeePerGas"))
        }
        get maxFeePerGas() {
            const H = j(this, W);
            return H ?? (this.type === 2 || this.type === 3 ? m : null)
        }
        set maxFeePerGas(H) {
            Q(this, W, H == null ? null : (0,
            r.getBigInt)(H, "maxFeePerGas"))
        }
        get data() {
            return j(this, z)
        }
        set data(H) {
            Q(this, z, (0,
            r.hexlify)(H))
        }
        get value() {
            return j(this, ee)
        }
        set value(H) {
            Q(this, ee, (0,
            r.getBigInt)(H, "value"))
        }
        get chainId() {
            return j(this, te)
        }
        set chainId(H) {
            Q(this, te, (0,
            r.getBigInt)(H))
        }
        get signature() {
            return j(this, fe) || null
        }
        set signature(H) {
            Q(this, fe, H == null ? null : s.Signature.from(H))
        }
        get accessList() {
            const H = j(this, be) || null;
            return H ?? (this.type === 1 || this.type === 2 || this.type === 3 ? [] : null)
        }
        set accessList(H) {
            Q(this, be, H == null ? null : (0,
            n.accessListify)(H))
        }
        get authorizationList() {
            const H = j(this, V) || null;
            return H == null && this.type === 4 ? [] : H
        }
        set authorizationList(H) {
            Q(this, V, H == null ? null : H.map(G => (0,
            d.authorizationify)(G)))
        }
        get maxFeePerBlobGas() {
            const H = j(this, le);
            return H == null && this.type === 3 ? m : H
        }
        set maxFeePerBlobGas(H) {
            Q(this, le, H == null ? null : (0,
            r.getBigInt)(H, "maxFeePerBlobGas"))
        }
        get blobVersionedHashes() {
            let H = j(this, re);
            return H == null && this.type === 3 ? [] : H
        }
        set blobVersionedHashes(H) {
            if (H != null) {
                (0,
                r.assertArgument)(Array.isArray(H), "blobVersionedHashes must be an Array", "value", H),
                H = H.slice();
                for (let G = 0; G < H.length; G++)
                    (0,
                    r.assertArgument)((0,
                    r.isHexString)(H[G], 32), "invalid blobVersionedHash", `value[${G}]`, H[G])
            }
            Q(this, re, H)
        }
        get blobs() {
            return j(this, K) == null ? null : j(this, K).map(H => Object.assign({}, H))
        }
        set blobs(H) {
            if (H == null) {
                Q(this, K, null);
                return
            }
            const G = []
              , q = [];
            for (let ae = 0; ae < H.length; ae++) {
                const Z = H[ae];
                if ((0,
                r.isBytesLike)(Z)) {
                    (0,
                    r.assert)(j(this, M), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
                        operation: "set blobs()"
                    });
                    let J = (0,
                    r.getBytes)(Z);
                    if ((0,
                    r.assertArgument)(J.length <= c, "blob is too large", `blobs[${ae}]`, Z),
                    J.length !== c) {
                        const ce = new Uint8Array(c);
                        ce.set(J),
                        J = ce
                    }
                    const D = j(this, M).blobToKzgCommitment(J)
                      , X = (0,
                    r.hexlify)(j(this, M).computeBlobKzgProof(J, D));
                    G.push({
                        data: (0,
                        r.hexlify)(J),
                        commitment: (0,
                        r.hexlify)(D),
                        proof: X
                    }),
                    q.push(g(1, D))
                } else {
                    const J = (0,
                    r.hexlify)(Z.commitment);
                    G.push({
                        data: (0,
                        r.hexlify)(Z.data),
                        commitment: J,
                        proof: (0,
                        r.hexlify)(Z.proof)
                    }),
                    q.push(g(1, J))
                }
            }
            Q(this, K, G),
            Q(this, re, q)
        }
        get kzg() {
            return j(this, M)
        }
        set kzg(H) {
            H == null ? Q(this, M, null) : Q(this, M, u(H))
        }
        get hash() {
            return this.signature == null ? null : (0,
            s.keccak256)(we(this, oe, hs).call(this, !0, !1))
        }
        get unsignedHash() {
            return (0,
            s.keccak256)(this.unsignedSerialized)
        }
        get from() {
            return this.signature == null ? null : (0,
            h.recoverAddress)(this.unsignedHash, this.signature)
        }
        get fromPublicKey() {
            return this.signature == null ? null : s.SigningKey.recoverPublicKey(this.unsignedHash, this.signature)
        }
        isSigned() {
            return this.signature != null
        }
        get serialized() {
            return we(this, oe, hs).call(this, !0, !0)
        }
        get unsignedSerialized() {
            return we(this, oe, hs).call(this, !1, !1)
        }
        inferType() {
            const H = this.inferTypes();
            return H.indexOf(2) >= 0 ? 2 : H.pop()
        }
        inferTypes() {
            const H = this.gasPrice != null
              , G = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null
              , q = this.accessList != null
              , ae = j(this, le) != null || j(this, re);
            this.maxFeePerGas != null && this.maxPriorityFeePerGas != null && (0,
            r.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
                value: this
            }),
            (0,
            r.assert)(!G || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
                value: this
            }),
            (0,
            r.assert)(this.type !== 0 || !q, "legacy transaction cannot have accessList", "BAD_DATA", {
                value: this
            });
            const Z = [];
            return this.type != null ? Z.push(this.type) : this.authorizationList && this.authorizationList.length ? Z.push(4) : G ? Z.push(2) : H ? (Z.push(1),
            q || Z.push(0)) : q ? (Z.push(1),
            Z.push(2)) : (ae && this.to || (Z.push(0),
            Z.push(1),
            Z.push(2)),
            Z.push(3)),
            Z.sort(),
            Z
        }
        isLegacy() {
            return this.type === 0
        }
        isBerlin() {
            return this.type === 1
        }
        isLondon() {
            return this.type === 2
        }
        isCancun() {
            return this.type === 3
        }
        clone() {
            return Pe.from(this)
        }
        toJSON() {
            const H = G => G == null ? null : G.toString();
            return {
                type: this.type,
                to: this.to,
                data: this.data,
                nonce: this.nonce,
                gasLimit: H(this.gasLimit),
                gasPrice: H(this.gasPrice),
                maxPriorityFeePerGas: H(this.maxPriorityFeePerGas),
                maxFeePerGas: H(this.maxFeePerGas),
                value: H(this.value),
                chainId: H(this.chainId),
                sig: this.signature ? this.signature.toJSON() : null,
                accessList: this.accessList
            }
        }
        static from(H) {
            if (H == null)
                return new Pe;
            if (typeof H == "string") {
                const q = (0,
                r.getBytes)(H);
                if (q[0] >= 127)
                    return Pe.from(C(q));
                switch (q[0]) {
                case 1:
                    return Pe.from(k(q));
                case 2:
                    return Pe.from(R(q));
                case 3:
                    return Pe.from(O(q));
                case 4:
                    return Pe.from(U(q))
                }
                (0,
                r.assert)(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
                    operation: "from"
                })
            }
            const G = new Pe;
            return H.type != null && (G.type = H.type),
            H.to != null && (G.to = H.to),
            H.nonce != null && (G.nonce = H.nonce),
            H.gasLimit != null && (G.gasLimit = H.gasLimit),
            H.gasPrice != null && (G.gasPrice = H.gasPrice),
            H.maxPriorityFeePerGas != null && (G.maxPriorityFeePerGas = H.maxPriorityFeePerGas),
            H.maxFeePerGas != null && (G.maxFeePerGas = H.maxFeePerGas),
            H.maxFeePerBlobGas != null && (G.maxFeePerBlobGas = H.maxFeePerBlobGas),
            H.data != null && (G.data = H.data),
            H.value != null && (G.value = H.value),
            H.chainId != null && (G.chainId = H.chainId),
            H.signature != null && (G.signature = s.Signature.from(H.signature)),
            H.accessList != null && (G.accessList = H.accessList),
            H.authorizationList != null && (G.authorizationList = H.authorizationList),
            H.blobVersionedHashes != null && (G.blobVersionedHashes = H.blobVersionedHashes),
            H.kzg != null && (G.kzg = H.kzg),
            H.blobs != null && (G.blobs = H.blobs),
            H.hash != null && ((0,
            r.assertArgument)(G.isSigned(), "unsigned transaction cannot define '.hash'", "tx", H),
            (0,
            r.assertArgument)(G.hash === H.hash, "hash mismatch", "tx", H)),
            H.from != null && ((0,
            r.assertArgument)(G.isSigned(), "unsigned transaction cannot define '.from'", "tx", H),
            (0,
            r.assertArgument)(G.from.toLowerCase() === (H.from || "").toLowerCase(), "from mismatch", "tx", H)),
            G
        }
    }
    ;
    I = new WeakMap,
    F = new WeakMap,
    z = new WeakMap,
    Y = new WeakMap,
    ie = new WeakMap,
    ne = new WeakMap,
    xe = new WeakMap,
    W = new WeakMap,
    ee = new WeakMap,
    te = new WeakMap,
    fe = new WeakMap,
    be = new WeakMap,
    le = new WeakMap,
    re = new WeakMap,
    M = new WeakMap,
    K = new WeakMap,
    V = new WeakMap,
    oe = new WeakSet,
    hs = function(H, G) {
        (0,
        r.assert)(!H || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
            operation: ".serialized"
        });
        const q = H ? this.signature : null;
        switch (this.inferType()) {
        case 0:
            return N(this, q);
        case 1:
            return _(this, q);
        case 2:
            return y(this, q);
        case 3:
            return L(this, q, G ? this.blobs : null);
        case 4:
            return $(this, q)
        }
        (0,
        r.assert)(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
            operation: ".serialized"
        })
    }
    ;
    let B = Pe;
    return gn.Transaction = B,
    gn
}
var La;
function lt() {
    return La || (La = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.Transaction = e.recoverAddress = e.computeAddress = e.authorizationify = e.accessListify = void 0;
        var t = Ju();
        Object.defineProperty(e, "accessListify", {
            enumerable: !0,
            get: function() {
                return t.accessListify
            }
        });
        var s = Qu();
        Object.defineProperty(e, "authorizationify", {
            enumerable: !0,
            get: function() {
                return s.authorizationify
            }
        });
        var r = Wu();
        Object.defineProperty(e, "computeAddress", {
            enumerable: !0,
            get: function() {
                return r.computeAddress
            }
        }),
        Object.defineProperty(e, "recoverAddress", {
            enumerable: !0,
            get: function() {
                return r.recoverAddress
            }
        });
        var n = of();
        Object.defineProperty(e, "Transaction", {
            enumerable: !0,
            get: function() {
                return n.Transaction
            }
        })
    }(ii)),
    ii
}
var Ua;
function af() {
    if (Ua)
        return fr;
    Ua = 1,
    Object.defineProperty(fr, "__esModule", {
        value: !0
    }),
    fr.verifyAuthorization = fr.hashAuthorization = void 0;
    const e = tt()
      , t = st()
      , s = lt()
      , r = Be();
    function n(h) {
        return (0,
        r.assertArgument)(typeof h.address == "string", "invalid address for hashAuthorization", "auth.address", h),
        (0,
        t.keccak256)((0,
        r.concat)(["0x05", (0,
        r.encodeRlp)([h.chainId != null ? (0,
        r.toBeArray)(h.chainId) : "0x", (0,
        e.getAddress)(h.address), h.nonce != null ? (0,
        r.toBeArray)(h.nonce) : "0x"])]))
    }
    fr.hashAuthorization = n;
    function d(h, m) {
        return (0,
        s.recoverAddress)(n(h), m)
    }
    return fr.verifyAuthorization = d,
    fr
}
var mn = {}, Fa;
function Yu() {
    if (Fa)
        return mn;
    Fa = 1,
    Object.defineProperty(mn, "__esModule", {
        value: !0
    }),
    mn.id = void 0;
    const e = st()
      , t = Be();
    function s(r) {
        return (0,
        e.keccak256)((0,
        t.toUtf8Bytes)(r))
    }
    return mn.id = s,
    mn
}
var Et = {}, bt = {}, Da;
function cf() {
    if (Da)
        return bt;
    Da = 1;
    var e = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
    const t = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]])
      , s = 4;
    function r(de) {
        let ge = 0;
        function ye() {
            return de[ge++] << 8 | de[ge++]
        }
        let Ee = ye()
          , Ae = 1
          , ke = [0, 1];
        for (let Nt = 1; Nt < Ee; Nt++)
            ke.push(Ae += ye());
        let _e = ye()
          , Se = ge;
        ge += _e;
        let De = 0
          , Je = 0;
        function Ne() {
            return De == 0 && (Je = Je << 8 | de[ge++],
            De = 8),
            Je >> --De & 1
        }
        const Ue = 31
          , Le = 2 ** Ue
          , ze = Le >>> 1
          , rt = ze >> 1
          , Ze = Le - 1;
        let et = 0;
        for (let Nt = 0; Nt < Ue; Nt++)
            et = et << 1 | Ne();
        let Ct = []
          , Or = 0
          , ls = Le;
        for (; ; ) {
            let Nt = Math.floor(((et - Or + 1) * Ae - 1) / ls)
              , Jt = 0
              , Hs = Ee;
            for (; Hs - Jt > 1; ) {
                let Gs = Jt + Hs >>> 1;
                Nt < ke[Gs] ? Hs = Gs : Jt = Gs
            }
            if (Jt == 0)
                break;
            Ct.push(Jt);
            let Kt = Or + Math.floor(ls * ke[Jt] / Ae)
              , Qt = Or + Math.floor(ls * ke[Jt + 1] / Ae) - 1;
            for (; !((Kt ^ Qt) & ze); )
                et = et << 1 & Ze | Ne(),
                Kt = Kt << 1 & Ze,
                Qt = Qt << 1 & Ze | 1;
            for (; Kt & ~Qt & rt; )
                et = et & ze | et << 1 & Ze >>> 1 | Ne(),
                Kt = Kt << 1 ^ ze,
                Qt = (Qt ^ ze) << 1 | ze | 1;
            Or = Kt,
            ls = 1 + Qt - Kt
        }
        let ds = Ee - 4;
        return Ct.map(Nt => {
            switch (Nt - ds) {
            case 3:
                return ds + 65792 + (de[Se++] << 16 | de[Se++] << 8 | de[Se++]);
            case 2:
                return ds + 256 + (de[Se++] << 8 | de[Se++]);
            case 1:
                return ds + de[Se++];
            default:
                return Nt - 1
            }
        }
        )
    }
    function n(de) {
        let ge = 0;
        return () => de[ge++]
    }
    function d(de) {
        return n(r(h(de)))
    }
    function h(de) {
        let ge = [];
        [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach( (Ae, ke) => ge[Ae.charCodeAt(0)] = ke);
        let ye = de.length
          , Ee = new Uint8Array(6 * ye >> 3);
        for (let Ae = 0, ke = 0, _e = 0, Se = 0; Ae < ye; Ae++)
            Se = Se << 6 | ge[de.charCodeAt(Ae)],
            _e += 6,
            _e >= 8 && (Ee[ke++] = Se >> (_e -= 8));
        return Ee
    }
    function m(de) {
        return de & 1 ? ~de >> 1 : de >> 1
    }
    function f(de, ge) {
        let ye = Array(de);
        for (let Ee = 0, Ae = 0; Ee < de; Ee++)
            ye[Ee] = Ae += m(ge());
        return ye
    }
    function i(de, ge=0) {
        let ye = [];
        for (; ; ) {
            let Ee = de()
              , Ae = de();
            if (!Ae)
                break;
            ge += Ee;
            for (let ke = 0; ke < Ae; ke++)
                ye.push(ge + ke);
            ge += Ae + 1
        }
        return ye
    }
    function l(de) {
        return o( () => {
            let ge = i(de);
            if (ge.length)
                return ge
        }
        )
    }
    function p(de) {
        let ge = [];
        for (; ; ) {
            let ye = de();
            if (ye == 0)
                break;
            ge.push(u(ye, de))
        }
        for (; ; ) {
            let ye = de() - 1;
            if (ye < 0)
                break;
            ge.push(g(ye, de))
        }
        return ge.flat()
    }
    function o(de) {
        let ge = [];
        for (; ; ) {
            let ye = de(ge.length);
            if (!ye)
                break;
            ge.push(ye)
        }
        return ge
    }
    function c(de, ge, ye) {
        let Ee = Array(de).fill().map( () => []);
        for (let Ae = 0; Ae < ge; Ae++)
            f(de, ye).forEach( (ke, _e) => Ee[_e].push(ke));
        return Ee
    }
    function u(de, ge) {
        let ye = 1 + ge()
          , Ee = ge()
          , Ae = o(ge);
        return c(Ae.length, 1 + de, ge).flatMap( (_e, Se) => {
            let[De,...Je] = _e;
            return Array(Ae[Se]).fill().map( (Ne, Ue) => {
                let Le = Ue * Ee;
                return [De + Ue * ye, Je.map(ze => ze + Le)]
            }
            )
        }
        )
    }
    function g(de, ge) {
        let ye = 1 + ge();
        return c(ye, 1 + de, ge).map(Ae => [Ae[0], Ae.slice(1)])
    }
    function P(de) {
        let ge = []
          , ye = i(de);
        return Ae(Ee([]), []),
        ge;
        function Ee(ke) {
            let _e = de()
              , Se = o( () => {
                let De = i(de).map(Je => ye[Je]);
                if (De.length)
                    return Ee(De)
            }
            );
            return {
                S: _e,
                B: Se,
                Q: ke
            }
        }
        function Ae({S: ke, B: _e}, Se, De) {
            if (!(ke & 4 && De === Se[Se.length - 1])) {
                ke & 2 && (De = Se[Se.length - 1]),
                ke & 1 && ge.push(Se);
                for (let Je of _e)
                    for (let Ne of Je.Q)
                        Ae(Je, [...Se, Ne], De)
            }
        }
    }
    function v(de) {
        return de.toString(16).toUpperCase().padStart(2, "0")
    }
    function b(de) {
        return `{${v(de)}}`
    }
    function x(de) {
        let ge = [];
        for (let ye = 0, Ee = de.length; ye < Ee; ) {
            let Ae = de.codePointAt(ye);
            ye += Ae < 65536 ? 1 : 2,
            ge.push(Ae)
        }
        return ge
    }
    function a(de) {
        let ye = de.length;
        if (ye < 4096)
            return String.fromCodePoint(...de);
        let Ee = [];
        for (let Ae = 0; Ae < ye; )
            Ee.push(String.fromCodePoint(...de.slice(Ae, Ae += 4096)));
        return Ee.join("")
    }
    function E(de, ge) {
        let ye = de.length
          , Ee = ye - ge.length;
        for (let Ae = 0; Ee == 0 && Ae < ye; Ae++)
            Ee = de[Ae] - ge[Ae];
        return Ee
    }
    var w = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
    const S = 44032
      , T = 4352
      , C = 4449
      , N = 4519
      , A = 19
      , R = 21
      , y = 28
      , k = R * y
      , _ = A * k
      , O = S + _
      , L = T + A
      , U = C + R
      , $ = N + y;
    function B(de) {
        return de >> 24 & 255
    }
    function I(de) {
        return de & 16777215
    }
    let F, z, Y, ie;
    function ne() {
        let de = d(w);
        F = new Map(l(de).flatMap( (ge, ye) => ge.map(Ee => [Ee, ye + 1 << 24]))),
        z = new Set(i(de)),
        Y = new Map,
        ie = new Map;
        for (let[ge,ye] of p(de)) {
            if (!z.has(ge) && ye.length == 2) {
                let[Ee,Ae] = ye
                  , ke = ie.get(Ee);
                ke || (ke = new Map,
                ie.set(Ee, ke)),
                ke.set(Ae, ge)
            }
            Y.set(ge, ye.reverse())
        }
    }
    function xe(de) {
        return de >= S && de < O
    }
    function W(de, ge) {
        if (de >= T && de < L && ge >= C && ge < U)
            return S + (de - T) * k + (ge - C) * y;
        if (xe(de) && ge > N && ge < $ && (de - S) % y == 0)
            return de + (ge - N);
        {
            let ye = ie.get(de);
            return ye && (ye = ye.get(ge),
            ye) ? ye : -1
        }
    }
    function ee(de) {
        F || ne();
        let ge = []
          , ye = []
          , Ee = !1;
        function Ae(ke) {
            let _e = F.get(ke);
            _e && (Ee = !0,
            ke |= _e),
            ge.push(ke)
        }
        for (let ke of de)
            for (; ; ) {
                if (ke < 128)
                    ge.push(ke);
                else if (xe(ke)) {
                    let _e = ke - S
                      , Se = _e / k | 0
                      , De = _e % k / y | 0
                      , Je = _e % y;
                    Ae(T + Se),
                    Ae(C + De),
                    Je > 0 && Ae(N + Je)
                } else {
                    let _e = Y.get(ke);
                    _e ? ye.push(..._e) : Ae(ke)
                }
                if (!ye.length)
                    break;
                ke = ye.pop()
            }
        if (Ee && ge.length > 1) {
            let ke = B(ge[0]);
            for (let _e = 1; _e < ge.length; _e++) {
                let Se = B(ge[_e]);
                if (Se == 0 || ke <= Se) {
                    ke = Se;
                    continue
                }
                let De = _e - 1;
                for (; ; ) {
                    let Je = ge[De + 1];
                    if (ge[De + 1] = ge[De],
                    ge[De] = Je,
                    !De || (ke = B(ge[--De]),
                    ke <= Se))
                        break
                }
                ke = B(ge[_e])
            }
        }
        return ge
    }
    function te(de) {
        let ge = []
          , ye = []
          , Ee = -1
          , Ae = 0;
        for (let ke of de) {
            let _e = B(ke)
              , Se = I(ke);
            if (Ee == -1)
                _e == 0 ? Ee = Se : ge.push(Se);
            else if (Ae > 0 && Ae >= _e)
                _e == 0 ? (ge.push(Ee, ...ye),
                ye.length = 0,
                Ee = Se) : ye.push(Se),
                Ae = _e;
            else {
                let De = W(Ee, Se);
                De >= 0 ? Ee = De : Ae == 0 && _e == 0 ? (ge.push(Ee),
                Ee = Se) : (ye.push(Se),
                Ae = _e)
            }
        }
        return Ee >= 0 && ge.push(Ee, ...ye),
        ge
    }
    function fe(de) {
        return ee(de).map(I)
    }
    function be(de) {
        return te(ee(de))
    }
    const le = 45
      , re = 46
      , M = "."
      , K = 65039
      , V = 1
      , oe = de => Array.from(de);
    function me(de, ge) {
        return de.P.has(ge) || de.Q.has(ge)
    }
    class Pe extends Array {
        get is_emoji() {
            return !0
        }
    }
    let se, H, G, q, ae, Z, J, D, X, ce, pe, ve;
    function Oe() {
        if (se)
            return;
        let de = d(e);
        const ge = () => i(de)
          , ye = () => new Set(ge())
          , Ee = (Ne, Ue) => Ue.forEach(Le => Ne.add(Le));
        se = new Map(p(de)),
        H = ye(),
        G = ge(),
        q = new Set(ge().map(Ne => G[Ne])),
        G = new Set(G),
        ae = ye(),
        Z = ye();
        let Ae = l(de)
          , ke = de();
        const _e = () => {
            let Ne = new Set;
            return ge().forEach(Ue => Ee(Ne, Ae[Ue])),
            Ee(Ne, ge()),
            Ne
        }
        ;
        J = o(Ne => {
            let Ue = o(de).map(Le => Le + 96);
            if (Ue.length) {
                let Le = Ne >= ke;
                Ue[0] -= 32,
                Ue = a(Ue),
                Le && (Ue = `Restricted[${Ue}]`);
                let ze = _e()
                  , rt = _e()
                  , Ze = !de();
                return {
                    N: Ue,
                    P: ze,
                    Q: rt,
                    M: Ze,
                    R: Le
                }
            }
        }
        ),
        D = ye(),
        X = new Map;
        let Se = ge().concat(oe(D)).sort( (Ne, Ue) => Ne - Ue);
        Se.forEach( (Ne, Ue) => {
            let Le = de()
              , ze = Se[Ue] = Le ? Se[Ue - Le] : {
                V: [],
                M: new Map
            };
            ze.V.push(Ne),
            D.has(Ne) || X.set(Ne, ze)
        }
        );
        for (let {V: Ne, M: Ue} of new Set(X.values())) {
            let Le = [];
            for (let rt of Ne) {
                let Ze = J.filter(Ct => me(Ct, rt))
                  , et = Le.find( ({G: Ct}) => Ze.some(Or => Ct.has(Or)));
                et || (et = {
                    G: new Set,
                    V: []
                },
                Le.push(et)),
                et.V.push(rt),
                Ee(et.G, Ze)
            }
            let ze = Le.flatMap(rt => oe(rt.G));
            for (let {G: rt, V: Ze} of Le) {
                let et = new Set(ze.filter(Ct => !rt.has(Ct)));
                for (let Ct of Ze)
                    Ue.set(Ct, et)
            }
        }
        ce = new Set;
        let De = new Set;
        const Je = Ne => ce.has(Ne) ? De.add(Ne) : ce.add(Ne);
        for (let Ne of J) {
            for (let Ue of Ne.P)
                Je(Ue);
            for (let Ue of Ne.Q)
                Je(Ue)
        }
        for (let Ne of ce)
            !X.has(Ne) && !De.has(Ne) && X.set(Ne, V);
        Ee(ce, fe(ce)),
        pe = P(de).map(Ne => Pe.from(Ne)).sort(E),
        ve = new Map;
        for (let Ne of pe) {
            let Ue = [ve];
            for (let Le of Ne) {
                let ze = Ue.map(rt => {
                    let Ze = rt.get(Le);
                    return Ze || (Ze = new Map,
                    rt.set(Le, Ze)),
                    Ze
                }
                );
                Le === K ? Ue.push(...ze) : Ue = ze
            }
            for (let Le of Ue)
                Le.V = Ne
        }
    }
    function Ge(de) {
        return (Ls(de) ? "" : `${qe(zt([de]))} `) + b(de)
    }
    function qe(de) {
        return `"${de}"`
    }
    function je(de) {
        if (de.length >= 4 && de[2] == le && de[3] == le)
            throw new Error(`invalid label extension: "${a(de.slice(0, 4))}"`)
    }
    function $e(de) {
        for (let ye = de.lastIndexOf(95); ye > 0; )
            if (de[--ye] !== 95)
                throw new Error("underscore allowed only at start")
    }
    function St(de) {
        let ge = de[0]
          , ye = t.get(ge);
        if (ye)
            throw Ur(`leading ${ye}`);
        let Ee = de.length
          , Ae = -1;
        for (let ke = 1; ke < Ee; ke++) {
            ge = de[ke];
            let _e = t.get(ge);
            if (_e) {
                if (Ae == ke)
                    throw Ur(`${ye} + ${_e}`);
                Ae = ke + 1,
                ye = _e
            }
        }
        if (Ae == Ee)
            throw Ur(`trailing ${ye}`)
    }
    function zt(de, ge=1 / 0, ye=b) {
        let Ee = [];
        oo(de[0]) && Ee.push(""),
        de.length > ge && (ge >>= 1,
        de = [...de.slice(0, ge), 8230, ...de.slice(-ge)]);
        let Ae = 0
          , ke = de.length;
        for (let _e = 0; _e < ke; _e++) {
            let Se = de[_e];
            Ls(Se) && (Ee.push(a(de.slice(Ae, _e))),
            Ee.push(ye(Se)),
            Ae = _e + 1)
        }
        return Ee.push(a(de.slice(Ae, ke))),
        Ee.join("")
    }
    function oo(de) {
        return Oe(),
        G.has(de)
    }
    function Ls(de) {
        return Oe(),
        ae.has(de)
    }
    function Sl() {
        return Oe(),
        pe.map(de => de.slice())
    }
    function Cl(de, ge) {
        Oe();
        let ye = ge ? fe : be;
        return de.split(M).map(Ee => a(lo(x(Ee), ye, us).flat())).join(M)
    }
    function Nl(de) {
        return ao(Us(de, be, us))
    }
    function Rl(de) {
        let ge = Us(de, be, ye => ye);
        for (let {type: ye, output: Ee, error: Ae} of ge) {
            if (Ae)
                break;
            ye !== "Greek" && Il(Ee, 958, 926)
        }
        return ao(ge)
    }
    function Il(de, ge, ye) {
        let Ee = 0;
        for (; ; ) {
            let Ae = de.indexOf(ge, Ee);
            if (Ae < 0)
                break;
            de[Ae] = ye,
            Ee = Ae + 1
        }
    }
    function jl(de, ge) {
        return Us(de, be, ge ? ye => ye.slice() : us)
    }
    function Us(de, ge, ye) {
        if (!de)
            return [];
        Oe();
        let Ee = 0;
        return de.split(M).map(Ae => {
            let ke = x(Ae)
              , _e = {
                input: ke,
                offset: Ee
            };
            Ee += ke.length + 1;
            try {
                let Se = _e.tokens = lo(ke, ge, ye), De = Se.length, Je;
                if (!De)
                    throw new Error("empty label");
                let Ne = _e.output = Se.flat();
                if ($e(Ne),
                !(_e.emoji = De > 1 || Se[0].is_emoji) && Ne.every(Le => Le < 128))
                    je(Ne),
                    Je = "ASCII";
                else {
                    let Le = Se.flatMap(ze => ze.is_emoji ? [] : ze);
                    if (!Le.length)
                        Je = "Emoji";
                    else {
                        if (G.has(Ne[0]))
                            throw Ur("leading combining mark");
                        for (let Ze = 1; Ze < De; Ze++) {
                            let et = Se[Ze];
                            if (!et.is_emoji && G.has(et[0]))
                                throw Ur(`emoji + combining mark: "${a(Se[Ze - 1])} + ${zt([et[0]])}"`)
                        }
                        St(Ne);
                        let ze = oe(new Set(Le))
                          , [rt] = Ll(ze);
                        Ul(rt, Le),
                        Ml(rt, ze),
                        Je = rt.N
                    }
                }
                _e.type = Je
            } catch (Se) {
                _e.error = Se
            }
            return _e
        }
        )
    }
    function Ml(de, ge) {
        let ye, Ee = [];
        for (let Ae of ge) {
            let ke = X.get(Ae);
            if (ke === V)
                return;
            if (ke) {
                let _e = ke.M.get(Ae);
                if (ye = ye ? ye.filter(Se => _e.has(Se)) : oe(_e),
                !ye.length)
                    return
            } else
                Ee.push(Ae)
        }
        if (ye) {
            for (let Ae of ye)
                if (Ee.every(ke => me(Ae, ke)))
                    throw new Error(`whole-script confusable: ${de.N}/${Ae.N}`)
        }
    }
    function Ll(de) {
        let ge = J;
        for (let ye of de) {
            let Ee = ge.filter(Ae => me(Ae, ye));
            if (!Ee.length)
                throw J.some(Ae => me(Ae, ye)) ? uo(ge[0], ye) : co(ye);
            if (ge = Ee,
            Ee.length == 1)
                break
        }
        return ge
    }
    function ao(de) {
        return de.map( ({input: ge, error: ye, output: Ee}) => {
            if (ye) {
                let Ae = ye.message;
                throw new Error(de.length == 1 ? Ae : `Invalid label ${qe(zt(ge, 63))}: ${Ae}`)
            }
            return a(Ee)
        }
        ).join(M)
    }
    function co(de) {
        return new Error(`disallowed character: ${Ge(de)}`)
    }
    function uo(de, ge) {
        let ye = Ge(ge)
          , Ee = J.find(Ae => Ae.P.has(ge));
        return Ee && (ye = `${Ee.N} ${ye}`),
        new Error(`illegal mixture: ${de.N} + ${ye}`)
    }
    function Ur(de) {
        return new Error(`illegal placement: ${de}`)
    }
    function Ul(de, ge) {
        for (let ye of ge)
            if (!me(de, ye))
                throw uo(de, ye);
        if (de.M) {
            let ye = fe(ge);
            for (let Ee = 1, Ae = ye.length; Ee < Ae; Ee++)
                if (q.has(ye[Ee])) {
                    let ke = Ee + 1;
                    for (let _e; ke < Ae && q.has(_e = ye[ke]); ke++)
                        for (let Se = Ee; Se < ke; Se++)
                            if (ye[Se] == _e)
                                throw new Error(`duplicate non-spacing marks: ${Ge(_e)}`);
                    if (ke - Ee > s)
                        throw new Error(`excessive non-spacing marks: ${qe(zt(ye.slice(Ee - 1, ke)))} (${ke - Ee}/${s})`);
                    Ee = ke
                }
        }
    }
    function lo(de, ge, ye) {
        let Ee = []
          , Ae = [];
        for (de = de.slice().reverse(); de.length; ) {
            let ke = fo(de);
            if (ke)
                Ae.length && (Ee.push(ge(Ae)),
                Ae = []),
                Ee.push(ye(ke));
            else {
                let _e = de.pop();
                if (ce.has(_e))
                    Ae.push(_e);
                else {
                    let Se = se.get(_e);
                    if (Se)
                        Ae.push(...Se);
                    else if (!H.has(_e))
                        throw co(_e)
                }
            }
        }
        return Ae.length && Ee.push(ge(Ae)),
        Ee
    }
    function us(de) {
        return de.filter(ge => ge != K)
    }
    function fo(de, ge) {
        let ye = ve, Ee, Ae = de.length;
        for (; Ae && (ye = ye.get(de[--Ae]),
        !!ye); ) {
            let {V: ke} = ye;
            ke && (Ee = ke,
            ge && ge.push(...de.slice(Ae).reverse()),
            de.length = Ae)
        }
        return Ee
    }
    const Fr = "valid"
      , ho = "mapped"
      , Fs = "ignored"
      , Fl = "disallowed"
      , Dl = "emoji"
      , Hl = "nfc"
      , Gl = "stop";
    function po(de, {nf: ge=!0}={}) {
        Oe();
        let ye = x(de).reverse()
          , Ee = []
          , Ae = [];
        for (; ye.length; ) {
            let ke = fo(ye, Ee);
            if (ke)
                Ae.push({
                    type: Dl,
                    emoji: ke.slice(),
                    input: Ee,
                    cps: us(ke)
                }),
                Ee = [];
            else {
                let _e = ye.pop();
                if (_e == re)
                    Ae.push({
                        type: Gl,
                        cp: _e
                    });
                else if (ce.has(_e))
                    Ae.push({
                        type: Fr,
                        cps: [_e]
                    });
                else if (H.has(_e))
                    Ae.push({
                        type: Fs,
                        cp: _e
                    });
                else {
                    let Se = se.get(_e);
                    Se ? Ae.push({
                        type: ho,
                        cp: _e,
                        cps: Se.slice()
                    }) : Ae.push({
                        type: Fl,
                        cp: _e
                    })
                }
            }
        }
        if (ge)
            for (let ke = 0, _e = -1; ke < Ae.length; ke++) {
                let Se = Ae[ke];
                if (Ds(Se.type))
                    if (bo(Se.cps)) {
                        let De = ke + 1;
                        for (let Le = De; Le < Ae.length; Le++) {
                            let {type: ze, cps: rt} = Ae[Le];
                            if (Ds(ze)) {
                                if (!bo(rt))
                                    break;
                                De = Le + 1
                            } else if (ze !== Fs)
                                break
                        }
                        _e < 0 && (_e = ke);
                        let Je = Ae.slice(_e, De)
                          , Ne = Je.flatMap(Le => Ds(Le.type) ? Le.cps : [])
                          , Ue = be(Ne);
                        E(Ue, Ne) ? (Ae.splice(_e, De - _e, {
                            type: Hl,
                            input: Ne,
                            cps: Ue,
                            tokens0: go(Je),
                            tokens: po(a(Ue), {
                                nf: !1
                            })
                        }),
                        ke = _e) : ke = De - 1,
                        _e = -1
                    } else
                        _e = ke;
                else
                    Se.type !== Fs && (_e = -1)
            }
        return go(Ae)
    }
    function Ds(de) {
        return de == Fr || de == ho
    }
    function bo(de) {
        return de.some(ge => Z.has(ge))
    }
    function go(de) {
        for (let ge = 0; ge < de.length; ge++)
            if (de[ge].type == Fr) {
                let ye = ge + 1;
                for (; ye < de.length && de[ye].type == Fr; )
                    ye++;
                de.splice(ge, ye - ge, {
                    type: Fr,
                    cps: de.slice(ge, ye).flatMap(Ee => Ee.cps)
                })
            }
        return de
    }
    return bt.ens_beautify = Rl,
    bt.ens_emoji = Sl,
    bt.ens_normalize = Nl,
    bt.ens_normalize_fragment = Cl,
    bt.ens_split = jl,
    bt.ens_tokenize = po,
    bt.is_combining_mark = oo,
    bt.nfc = be,
    bt.nfd = fe,
    bt.safe_str_from_cps = zt,
    bt.should_escape = Ls,
    bt
}
var Ha;
function uf() {
    if (Ha)
        return Et;
    Ha = 1,
    Object.defineProperty(Et, "__esModule", {
        value: !0
    }),
    Et.dnsEncode = Et.namehash = Et.isValidName = Et.ensNormalize = void 0;
    const e = st()
      , t = Be()
      , s = cf()
      , r = new Uint8Array(32);
    r.fill(0);
    function n(l) {
        return (0,
        t.assertArgument)(l.length !== 0, "invalid ENS name; empty component", "comp", l),
        l
    }
    function d(l) {
        const p = (0,
        t.toUtf8Bytes)(h(l))
          , o = [];
        if (l.length === 0)
            return o;
        let c = 0;
        for (let u = 0; u < p.length; u++)
            p[u] === 46 && (o.push(n(p.slice(c, u))),
            c = u + 1);
        return (0,
        t.assertArgument)(c < p.length, "invalid ENS name; empty component", "name", l),
        o.push(n(p.slice(c))),
        o
    }
    function h(l) {
        try {
            if (l.length === 0)
                throw new Error("empty label");
            return (0,
            s.ens_normalize)(l)
        } catch (p) {
            (0,
            t.assertArgument)(!1, `invalid ENS name (${p.message})`, "name", l)
        }
    }
    Et.ensNormalize = h;
    function m(l) {
        try {
            return d(l).length !== 0
        } catch {}
        return !1
    }
    Et.isValidName = m;
    function f(l) {
        (0,
        t.assertArgument)(typeof l == "string", "invalid ENS name; not a string", "name", l),
        (0,
        t.assertArgument)(l.length, "invalid ENS name (empty label)", "name", l);
        let p = r;
        const o = d(l);
        for (; o.length; )
            p = (0,
            e.keccak256)((0,
            t.concat)([p, (0,
            e.keccak256)(o.pop())]));
        return (0,
        t.hexlify)(p)
    }
    Et.namehash = f;
    function i(l, p) {
        const o = p ?? 63;
        return (0,
        t.assertArgument)(o <= 255, "DNS encoded label cannot exceed 255", "length", o),
        (0,
        t.hexlify)((0,
        t.concat)(d(l).map(c => {
            (0,
            t.assertArgument)(c.length <= o, `label ${JSON.stringify(l)} exceeds ${o} bytes`, "name", l);
            const u = new Uint8Array(c.length + 1);
            return u.set(c, 1),
            u[0] = u.length - 1,
            u
        }
        ))) + "00"
    }
    return Et.dnsEncode = i,
    Et
}
var pr = {}, Ga;
function lf() {
    if (Ga)
        return pr;
    Ga = 1,
    Object.defineProperty(pr, "__esModule", {
        value: !0
    }),
    pr.verifyMessage = pr.hashMessage = void 0;
    const e = st()
      , t = is()
      , s = lt()
      , r = Be();
    function n(h) {
        return typeof h == "string" && (h = (0,
        r.toUtf8Bytes)(h)),
        (0,
        e.keccak256)((0,
        r.concat)([(0,
        r.toUtf8Bytes)(t.MessagePrefix), (0,
        r.toUtf8Bytes)(String(h.length)), h]))
    }
    pr.hashMessage = n;
    function d(h, m) {
        const f = n(h);
        return (0,
        s.recoverAddress)(f, m)
    }
    return pr.verifyMessage = d,
    pr
}
var Ut = {}, $a;
function df() {
    if ($a)
        return Ut;
    $a = 1,
    Object.defineProperty(Ut, "__esModule", {
        value: !0
    }),
    Ut.solidityPackedSha256 = Ut.solidityPackedKeccak256 = Ut.solidityPacked = void 0;
    const e = tt()
      , t = st()
      , s = Be()
      , r = new RegExp("^bytes([0-9]+)$")
      , n = new RegExp("^(u?int)([0-9]*)$")
      , d = new RegExp("^(.*)\\[([0-9]*)\\]$");
    function h(l, p, o) {
        switch (l) {
        case "address":
            return o ? (0,
            s.getBytes)((0,
            s.zeroPadValue)(p, 32)) : (0,
            s.getBytes)((0,
            e.getAddress)(p));
        case "string":
            return (0,
            s.toUtf8Bytes)(p);
        case "bytes":
            return (0,
            s.getBytes)(p);
        case "bool":
            return p = p ? "0x01" : "0x00",
            o ? (0,
            s.getBytes)((0,
            s.zeroPadValue)(p, 32)) : (0,
            s.getBytes)(p)
        }
        let c = l.match(n);
        if (c) {
            let u = c[1] === "int"
              , g = parseInt(c[2] || "256");
            return (0,
            s.assertArgument)((!c[2] || c[2] === String(g)) && g % 8 === 0 && g !== 0 && g <= 256, "invalid number type", "type", l),
            o && (g = 256),
            u && (p = (0,
            s.toTwos)(p, g)),
            (0,
            s.getBytes)((0,
            s.zeroPadValue)((0,
            s.toBeArray)(p), g / 8))
        }
        if (c = l.match(r),
        c) {
            const u = parseInt(c[1]);
            return (0,
            s.assertArgument)(String(u) === c[1] && u !== 0 && u <= 32, "invalid bytes type", "type", l),
            (0,
            s.assertArgument)((0,
            s.dataLength)(p) === u, `invalid value for ${l}`, "value", p),
            o ? (0,
            s.getBytes)((0,
            s.zeroPadBytes)(p, 32)) : p
        }
        if (c = l.match(d),
        c && Array.isArray(p)) {
            const u = c[1]
              , g = parseInt(c[2] || String(p.length));
            (0,
            s.assertArgument)(g === p.length, `invalid array length for ${l}`, "value", p);
            const P = [];
            return p.forEach(function(v) {
                P.push(h(u, v, !0))
            }),
            (0,
            s.getBytes)((0,
            s.concat)(P))
        }
        (0,
        s.assertArgument)(!1, "invalid type", "type", l)
    }
    function m(l, p) {
        (0,
        s.assertArgument)(l.length === p.length, "wrong number of values; expected ${ types.length }", "values", p);
        const o = [];
        return l.forEach(function(c, u) {
            o.push(h(c, p[u]))
        }),
        (0,
        s.hexlify)((0,
        s.concat)(o))
    }
    Ut.solidityPacked = m;
    function f(l, p) {
        return (0,
        t.keccak256)(m(l, p))
    }
    Ut.solidityPackedKeccak256 = f;
    function i(l, p) {
        return (0,
        t.sha256)(m(l, p))
    }
    return Ut.solidityPackedSha256 = i,
    Ut
}
var br = {}, qa;
function ff() {
    var w, S, T, C, Zu;
    if (qa)
        return br;
    qa = 1,
    Object.defineProperty(br, "__esModule", {
        value: !0
    }),
    br.verifyTypedData = br.TypedDataEncoder = void 0;
    const e = tt()
      , t = st()
      , s = lt()
      , r = Be()
      , n = Yu()
      , d = new Uint8Array(32);
    d.fill(0);
    const h = BigInt(-1)
      , m = BigInt(0)
      , f = BigInt(1)
      , i = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    function l(R) {
        const y = (0,
        r.getBytes)(R)
          , k = y.length % 32;
        return k ? (0,
        r.concat)([y, d.slice(k)]) : (0,
        r.hexlify)(y)
    }
    const p = (0,
    r.toBeHex)(f, 32)
      , o = (0,
    r.toBeHex)(m, 32)
      , c = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
    }
      , u = ["name", "version", "chainId", "verifyingContract", "salt"];
    function g(R) {
        return function(y) {
            return (0,
            r.assertArgument)(typeof y == "string", `invalid domain value for ${JSON.stringify(R)}`, `domain.${R}`, y),
            y
        }
    }
    const P = {
        name: g("name"),
        version: g("version"),
        chainId: function(R) {
            const y = (0,
            r.getBigInt)(R, "domain.chainId");
            return (0,
            r.assertArgument)(y >= 0, "invalid chain ID", "domain.chainId", R),
            Number.isSafeInteger(y) ? Number(y) : (0,
            r.toQuantity)(y)
        },
        verifyingContract: function(R) {
            try {
                return (0,
                e.getAddress)(R).toLowerCase()
            } catch {}
            (0,
            r.assertArgument)(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", R)
        },
        salt: function(R) {
            const y = (0,
            r.getBytes)(R, "domain.salt");
            return (0,
            r.assertArgument)(y.length === 32, 'invalid domain value "salt"', "domain.salt", R),
            (0,
            r.hexlify)(y)
        }
    };
    function v(R) {
        {
            const y = R.match(/^(u?)int(\d+)$/);
            if (y) {
                const k = y[1] === ""
                  , _ = parseInt(y[2]);
                (0,
                r.assertArgument)(_ % 8 === 0 && _ !== 0 && _ <= 256 && y[2] === String(_), "invalid numeric width", "type", R);
                const O = (0,
                r.mask)(i, k ? _ - 1 : _)
                  , L = k ? (O + f) * h : m;
                return function(U) {
                    const $ = (0,
                    r.getBigInt)(U, "value");
                    return (0,
                    r.assertArgument)($ >= L && $ <= O, `value out-of-bounds for ${R}`, "value", $),
                    (0,
                    r.toBeHex)(k ? (0,
                    r.toTwos)($, 256) : $, 32)
                }
            }
        }
        {
            const y = R.match(/^bytes(\d+)$/);
            if (y) {
                const k = parseInt(y[1]);
                return (0,
                r.assertArgument)(k !== 0 && k <= 32 && y[1] === String(k), "invalid bytes width", "type", R),
                function(_) {
                    const O = (0,
                    r.getBytes)(_);
                    return (0,
                    r.assertArgument)(O.length === k, `invalid length for ${R}`, "value", _),
                    l(_)
                }
            }
        }
        switch (R) {
        case "address":
            return function(y) {
                return (0,
                r.zeroPadValue)((0,
                e.getAddress)(y), 32)
            }
            ;
        case "bool":
            return function(y) {
                return y ? p : o
            }
            ;
        case "bytes":
            return function(y) {
                return (0,
                t.keccak256)(y)
            }
            ;
        case "string":
            return function(y) {
                return (0,
                n.id)(y)
            }
        }
        return null
    }
    function b(R, y) {
        return `${R}(${y.map( ({name: k, type: _}) => _ + " " + k).join(",")})`
    }
    function x(R) {
        const y = R.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
        return y ? {
            base: y[1],
            index: y[2] + y[4],
            array: {
                base: y[1],
                prefix: y[1] + y[2],
                count: y[5] ? parseInt(y[5]) : -1
            }
        } : {
            base: R
        }
    }
    const A = class A {
        constructor(y) {
            he(this, C);
            ue(this, "primaryType");
            he(this, w);
            he(this, S);
            he(this, T);
            Q(this, S, new Map),
            Q(this, T, new Map);
            const k = new Map
              , _ = new Map
              , O = new Map
              , L = {};
            Object.keys(y).forEach(B => {
                L[B] = y[B].map( ({name: I, type: F}) => {
                    let {base: z, index: Y} = x(F);
                    return z === "int" && !y.int && (z = "int256"),
                    z === "uint" && !y.uint && (z = "uint256"),
                    {
                        name: I,
                        type: z + (Y || "")
                    }
                }
                ),
                k.set(B, new Set),
                _.set(B, []),
                O.set(B, new Set)
            }
            ),
            Q(this, w, JSON.stringify(L));
            for (const B in L) {
                const I = new Set;
                for (const F of L[B]) {
                    (0,
                    r.assertArgument)(!I.has(F.name), `duplicate variable name ${JSON.stringify(F.name)} in ${JSON.stringify(B)}`, "types", y),
                    I.add(F.name);
                    const z = x(F.type).base;
                    (0,
                    r.assertArgument)(z !== B, `circular type reference to ${JSON.stringify(z)}`, "types", y),
                    !v(z) && ((0,
                    r.assertArgument)(_.has(z), `unknown type ${JSON.stringify(z)}`, "types", y),
                    _.get(z).push(B),
                    k.get(B).add(z))
                }
            }
            const U = Array.from(_.keys()).filter(B => _.get(B).length === 0);
            (0,
            r.assertArgument)(U.length !== 0, "missing primary type", "types", y),
            (0,
            r.assertArgument)(U.length === 1, `ambiguous primary types or unused types: ${U.map(B => JSON.stringify(B)).join(", ")}`, "types", y),
            (0,
            r.defineProperties)(this, {
                primaryType: U[0]
            });
            function $(B, I) {
                (0,
                r.assertArgument)(!I.has(B), `circular type reference to ${JSON.stringify(B)}`, "types", y),
                I.add(B);
                for (const F of k.get(B))
                    if (_.has(F)) {
                        $(F, I);
                        for (const z of I)
                            O.get(z).add(F)
                    }
                I.delete(B)
            }
            $(this.primaryType, new Set);
            for (const [B,I] of O) {
                const F = Array.from(I);
                F.sort(),
                j(this, S).set(B, b(B, L[B]) + F.map(z => b(z, L[z])).join(""))
            }
        }
        get types() {
            return JSON.parse(j(this, w))
        }
        getEncoder(y) {
            let k = j(this, T).get(y);
            return k || (k = we(this, C, Zu).call(this, y),
            j(this, T).set(y, k)),
            k
        }
        encodeType(y) {
            const k = j(this, S).get(y);
            return (0,
            r.assertArgument)(k, `unknown type: ${JSON.stringify(y)}`, "name", y),
            k
        }
        encodeData(y, k) {
            return this.getEncoder(y)(k)
        }
        hashStruct(y, k) {
            return (0,
            t.keccak256)(this.encodeData(y, k))
        }
        encode(y) {
            return this.encodeData(this.primaryType, y)
        }
        hash(y) {
            return this.hashStruct(this.primaryType, y)
        }
        _visit(y, k, _) {
            if (v(y))
                return _(y, k);
            const O = x(y).array;
            if (O)
                return (0,
                r.assertArgument)(O.count === -1 || O.count === k.length, `array length mismatch; expected length ${O.count}`, "value", k),
                k.map(U => this._visit(O.prefix, U, _));
            const L = this.types[y];
            if (L)
                return L.reduce( (U, {name: $, type: B}) => (U[$] = this._visit(B, k[$], _),
                U), {});
            (0,
            r.assertArgument)(!1, `unknown type: ${y}`, "type", y)
        }
        visit(y, k) {
            return this._visit(this.primaryType, y, k)
        }
        static from(y) {
            return new A(y)
        }
        static getPrimaryType(y) {
            return A.from(y).primaryType
        }
        static hashStruct(y, k, _) {
            return A.from(k).hashStruct(y, _)
        }
        static hashDomain(y) {
            const k = [];
            for (const _ in y) {
                if (y[_] == null)
                    continue;
                const O = c[_];
                (0,
                r.assertArgument)(O, `invalid typed-data domain key: ${JSON.stringify(_)}`, "domain", y),
                k.push({
                    name: _,
                    type: O
                })
            }
            return k.sort( (_, O) => u.indexOf(_.name) - u.indexOf(O.name)),
            A.hashStruct("EIP712Domain", {
                EIP712Domain: k
            }, y)
        }
        static encode(y, k, _) {
            return (0,
            r.concat)(["0x1901", A.hashDomain(y), A.from(k).hash(_)])
        }
        static hash(y, k, _) {
            return (0,
            t.keccak256)(A.encode(y, k, _))
        }
        static async resolveNames(y, k, _, O) {
            y = Object.assign({}, y);
            for (const $ in y)
                y[$] == null && delete y[$];
            const L = {};
            y.verifyingContract && !(0,
            r.isHexString)(y.verifyingContract, 20) && (L[y.verifyingContract] = "0x");
            const U = A.from(k);
            U.visit(_, ($, B) => ($ === "address" && !(0,
            r.isHexString)(B, 20) && (L[B] = "0x"),
            B));
            for (const $ in L)
                L[$] = await O($);
            return y.verifyingContract && L[y.verifyingContract] && (y.verifyingContract = L[y.verifyingContract]),
            _ = U.visit(_, ($, B) => $ === "address" && L[B] ? L[B] : B),
            {
                domain: y,
                value: _
            }
        }
        static getPayload(y, k, _) {
            A.hashDomain(y);
            const O = {}
              , L = [];
            u.forEach(B => {
                const I = y[B];
                I != null && (O[B] = P[B](I),
                L.push({
                    name: B,
                    type: c[B]
                }))
            }
            );
const U = A.from(k);
            k = U.types;
            const $ = Object.assign({}, k);
            return (0,
            r.assertArgument)($.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", k),
            $.EIP712Domain = L,
            U.encode(_),
            {
                types: $,
                domain: O,
                primaryType: U.primaryType,
                message: U.visit(_, (B, I) => {
                    if (B.match(/^bytes(\d*)/))
                        return (0,
                        r.hexlify)((0,
                        r.getBytes)(I));
                    if (B.match(/^u?int/))
                        return (0,
                        r.getBigInt)(I).toString();
                    switch (B) {
                    case "address":
                        return I.toLowerCase();
                    case "bool":
                        return !!I;
                    case "string":
                        return (0,
                        r.assertArgument)(typeof I == "string", "invalid string", "value", I),
                        I
                    }
                    (0,
                    r.assertArgument)(!1, "unsupported type", "type", B)
                }
                )
            }
        }
    }
    ;
    w = new WeakMap,
    S = new WeakMap,
    T = new WeakMap,
    C = new WeakSet,
    Zu = function(y) {
        {
            const O = v(y);
            if (O)
                return O
        }
        const k = x(y).array;
        if (k) {
            const O = k.prefix
              , L = this.getEncoder(O);
            return U => {
                (0,
                r.assertArgument)(k.count === -1 || k.count === U.length, `array length mismatch; expected length ${k.count}`, "value", U);
                let $ = U.map(L);
                return j(this, S).has(O) && ($ = $.map(t.keccak256)),
                (0,
                t.keccak256)((0,
                r.concat)($))
            }
        }
        const _ = this.types[y];
        if (_) {
            const O = (0,
            n.id)(j(this, S).get(y));
            return L => {
                const U = _.map( ({name: $, type: B}) => {
                    const I = this.getEncoder(B)(L[$]);
                    return j(this, S).has(B) ? (0,
                    t.keccak256)(I) : I
                }
                );
                return U.unshift(O),
                (0,
                r.concat)(U)
            }
        }
        (0,
        r.assertArgument)(!1, `unknown type: ${y}`, "type", y)
    }
    ;
    let a = A;
    br.TypedDataEncoder = a;
    function E(R, y, k, _) {
        return (0,
        s.recoverAddress)(a.hash(R, y, k), _)
    }
    return br.verifyTypedData = E,
    br
}
var za;
function qt() {
    return za || (za = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.verifyTypedData = e.TypedDataEncoder = e.solidityPackedSha256 = e.solidityPackedKeccak256 = e.solidityPacked = e.verifyMessage = e.hashMessage = e.dnsEncode = e.namehash = e.isValidName = e.ensNormalize = e.id = e.verifyAuthorization = e.hashAuthorization = void 0;
        var t = af();
        Object.defineProperty(e, "hashAuthorization", {
            enumerable: !0,
            get: function() {
                return t.hashAuthorization
            }
        }),
        Object.defineProperty(e, "verifyAuthorization", {
            enumerable: !0,
            get: function() {
                return t.verifyAuthorization
            }
        });
        var s = Yu();
        Object.defineProperty(e, "id", {
            enumerable: !0,
            get: function() {
                return s.id
            }
        });
        var r = uf();
        Object.defineProperty(e, "ensNormalize", {
            enumerable: !0,
            get: function() {
                return r.ensNormalize
            }
        }),
        Object.defineProperty(e, "isValidName", {
            enumerable: !0,
            get: function() {
                return r.isValidName
            }
        }),
        Object.defineProperty(e, "namehash", {
            enumerable: !0,
            get: function() {
                return r.namehash
            }
        }),
        Object.defineProperty(e, "dnsEncode", {
            enumerable: !0,
            get: function() {
                return r.dnsEncode
            }
        });
        var n = lf();
        Object.defineProperty(e, "hashMessage", {
            enumerable: !0,
            get: function() {
                return n.hashMessage
            }
        }),
        Object.defineProperty(e, "verifyMessage", {
            enumerable: !0,
            get: function() {
                return n.verifyMessage
            }
        });
        var d = df();
        Object.defineProperty(e, "solidityPacked", {
            enumerable: !0,
            get: function() {
                return d.solidityPacked
            }
        }),
        Object.defineProperty(e, "solidityPackedKeccak256", {
            enumerable: !0,
            get: function() {
                return d.solidityPackedKeccak256
            }
        }),
        Object.defineProperty(e, "solidityPackedSha256", {
            enumerable: !0,
            get: function() {
                return d.solidityPackedSha256
            }
        });
        var h = ff();
        Object.defineProperty(e, "TypedDataEncoder", {
            enumerable: !0,
            get: function() {
                return h.TypedDataEncoder
            }
        }),
        Object.defineProperty(e, "verifyTypedData", {
            enumerable: !0,
            get: function() {
                return h.verifyTypedData
            }
        })
    }(si)),
    si
}
var Ka;
function Qi() {
    var re, M, K, wi, me, ps;
    if (Ka)
        return Xe;
    Ka = 1,
    Object.defineProperty(Xe, "__esModule", {
        value: !0
    }),
    Xe.StructFragment = Xe.FunctionFragment = Xe.FallbackFragment = Xe.ConstructorFragment = Xe.EventFragment = Xe.ErrorFragment = Xe.NamedFragment = Xe.Fragment = Xe.ParamType = void 0;
    const e = Be()
      , t = qt();
    function s(H) {
        const G = new Set;
        return H.forEach(q => G.add(q)),
        Object.freeze(G)
    }
    const n = s("external public payable override".split(" "))
      , d = "constant external internal payable private public pure view override"
      , h = s(d.split(" "))
      , m = "constructor error event fallback function receive struct"
      , f = s(m.split(" "))
      , i = "calldata memory storage payable indexed"
      , l = s(i.split(" "))
      , o = [m, i, "tuple returns", d].join(" ")
      , c = s(o.split(" "))
      , u = {
        "(": "OPEN_PAREN",
        ")": "CLOSE_PAREN",
        "[": "OPEN_BRACKET",
        "]": "CLOSE_BRACKET",
        ",": "COMMA",
        "@": "AT"
    }
      , g = new RegExp("^(\\s*)")
      , P = new RegExp("^([0-9]+)")
      , v = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)")
      , b = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$")
      , x = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$")
      , oe = class oe {
        constructor(G) {
            he(this, K);
            he(this, re);
            he(this, M);
            Q(this, re, 0),
            Q(this, M, G.slice())
        }
        get offset() {
            return j(this, re)
        }
        get length() {
            return j(this, M).length - j(this, re)
        }
        clone() {
            return new oe(j(this, M))
        }
        reset() {
            Q(this, re, 0)
        }
        popKeyword(G) {
            const q = this.peek();
            if (q.type !== "KEYWORD" || !G.has(q.text))
                throw new Error(`expected keyword ${q.text}`);
            return this.pop().text
        }
        popType(G) {
            if (this.peek().type !== G) {
                const q = this.peek();
                throw new Error(`expected ${G}; got ${q.type} ${JSON.stringify(q.text)}`)
            }
            return this.pop().text
        }
        popParen() {
            const G = this.peek();
            if (G.type !== "OPEN_PAREN")
                throw new Error("bad start");
            const q = we(this, K, wi).call(this, j(this, re) + 1, G.match + 1);
            return Q(this, re, G.match + 1),
            q
        }
        popParams() {
            const G = this.peek();
            if (G.type !== "OPEN_PAREN")
                throw new Error("bad start");
            const q = [];
            for (; j(this, re) < G.match - 1; ) {
                const ae = this.peek().linkNext;
                q.push(we(this, K, wi).call(this, j(this, re) + 1, ae)),
                Q(this, re, ae)
            }
            return Q(this, re, G.match + 1),
            q
        }
        peek() {
            if (j(this, re) >= j(this, M).length)
                throw new Error("out-of-bounds");
            return j(this, M)[j(this, re)]
        }
        peekKeyword(G) {
            const q = this.peekType("KEYWORD");
            return q != null && G.has(q) ? q : null
        }
        peekType(G) {
            if (this.length === 0)
                return null;
            const q = this.peek();
            return q.type === G ? q.text : null
        }
        pop() {
            const G = this.peek();
            return Br(this, re)._++,
            G
        }
        toString() {
            const G = [];
            for (let q = j(this, re); q < j(this, M).length; q++) {
                const ae = j(this, M)[q];
                G.push(`${ae.type}:${ae.text}`)
            }
            return `<TokenString ${G.join(" ")}>`
        }
    }
    ;
    re = new WeakMap,
    M = new WeakMap,
    K = new WeakSet,
    wi = function(G=0, q=0) {
        return new oe(j(this, M).slice(G, q).map(ae => Object.freeze(Object.assign({}, ae, {
            match: ae.match - G,
            linkBack: ae.linkBack - G,
            linkNext: ae.linkNext - G
        }))))
    }
    ;
    let a = oe;
    function E(H) {
        const G = []
          , q = D => {
            const X = J < H.length ? JSON.stringify(H[J]) : "$EOI";
            throw new Error(`invalid token ${X} at ${J}: ${D}`)
        }
        ;
        let ae = []
          , Z = []
          , J = 0;
        for (; J < H.length; ) {
            let D = H.substring(J)
              , X = D.match(g);
            X && (J += X[1].length,
            D = H.substring(J));
            const ce = {
                depth: ae.length,
                linkBack: -1,
                linkNext: -1,
                match: -1,
                type: "",
                text: "",
                offset: J,
                value: -1
            };
            G.push(ce);
            let pe = u[D[0]] || "";
            if (pe) {
                if (ce.type = pe,
                ce.text = D[0],
                J++,
                pe === "OPEN_PAREN")
                    ae.push(G.length - 1),
                    Z.push(G.length - 1);
                else if (pe == "CLOSE_PAREN")
                    ae.length === 0 && q("no matching open bracket"),
                    ce.match = ae.pop(),
                    G[ce.match].match = G.length - 1,
                    ce.depth--,
                    ce.linkBack = Z.pop(),
                    G[ce.linkBack].linkNext = G.length - 1;
                else if (pe === "COMMA")
                    ce.linkBack = Z.pop(),
                    G[ce.linkBack].linkNext = G.length - 1,
                    Z.push(G.length - 1);
                else if (pe === "OPEN_BRACKET")
                    ce.type = "BRACKET";
                else if (pe === "CLOSE_BRACKET") {
                    let ve = G.pop().text;
                    if (G.length > 0 && G[G.length - 1].type === "NUMBER") {
                        const Oe = G.pop().text;
                        ve = Oe + ve,
                        G[G.length - 1].value = (0,
                        e.getNumber)(Oe)
                    }
                    if (G.length === 0 || G[G.length - 1].type !== "BRACKET")
                        throw new Error("missing opening bracket");
                    G[G.length - 1].text += ve
                }
                continue
            }
            if (X = D.match(v),
            X) {
                if (ce.text = X[1],
                J += ce.text.length,
                c.has(ce.text)) {
                    ce.type = "KEYWORD";
                    continue
                }
                if (ce.text.match(x)) {
                    ce.type = "TYPE";
                    continue
                }
                ce.type = "ID";
                continue
            }
            if (X = D.match(P),
            X) {
                ce.text = X[1],
                ce.type = "NUMBER",
                J += ce.text.length;
                continue
            }
            throw new Error(`unexpected token ${JSON.stringify(D[0])} at position ${J}`)
        }
        return new a(G.map(D => Object.freeze(D)))
    }
    function w(H, G) {
        let q = [];
        for (const ae in G.keys())
            H.has(ae) && q.push(ae);
        if (q.length > 1)
            throw new Error(`conflicting types: ${q.join(", ")}`)
    }
    function S(H, G) {
        if (G.peekKeyword(f)) {
            const q = G.pop().text;
            if (q !== H)
                throw new Error(`expected ${H}, got ${q}`)
        }
        return G.popType("ID")
    }
    function T(H, G) {
        const q = new Set;
        for (; ; ) {
            const ae = H.peekType("KEYWORD");
            if (ae == null || G && !G.has(ae))
                break;
            if (H.pop(),
            q.has(ae))
                throw new Error(`duplicate keywords: ${JSON.stringify(ae)}`);
            q.add(ae)
        }
        return Object.freeze(q)
    }
    function C(H) {
        let G = T(H, h);
        return w(G, s("constant payable nonpayable".split(" "))),
        w(G, s("pure view payable nonpayable".split(" "))),
        G.has("view") ? "view" : G.has("pure") ? "pure" : G.has("payable") ? "payable" : G.has("nonpayable") ? "nonpayable" : G.has("constant") ? "view" : "nonpayable"
    }
    function N(H, G) {
        return H.popParams().map(q => Y.from(q, G))
    }
    function A(H) {
        if (H.peekType("AT")) {
            if (H.pop(),
            H.peekType("NUMBER"))
                return (0,
                e.getBigInt)(H.pop().text);
            throw new Error("invalid gas")
        }
        return null
    }
    function R(H) {
        if (H.length)
            throw new Error(`unexpected tokens at offset ${H.offset}: ${H.toString()}`)
    }
    const y = new RegExp(/^(.*)\[([0-9]*)\]$/);
    function k(H) {
        const G = H.match(x);
        if ((0,
        e.assertArgument)(G, "invalid type", "type", H),
        H === "uint")
            return "uint256";
        if (H === "int")
            return "int256";
        if (G[2]) {
            const q = parseInt(G[2]);
            (0,
            e.assertArgument)(q !== 0 && q <= 32, "invalid bytes length", "type", H)
        } else if (G[3]) {
            const q = parseInt(G[3]);
            (0,
            e.assertArgument)(q !== 0 && q <= 256 && q % 8 === 0, "invalid numeric width", "type", H)
        }
        return H
    }
    const _ = {}
      , O = Symbol.for("_ethers_internal")
      , L = "_ParamTypeInternal"
      , U = "_ErrorInternal"
      , $ = "_EventInternal"
      , B = "_ConstructorInternal"
      , I = "_FallbackInternal"
      , F = "_FunctionInternal"
      , z = "_StructInternal"
      , se = class se {
        constructor(G, q, ae, Z, J, D, X, ce) {
            he(this, me);
            ue(this, "name");
            ue(this, "type");
            ue(this, "baseType");
            ue(this, "indexed");
            ue(this, "components");
            ue(this, "arrayLength");
            ue(this, "arrayChildren");
            if ((0,
            e.assertPrivate)(G, _, "ParamType"),
            Object.defineProperty(this, O, {
                value: L
            }),
            D && (D = Object.freeze(D.slice())),
            Z === "array") {
                if (X == null || ce == null)
                    throw new Error("")
            } else if (X != null || ce != null)
                throw new Error("");
            if (Z === "tuple") {
                if (D == null)
                    throw new Error("")
            } else if (D != null)
                throw new Error("");
            (0,
            e.defineProperties)(this, {
                name: q,
                type: ae,
                baseType: Z,
                indexed: J,
                components: D,
                arrayLength: X,
                arrayChildren: ce
            })
        }
        format(G) {
            if (G == null && (G = "sighash"),
            G === "json") {
                const ae = this.name || "";
                if (this.isArray()) {
                    const J = JSON.parse(this.arrayChildren.format("json"));
                    return J.name = ae,
                    J.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`,
                    JSON.stringify(J)
                }
                const Z = {
                    type: this.baseType === "tuple" ? "tuple" : this.type,
                    name: ae
                };
                return typeof this.indexed == "boolean" && (Z.indexed = this.indexed),
                this.isTuple() && (Z.components = this.components.map(J => JSON.parse(J.format(G)))),
                JSON.stringify(Z)
            }
            let q = "";
            return this.isArray() ? (q += this.arrayChildren.format(G),
            q += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`) : this.isTuple() ? q += "(" + this.components.map(ae => ae.format(G)).join(G === "full" ? ", " : ",") + ")" : q += this.type,
            G !== "sighash" && (this.indexed === !0 && (q += " indexed"),
            G === "full" && this.name && (q += " " + this.name)),
            q
        }
        isArray() {
            return this.baseType === "array"
        }
        isTuple() {
            return this.baseType === "tuple"
        }
        isIndexable() {
            return this.indexed != null
        }
        walk(G, q) {
            if (this.isArray()) {
                if (!Array.isArray(G))
                    throw new Error("invalid array value");
                if (this.arrayLength !== -1 && G.length !== this.arrayLength)
                    throw new Error("array is wrong length");
                const ae = this;
                return G.map(Z => ae.arrayChildren.walk(Z, q))
            }
            if (this.isTuple()) {
                if (!Array.isArray(G))
                    throw new Error("invalid tuple value");
                if (G.length !== this.components.length)
                    throw new Error("array is wrong length");
                const ae = this;
                return G.map( (Z, J) => ae.components[J].walk(Z, q))
            }
            return q(this.type, G)
        }
        async walkAsync(G, q) {
            const ae = []
              , Z = [G];
            return we(this, me, ps).call(this, ae, G, q, J => {
                Z[0] = J
            }
            ),
            ae.length && await Promise.all(ae),
            Z[0]
        }
        static from(G, q) {
            if (se.isParamType(G))
                return G;
            if (typeof G == "string")
                try {
                    return se.from(E(G), q)
                } catch {
                    (0,
                    e.assertArgument)(!1, "invalid param type", "obj", G)
                }
            else if (G instanceof a) {
                let X = ""
                  , ce = ""
                  , pe = null;
                T(G, s(["tuple"])).has("tuple") || G.peekType("OPEN_PAREN") ? (ce = "tuple",
                pe = G.popParams().map($e => se.from($e)),
                X = `tuple(${pe.map($e => $e.format()).join(",")})`) : (X = k(G.popType("TYPE")),
                ce = X);
                let ve = null
                  , Oe = null;
                for (; G.length && G.peekType("BRACKET"); ) {
                    const $e = G.pop();
                    ve = new se(_,"",X,ce,null,pe,Oe,ve),
                    Oe = $e.value,
                    X += $e.text,
                    ce = "array",
                    pe = null
                }
                let Ge = null;
                if (T(G, l).has("indexed")) {
                    if (!q)
                        throw new Error("");
                    Ge = !0
                }
                const je = G.peekType("ID") ? G.pop().text : "";
                if (G.length)
                    throw new Error("leftover tokens");
                return new se(_,je,X,ce,Ge,pe,Oe,ve)
            }
            const ae = G.name;
            (0,
            e.assertArgument)(!ae || typeof ae == "string" && ae.match(b), "invalid name", "obj.name", ae);
            let Z = G.indexed;
            Z != null && ((0,
            e.assertArgument)(q, "parameter cannot be indexed", "obj.indexed", G.indexed),
            Z = !!Z);
            let J = G.type
              , D = J.match(y);
            if (D) {
                const X = parseInt(D[2] || "-1")
                  , ce = se.from({
                    type: D[1],
                    components: G.components
                });
                return new se(_,ae || "",J,"array",Z,null,X,ce)
            }
            if (J === "tuple" || J.startsWith("tuple(") || J.startsWith("(")) {
                const X = G.components != null ? G.components.map(pe => se.from(pe)) : null;
                return new se(_,ae || "",J,"tuple",Z,X,null,null)
            }
            return J = k(G.type),
            new se(_,ae || "",J,J,Z,null,null,null)
        }
        static isParamType(G) {
            return G && G[O] === L
        }
    }
    ;
    me = new WeakSet,
    ps = function(G, q, ae, Z) {
        if (this.isArray()) {
            if (!Array.isArray(q))
                throw new Error("invalid array value");
            if (this.arrayLength !== -1 && q.length !== this.arrayLength)
                throw new Error("array is wrong length");
            const D = this.arrayChildren
              , X = q.slice();
            X.forEach( (ce, pe) => {
                var ve;
                we(ve = D, me, ps).call(ve, G, ce, ae, Oe => {
                    X[pe] = Oe
                }
                )
            }
            ),
            Z(X);
            return
        }
        if (this.isTuple()) {
            const D = this.components;
            let X;
            if (Array.isArray(q))
                X = q.slice();
            else {
                if (q == null || typeof q != "object")
                    throw new Error("invalid tuple value");
                X = D.map(ce => {
                    if (!ce.name)
                        throw new Error("cannot use object value with unnamed components");
                    if (!(ce.name in q))
                        throw new Error(`missing value for component ${ce.name}`);
                    return q[ce.name]
                }
                )
            }
            if (X.length !== this.components.length)
                throw new Error("array is wrong length");
            X.forEach( (ce, pe) => {
                var ve;
                we(ve = D[pe], me, ps).call(ve, G, ce, ae, Oe => {
                    X[pe] = Oe
                }
                )
            }
            ),
            Z(X);
            return
        }
        const J = ae(this.type, q);
        J.then ? G.push(async function() {
            Z(await J)
        }()) : Z(J)
    }
    ;
    let Y = se;
    Xe.ParamType = Y;
    class ie {
        constructor(G, q, ae) {
            ue(this, "type");
            ue(this, "inputs");
            (0,
            e.assertPrivate)(G, _, "Fragment"),
            ae = Object.freeze(ae.slice()),
            (0,
            e.defineProperties)(this, {
                type: q,
                inputs: ae
            })
        }
        static from(G) {
            if (typeof G == "string") {
                try {
                    ie.from(JSON.parse(G))
                } catch {}
                return ie.from(E(G))
            }
            if (G instanceof a)
                switch (G.peekKeyword(f)) {
                case "constructor":
                    return te.from(G);
                case "error":
                    return W.from(G);
                case "event":
                    return ee.from(G);
                case "fallback":
                case "receive":
                    return fe.from(G);
                case "function":
                    return be.from(G);
                case "struct":
                    return le.from(G)
                }
            else if (typeof G == "object") {
                switch (G.type) {
                case "constructor":
                    return te.from(G);
                case "error":
                    return W.from(G);
                case "event":
                    return ee.from(G);
                case "fallback":
                case "receive":
                    return fe.from(G);
                case "function":
                    return be.from(G);
                case "struct":
                    return le.from(G)
                }
                (0,
                e.assert)(!1, `unsupported type: ${G.type}`, "UNSUPPORTED_OPERATION", {
                    operation: "Fragment.from"
                })
            }
            (0,
            e.assertArgument)(!1, "unsupported frgament object", "obj", G)
        }
        static isConstructor(G) {
            return te.isFragment(G)
        }
        static isError(G) {
            return W.isFragment(G)
        }
        static isEvent(G) {
            return ee.isFragment(G)
        }
        static isFunction(G) {
            return be.isFragment(G)
        }
        static isStruct(G) {
            return le.isFragment(G)
        }
    }
    Xe.Fragment = ie;
    class ne extends ie {
        constructor(q, ae, Z, J) {
            super(q, ae, J);
            ue(this, "name");
            (0,
            e.assertArgument)(typeof Z == "string" && Z.match(b), "invalid identifier", "name", Z),
            J = Object.freeze(J.slice()),
            (0,
            e.defineProperties)(this, {
                name: Z
            })
        }
    }
    Xe.NamedFragment = ne;
    function xe(H, G) {
        return "(" + G.map(q => q.format(H)).join(H === "full" ? ", " : ",") + ")"
    }
    class W extends ne {
        constructor(G, q, ae) {
            super(G, "error", q, ae),
            Object.defineProperty(this, O, {
                value: U
            })
        }
        get selector() {
            return (0,
            t.id)(this.format("sighash")).substring(0, 10)
        }
        format(G) {
            if (G == null && (G = "sighash"),
            G === "json")
                return JSON.stringify({
                    type: "error",
                    name: this.name,
                    inputs: this.inputs.map(ae => JSON.parse(ae.format(G)))
                });
            const q = [];
            return G !== "sighash" && q.push("error"),
            q.push(this.name + xe(G, this.inputs)),
            q.join(" ")
        }
        static from(G) {
            if (W.isFragment(G))
                return G;
            if (typeof G == "string")
                return W.from(E(G));
            if (G instanceof a) {
                const q = S("error", G)
                  , ae = N(G);
                return R(G),
                new W(_,q,ae)
            }
            return new W(_,G.name,G.inputs ? G.inputs.map(Y.from) : [])
        }
        static isFragment(G) {
            return G && G[O] === U
        }
    }
    Xe.ErrorFragment = W;
    class ee extends ne {
        constructor(q, ae, Z, J) {
            super(q, "event", ae, Z);
            ue(this, "anonymous");
            Object.defineProperty(this, O, {
                value: $
            }),
            (0,
            e.defineProperties)(this, {
                anonymous: J
            })
        }
        get topicHash() {
            return (0,
            t.id)(this.format("sighash"))
        }
        format(q) {
            if (q == null && (q = "sighash"),
            q === "json")
                return JSON.stringify({
                    type: "event",
                    anonymous: this.anonymous,
                    name: this.name,
                    inputs: this.inputs.map(Z => JSON.parse(Z.format(q)))
                });
            const ae = [];
            return q !== "sighash" && ae.push("event"),
            ae.push(this.name + xe(q, this.inputs)),
            q !== "sighash" && this.anonymous && ae.push("anonymous"),
            ae.join(" ")
        }
        static getTopicHash(q, ae) {
            return ae = (ae || []).map(J => Y.from(J)),
            new ee(_,q,ae,!1).topicHash
        }
        static from(q) {
            if (ee.isFragment(q))
                return q;
            if (typeof q == "string")
                try {
                    return ee.from(E(q))
                } catch {
                    (0,
                    e.assertArgument)(!1, "invalid event fragment", "obj", q)
                }
            else if (q instanceof a) {
                const ae = S("event", q)
                  , Z = N(q, !0)
                  , J = !!T(q, s(["anonymous"])).has("anonymous");
                return R(q),
                new ee(_,ae,Z,J)
            }
            return new ee(_,q.name,q.inputs ? q.inputs.map(ae => Y.from(ae, !0)) : [],!!q.anonymous)
        }
        static isFragment(q) {
            return q && q[O] === $
        }
    }
    Xe.EventFragment = ee;
    class te extends ie {
        constructor(q, ae, Z, J, D) {
            super(q, ae, Z);
            ue(this, "payable");
            ue(this, "gas");
            Object.defineProperty(this, O, {
                value: B
            }),
            (0,
            e.defineProperties)(this, {
                payable: J,
                gas: D
            })
        }
        format(q) {
            if ((0,
            e.assert)(q != null && q !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
                operation: "format(sighash)"
            }),
            q === "json")
                return JSON.stringify({
                    type: "constructor",
                    stateMutability: this.payable ? "payable" : "undefined",
                    payable: this.payable,
                    gas: this.gas != null ? this.gas : void 0,
                    inputs: this.inputs.map(Z => JSON.parse(Z.format(q)))
                });
            const ae = [`constructor${xe(q, this.inputs)}`];
            return this.payable && ae.push("payable"),
            this.gas != null && ae.push(`@${this.gas.toString()}`),
            ae.join(" ")
        }
        static from(q) {
            if (te.isFragment(q))
                return q;
            if (typeof q == "string")
                try {
                    return te.from(E(q))
                } catch {
                    (0,
                    e.assertArgument)(!1, "invalid constuctor fragment", "obj", q)
                }
            else if (q instanceof a) {
                T(q, s(["constructor"]));
                const ae = N(q)
                  , Z = !!T(q, n).has("payable")
                  , J = A(q);
                return R(q),
                new te(_,"constructor",ae,Z,J)
            }
            return new te(_,"constructor",q.inputs ? q.inputs.map(Y.from) : [],!!q.payable,q.gas != null ? q.gas : null)
        }
        static isFragment(q) {
            return q && q[O] === B
        }
    }
    Xe.ConstructorFragment = te;
    class fe extends ie {
        constructor(q, ae, Z) {
            super(q, "fallback", ae);
            ue(this, "payable");
            Object.defineProperty(this, O, {
                value: I
            }),
            (0,
            e.defineProperties)(this, {
                payable: Z
            })
        }
        format(q) {
            const ae = this.inputs.length === 0 ? "receive" : "fallback";
            if (q === "json") {
                const Z = this.payable ? "payable" : "nonpayable";
                return JSON.stringify({
                    type: ae,
                    stateMutability: Z
                })
            }
            return `${ae}()${this.payable ? " payable" : ""}`
        }
        static from(q) {
            if (fe.isFragment(q))
                return q;
            if (typeof q == "string")
                try {
                    return fe.from(E(q))
                } catch {
                    (0,
                    e.assertArgument)(!1, "invalid fallback fragment", "obj", q)
                }
            else if (q instanceof a) {
                const ae = q.toString()
                  , Z = q.peekKeyword(s(["fallback", "receive"]));
                if ((0,
                e.assertArgument)(Z, "type must be fallback or receive", "obj", ae),
                q.popKeyword(s(["fallback", "receive"])) === "receive") {
                    const ce = N(q);
                    return (0,
                    e.assertArgument)(ce.length === 0, "receive cannot have arguments", "obj.inputs", ce),
                    T(q, s(["payable"])),
                    R(q),
                    new fe(_,[],!0)
                }
                let D = N(q);
                D.length ? (0,
                e.assertArgument)(D.length === 1 && D[0].type === "bytes", "invalid fallback inputs", "obj.inputs", D.map(ce => ce.format("minimal")).join(", ")) : D = [Y.from("bytes")];
                const X = C(q);
                if ((0,
                e.assertArgument)(X === "nonpayable" || X === "payable", "fallback cannot be constants", "obj.stateMutability", X),
                T(q, s(["returns"])).has("returns")) {
                    const ce = N(q);
                    (0,
                    e.assertArgument)(ce.length === 1 && ce[0].type === "bytes", "invalid fallback outputs", "obj.outputs", ce.map(pe => pe.format("minimal")).join(", "))
                }
                return R(q),
                new fe(_,D,X === "payable")
            }
            if (q.type === "receive")
                return new fe(_,[],!0);
            if (q.type === "fallback") {
                const ae = [Y.from("bytes")]
                  , Z = q.stateMutability === "payable";
                return new fe(_,ae,Z)
            }
            (0,
            e.assertArgument)(!1, "invalid fallback description", "obj", q)
        }
        static isFragment(q) {
            return q && q[O] === I
        }
    }
    Xe.FallbackFragment = fe;
    class be extends ne {
        constructor(q, ae, Z, J, D, X) {
            super(q, "function", ae, J);
            ue(this, "constant");
            ue(this, "outputs");
            ue(this, "stateMutability");
            ue(this, "payable");
            ue(this, "gas");
            Object.defineProperty(this, O, {
                value: F
            }),
            D = Object.freeze(D.slice());
            const ce = Z === "view" || Z === "pure"
              , pe = Z === "payable";
            (0,
            e.defineProperties)(this, {
                constant: ce,
                gas: X,
                outputs: D,
                payable: pe,
                stateMutability: Z
            })
        }
        get selector() {
            return (0,
            t.id)(this.format("sighash")).substring(0, 10)
        }
        format(q) {
            if (q == null && (q = "sighash"),
            q === "json")
                return JSON.stringify({
                    type: "function",
                    name: this.name,
                    constant: this.constant,
                    stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
                    payable: this.payable,
                    gas: this.gas != null ? this.gas : void 0,
                    inputs: this.inputs.map(Z => JSON.parse(Z.format(q))),
                    outputs: this.outputs.map(Z => JSON.parse(Z.format(q)))
                });
            const ae = [];
            return q !== "sighash" && ae.push("function"),
            ae.push(this.name + xe(q, this.inputs)),
            q !== "sighash" && (this.stateMutability !== "nonpayable" && ae.push(this.stateMutability),
            this.outputs && this.outputs.length && (ae.push("returns"),
            ae.push(xe(q, this.outputs))),
            this.gas != null && ae.push(`@${this.gas.toString()}`)),
            ae.join(" ")
        }
        static getSelector(q, ae) {
            return ae = (ae || []).map(J => Y.from(J)),
            new be(_,q,"view",ae,[],null).selector
        }
        static from(q) {
            if (be.isFragment(q))
                return q;
            if (typeof q == "string")
                try {
                    return be.from(E(q))
                } catch {
                    (0,
                    e.assertArgument)(!1, "invalid function fragment", "obj", q)
                }
            else if (q instanceof a) {
                const Z = S("function", q)
                  , J = N(q)
                  , D = C(q);
                let X = [];
                T(q, s(["returns"])).has("returns") && (X = N(q));
                const ce = A(q);
                return R(q),
                new be(_,Z,D,J,X,ce)
            }
            let ae = q.stateMutability;
            return ae == null && (ae = "payable",
            typeof q.constant == "boolean" ? (ae = "view",
            q.constant || (ae = "payable",
            typeof q.payable == "boolean" && !q.payable && (ae = "nonpayable"))) : typeof q.payable == "boolean" && !q.payable && (ae = "nonpayable")),
            new be(_,q.name,ae,q.inputs ? q.inputs.map(Y.from) : [],q.outputs ? q.outputs.map(Y.from) : [],q.gas != null ? q.gas : null)
        }
        static isFragment(q) {
            return q && q[O] === F
        }
    }
    Xe.FunctionFragment = be;
    class le extends ne {
        constructor(G, q, ae) {
            super(G, "struct", q, ae),
            Object.defineProperty(this, O, {
                value: z
            })
        }
        format() {
            throw new Error("@TODO")
        }
        static from(G) {
            if (typeof G == "string")
                try {
                    return le.from(E(G))
                } catch {
                    (0,
                    e.assertArgument)(!1, "invalid struct fragment", "obj", G)
                }
            else if (G instanceof a) {
                const q = S("struct", G)
                  , ae = N(G);
                return R(G),
                new le(_,q,ae)
            }
            return new le(_,G.name,G.inputs ? G.inputs.map(Y.from) : [])
        }
        static isFragment(G) {
            return G && G[O] === z
        }
    }
    return Xe.StructFragment = le,
    Xe
}
var Va;
function Xu() {
    var E, Cr;
    if (Va)
        return Hr;
    Va = 1,
    Object.defineProperty(Hr, "__esModule", {
        value: !0
    }),
    Hr.AbiCoder = void 0;
    const e = Be()
      , t = Bt()
      , s = Yd()
      , r = Ku()
      , n = Xd()
      , d = Vu()
      , h = ef()
      , m = tf()
      , f = rf()
      , i = nf()
      , l = sf()
      , p = Qi()
      , o = tt()
      , c = Be()
      , u = new Map;
    u.set(0, "GENERIC_PANIC"),
    u.set(1, "ASSERT_FALSE"),
    u.set(17, "OVERFLOW"),
    u.set(18, "DIVIDE_BY_ZERO"),
    u.set(33, "ENUM_RANGE_ERROR"),
    u.set(34, "BAD_STORAGE_DATA"),
    u.set(49, "STACK_UNDERFLOW"),
    u.set(50, "ARRAY_RANGE_ERROR"),
    u.set(65, "OUT_OF_MEMORY"),
    u.set(81, "UNINITIALIZED_FUNCTION_CALL");
    const g = new RegExp(/^bytes([0-9]*)$/)
      , P = new RegExp(/^(u?int)([0-9]*)$/);
    let v = null
      , b = 1024;
    function x(T, C, N, A) {
        let R = "missing revert data"
          , y = null;
        const k = null;
        let _ = null;
        if (N) {
            R = "execution reverted";
            const L = (0,
            c.getBytes)(N);
            if (N = (0,
            c.hexlify)(N),
            L.length === 0)
                R += " (no data present; likely require(false) occurred",
                y = "require(false)";
            else if (L.length % 32 !== 4)
                R += " (could not decode reason; invalid data length)";
            else if ((0,
            c.hexlify)(L.slice(0, 4)) === "0x08c379a0")
                try {
                    y = A.decode(["string"], L.slice(4))[0],
                    _ = {
                        signature: "Error(string)",
                        name: "Error",
                        args: [y]
                    },
                    R += `: ${JSON.stringify(y)}`
                } catch {
                    R += " (could not decode reason; invalid string data)"
                }
            else if ((0,
            c.hexlify)(L.slice(0, 4)) === "0x4e487b71")
                try {
                    const U = Number(A.decode(["uint256"], L.slice(4))[0]);
                    _ = {
                        signature: "Panic(uint256)",
                        name: "Panic",
                        args: [U]
                    },
                    y = `Panic due to ${u.get(U) || "UNKNOWN"}(${U})`,
                    R += `: ${y}`
                } catch {
                    R += " (could not decode panic code)"
                }
            else
                R += " (unknown custom error)"
        }
        const O = {
            to: C.to ? (0,
            o.getAddress)(C.to) : null,
            data: C.data || "0x"
        };
        return C.from && (O.from = (0,
        o.getAddress)(C.from)),
        (0,
        c.makeError)(R, "CALL_EXCEPTION", {
            action: T,
            data: N,
            reason: y,
            transaction: O,
            invocation: k,
            revert: _
        })
    }
    const S = class S {
        constructor() {
            he(this, E)
        }
        getDefaultValue(C) {
            const N = C.map(R => we(this, E, Cr).call(this, p.ParamType.from(R)));
            return new l.TupleCoder(N,"_").defaultValue()
        }
        encode(C, N) {
            (0,
            e.assertArgumentCount)(N.length, C.length, "types/values length mismatch");
            const A = C.map(k => we(this, E, Cr).call(this, p.ParamType.from(k)))
              , R = new l.TupleCoder(A,"_")
              , y = new t.Writer;
            return R.encode(y, N),
            y.data
        }
        decode(C, N, A) {
            const R = C.map(k => we(this, E, Cr).call(this, p.ParamType.from(k)));
            return new l.TupleCoder(R,"_").decode(new t.Reader(N,A,b))
        }
        static _setDefaultMaxInflation(C) {
            (0,
            e.assertArgument)(typeof C == "number" && Number.isInteger(C), "invalid defaultMaxInflation factor", "value", C),
            b = C
        }
        static defaultAbiCoder() {
            return v == null && (v = new S),
            v
        }
        static getBuiltinCallException(C, N, A) {
            return x(C, N, A, S.defaultAbiCoder())
        }
    }
    ;
    E = new WeakSet,
    Cr = function(C) {
        if (C.isArray())
            return new r.ArrayCoder(we(this, E, Cr).call(this, C.arrayChildren),C.arrayLength,C.name);
        if (C.isTuple())
            return new l.TupleCoder(C.components.map(A => we(this, E, Cr).call(this, A)),C.name);
        switch (C.baseType) {
        case "address":
            return new s.AddressCoder(C.name);
        case "bool":
            return new n.BooleanCoder(C.name);
        case "string":
            return new i.StringCoder(C.name);
        case "bytes":
            return new d.BytesCoder(C.name);
        case "":
            return new m.NullCoder(C.name)
        }
        let N = C.type.match(P);
        if (N) {
            let A = parseInt(N[2] || "256");
            return (0,
            e.assertArgument)(A !== 0 && A <= 256 && A % 8 === 0, "invalid " + N[1] + " bit length", "param", C),
            new f.NumberCoder(A / 8,N[1] === "int",C.name)
        }
        if (N = C.type.match(g),
        N) {
            let A = parseInt(N[1]);
            return (0,
            e.assertArgument)(A !== 0 && A <= 32, "invalid bytes length", "param", C),
            new h.FixedBytesCoder(A,C.name)
        }
        (0,
        e.assertArgument)(!1, "invalid type", "type", C.type)
    }
    ;
    let a = S;
    return Hr.AbiCoder = a,
    Hr
}
var gr = {}, Ja;
function hf() {
    if (Ja)
        return gr;
    Ja = 1,
    Object.defineProperty(gr, "__esModule", {
        value: !0
    }),
    gr.decodeBytes32String = gr.encodeBytes32String = void 0;
    const e = Be();
    function t(r) {
        const n = (0,
        e.toUtf8Bytes)(r);
        if (n.length > 31)
            throw new Error("bytes32 string must be less than 32 bytes");
        return (0,
        e.zeroPadBytes)(n, 32)
    }
    gr.encodeBytes32String = t;
    function s(r) {
        const n = (0,
        e.getBytes)(r, "bytes");
        if (n.length !== 32)
            throw new Error("invalid bytes32 - not 32 bytes long");
        if (n[31] !== 0)
            throw new Error("invalid bytes32 string - no null terminator");
        let d = 31;
        for (; n[d - 1] === 0; )
            d--;
        return (0,
        e.toUtf8String)(n.slice(0, d))
    }
    return gr.decodeBytes32String = s,
    gr
}
var oi = {}, Qa;
function pf() {
    return Qa || (Qa = 1,
    function(e) {
        var g, P, v, b, x, bs, gs;
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.Interface = e.Indexed = e.ErrorDescription = e.TransactionDescription = e.LogDescription = e.Result = e.checkResultErrors = void 0;
        const t = st()
          , s = qt()
          , r = Be()
          , n = Xu()
          , d = Bt();
        Object.defineProperty(e, "checkResultErrors", {
            enumerable: !0,
            get: function() {
                return d.checkResultErrors
            }
        }),
        Object.defineProperty(e, "Result", {
            enumerable: !0,
            get: function() {
                return d.Result
            }
        });
        const h = Qi()
          , m = $t();
        class f {
            constructor(T, C, N) {
                ue(this, "fragment");
                ue(this, "name");
                ue(this, "signature");
                ue(this, "topic");
                ue(this, "args");
                const A = T.name
                  , R = T.format();
                (0,
                r.defineProperties)(this, {
                    fragment: T,
                    name: A,
                    signature: R,
                    topic: C,
                    args: N
                })
            }
        }
        e.LogDescription = f;
        class i {
            constructor(T, C, N, A) {
                ue(this, "fragment");
                ue(this, "name");
                ue(this, "args");
                ue(this, "signature");
                ue(this, "selector");
                ue(this, "value");
                const R = T.name
                  , y = T.format();
                (0,
                r.defineProperties)(this, {
                    fragment: T,
                    name: R,
                    args: N,
                    signature: y,
                    selector: C,
                    value: A
                })
            }
        }
        e.TransactionDescription = i;
        class l {
            constructor(T, C, N) {
                ue(this, "fragment");
                ue(this, "name");
                ue(this, "args");
                ue(this, "signature");
                ue(this, "selector");
                const A = T.name
                  , R = T.format();
                (0,
                r.defineProperties)(this, {
                    fragment: T,
                    name: A,
                    args: N,
                    signature: R,
                    selector: C
                })
            }
        }
        e.ErrorDescription = l;
        class p {
            constructor(T) {
                ue(this, "hash");
                ue(this, "_isIndexed");
                (0,
                r.defineProperties)(this, {
                    hash: T,
                    _isIndexed: !0
                })
            }
            static isIndexed(T) {
                return !!(T && T._isIndexed)
            }
        }
        e.Indexed = p;
        const o = {
            0: "generic panic",
            1: "assert(false)",
            17: "arithmetic overflow",
            18: "division or modulo by zero",
            33: "enum overflow",
            34: "invalid encoded storage byte array accessed",
            49: "out-of-bounds array access; popping on an empty array",
            50: "out-of-bounds access of an array or bytesN",
            65: "out of memory",
            81: "uninitialized function"
        }
          , c = {
            "0x08c379a0": {
                signature: "Error(string)",
                name: "Error",
                inputs: ["string"],
                reason: S => `reverted with reason string ${JSON.stringify(S)}`
            },
            "0x4e487b71": {
                signature: "Panic(uint256)",
                name: "Panic",
                inputs: ["uint256"],
                reason: S => {
                    let T = "unknown panic code";
                    return S >= 0 && S <= 255 && o[S.toString()] && (T = o[S.toString()]),
                    `reverted with panic code 0x${S.toString(16)} (${T})`
                }
            }
        }
          , w = class w {
            constructor(T) {
                he(this, x);
                ue(this, "fragments");
                ue(this, "deploy");
                ue(this, "fallback");
                ue(this, "receive");
                he(this, g);
                he(this, P);
                he(this, v);
                he(this, b);
                let C = [];
                typeof T == "string" ? C = JSON.parse(T) : C = T,
                Q(this, v, new Map),
                Q(this, g, new Map),
                Q(this, P, new Map);
                const N = [];
                for (const y of C)
                    try {
                        N.push(h.Fragment.from(y))
                    } catch (k) {
                        console.log(`[Warning] Invalid Fragment ${JSON.stringify(y)}:`, k.message)
                    }
                (0,
                r.defineProperties)(this, {
                    fragments: Object.freeze(N)
                });
                let A = null
                  , R = !1;
                Q(this, b, this.getAbiCoder()),
                this.fragments.forEach( (y, k) => {
                    let _;
                    switch (y.type) {
                    case "constructor":
                        if (this.deploy) {
                            console.log("duplicate definition - constructor");
                            return
                        }
                        (0,
                        r.defineProperties)(this, {
                            deploy: y
                        });
                        return;
                    case "fallback":
                        y.inputs.length === 0 ? R = !0 : ((0,
                        r.assertArgument)(!A || y.payable !== A.payable, "conflicting fallback fragments", `fragments[${k}]`, y),
                        A = y,
                        R = A.payable);
                        return;
                    case "function":
                        _ = j(this, v);
                        break;
                    case "event":
                        _ = j(this, P);
                        break;
                    case "error":
                        _ = j(this, g);
                        break;
                    default:
                        return
                    }
                    const O = y.format();
                    _.has(O) || _.set(O, y)
                }
                ),
                this.deploy || (0,
                r.defineProperties)(this, {
                    deploy: h.ConstructorFragment.from("constructor()")
                }),
                (0,
                r.defineProperties)(this, {
                    fallback: A,
                    receive: R
                })
            }
            format(T) {
                const C = T ? "minimal" : "full";
                return this.fragments.map(A => A.format(C))
            }
            formatJson() {
                const T = this.fragments.map(C => C.format("json"));
                return JSON.stringify(T.map(C => JSON.parse(C)))
            }
            getAbiCoder() {
                return n.AbiCoder.defaultAbiCoder()
            }
            getFunctionName(T) {
                const C = we(this, x, bs).call(this, T, null, !1);
                return (0,
                r.assertArgument)(C, "no matching function", "key", T),
                C.name
            }
            hasFunction(T) {
                return !!we(this, x, bs).call(this, T, null, !1)
            }
            getFunction(T, C) {
                return we(this, x, bs).call(this, T, C || null, !0)
            }
            forEachFunction(T) {
                const C = Array.from(j(this, v).keys());
                C.sort( (N, A) => N.localeCompare(A));
                for (let N = 0; N < C.length; N++) {
                    const A = C[N];
                    T(j(this, v).get(A), N)
                }
            }
            getEventName(T) {
                const C = we(this, x, gs).call(this, T, null, !1);
                return (0,
                r.assertArgument)(C, "no matching event", "key", T),
                C.name
            }
            hasEvent(T) {
                return !!we(this, x, gs).call(this, T, null, !1)
            }
            getEvent(T, C) {
                return we(this, x, gs).call(this, T, C || null, !0)
            }
            forEachEvent(T) {
                const C = Array.from(j(this, P).keys());
                C.sort( (N, A) => N.localeCompare(A));
                for (let N = 0; N < C.length; N++) {
                    const A = C[N];
                    T(j(this, P).get(A), N)
                }
            }
            getError(T, C) {
                if ((0,
                r.isHexString)(T)) {
                    const A = T.toLowerCase();
                    if (c[A])
                        return h.ErrorFragment.from(c[A].signature);
                    for (const R of j(this, g).values())
                        if (A === R.selector)
                            return R;
                    return null
                }
                if (T.indexOf("(") === -1) {
                    const A = [];
                    for (const [R,y] of j(this, g))
                        R.split("(")[0] === T && A.push(y);
                    if (A.length === 0)
                        return T === "Error" ? h.ErrorFragment.from("error Error(string)") : T === "Panic" ? h.ErrorFragment.from("error Panic(uint256)") : null;
                    if (A.length > 1) {
                        const R = A.map(y => JSON.stringify(y.format())).join(", ");
                        (0,
                        r.assertArgument)(!1, `ambiguous error description (i.e. ${R})`, "name", T)
                    }
                    return A[0]
                }
                if (T = h.ErrorFragment.from(T).format(),
                T === "Error(string)")
                    return h.ErrorFragment.from("error Error(string)");
                if (T === "Panic(uint256)")
                    return h.ErrorFragment.from("error Panic(uint256)");
                const N = j(this, g).get(T);
                return N || null
            }
            forEachError(T) {
                const C = Array.from(j(this, g).keys());
                C.sort( (N, A) => N.localeCompare(A));
                for (let N = 0; N < C.length; N++) {
                    const A = C[N];
                    T(j(this, g).get(A), N)
                }
            }
            _decodeParams(T, C) {
                return j(this, b).decode(T, C)
            }
            _encodeParams(T, C) {
                return j(this, b).encode(T, C)
            }
            encodeDeploy(T) {
                return this._encodeParams(this.deploy.inputs, T || [])
            }
            decodeErrorResult(T, C) {
                if (typeof T == "string") {
                    const N = this.getError(T);
                    (0,
                    r.assertArgument)(N, "unknown error", "fragment", T),
                    T = N
                }
                return (0,
                r.assertArgument)((0,
                r.dataSlice)(C, 0, 4) === T.selector, `data signature does not match error ${T.name}.`, "data", C),
                this._decodeParams(T.inputs, (0,
                r.dataSlice)(C, 4))
            }
            encodeErrorResult(T, C) {
                if (typeof T == "string") {
                    const N = this.getError(T);
                    (0,
                    r.assertArgument)(N, "unknown error", "fragment", T),
                    T = N
                }
                return (0,
                r.concat)([T.selector, this._encodeParams(T.inputs, C || [])])
            }
            decodeFunctionData(T, C) {
                if (typeof T == "string") {
                    const N = this.getFunction(T);
                    (0,
                    r.assertArgument)(N, "unknown function", "fragment", T),
                    T = N
                }
                return (0,
                r.assertArgument)((0,
                r.dataSlice)(C, 0, 4) === T.selector, `data signature does not match function ${T.name}.`, "data", C),
                this._decodeParams(T.inputs, (0,
                r.dataSlice)(C, 4))
            }
            encodeFunctionData(T, C) {
                if (typeof T == "string") {
                    const N = this.getFunction(T);
                    (0,
                    r.assertArgument)(N, "unknown function", "fragment", T),
                    T = N
                }
                return (0,
                r.concat)([T.selector, this._encodeParams(T.inputs, C || [])])
            }
            decodeFunctionResult(T, C) {
                if (typeof T == "string") {
                    const R = this.getFunction(T);
                    (0,
                    r.assertArgument)(R, "unknown function", "fragment", T),
                    T = R
                }
                let N = "invalid length for result data";
                const A = (0,
                r.getBytesCopy)(C);
                if (A.length % 32 === 0)
                    try {
                        return j(this, b).decode(T.outputs, A)
                    } catch {
                        N = "could not decode result data"
                    }
                (0,
                r.assert)(!1, N, "BAD_DATA", {
                    value: (0,
                    r.hexlify)(A),
                    info: {
                        method: T.name,
                        signature: T.format()
                    }
                })
            }
            makeError(T, C) {
                const N = (0,
                r.getBytes)(T, "data")
                  , A = n.AbiCoder.getBuiltinCallException("call", C, N);
                if (A.message.startsWith("execution reverted (unknown custom error)")) {
                    const k = (0,
                    r.hexlify)(N.slice(0, 4))
                      , _ = this.getError(k);
                    if (_)
                        try {
                            const O = j(this, b).decode(_.inputs, N.slice(4));
                            A.revert = {
                                name: _.name,
                                signature: _.format(),
                                args: O
                            },
                            A.reason = A.revert.signature,
                            A.message = `execution reverted: ${A.reason}`
                        } catch {
                            A.message = "execution reverted (coult not decode custom error)"
                        }
                }
                const y = this.parseTransaction(C);
                return y && (A.invocation = {
                    method: y.name,
                    signature: y.signature,
                    args: y.args
                }),
                A
            }
            encodeFunctionResult(T, C) {
                if (typeof T == "string") {
                    const N = this.getFunction(T);
                    (0,
                    r.assertArgument)(N, "unknown function", "fragment", T),
                    T = N
                }
                return (0,
                r.hexlify)(j(this, b).encode(T.outputs, C || []))
            }
            encodeFilterTopics(T, C) {
                if (typeof T == "string") {
                    const R = this.getEvent(T);
                    (0,
                    r.assertArgument)(R, "unknown event", "eventFragment", T),
                    T = R
                }
                (0,
                r.assert)(C.length <= T.inputs.length, `too many arguments for ${T.format()}`, "UNEXPECTED_ARGUMENT", {
                    count: C.length,
                    expectedCount: T.inputs.length
                });
                const N = [];
                T.anonymous || N.push(T.topicHash);
                const A = (R, y) => R.type === "string" ? (0,
                s.id)(y) : R.type === "bytes" ? (0,
                t.keccak256)((0,
                r.hexlify)(y)) : (R.type === "bool" && typeof y == "boolean" ? y = y ? "0x01" : "0x00" : R.type.match(/^u?int/) ? y = (0,
                r.toBeHex)(y) : R.type.match(/^bytes/) ? y = (0,
                r.zeroPadBytes)(y, 32) : R.type === "address" && j(this, b).encode(["address"], [y]),
                (0,
                r.zeroPadValue)((0,
                r.hexlify)(y), 32));
                for (C.forEach( (R, y) => {
                    const k = T.inputs[y];
                    if (!k.indexed) {
                        (0,
                        r.assertArgument)(R == null, "cannot filter non-indexed parameters; must be null", "contract." + k.name, R);
                        return
                    }
                    R == null ? N.push(null) : k.baseType === "array" || k.baseType === "tuple" ? (0,
                    r.assertArgument)(!1, "filtering with tuples or arrays not supported", "contract." + k.name, R) : Array.isArray(R) ? N.push(R.map(_ => A(k, _))) : N.push(A(k, R))
                }
                ); N.length && N[N.length - 1] === null; )
                    N.pop();
                return N
            }
            encodeEventLog(T, C) {
                if (typeof T == "string") {
                    const y = this.getEvent(T);
                    (0,
                    r.assertArgument)(y, "unknown event", "eventFragment", T),
                    T = y
                }
                const N = []
                  , A = []
                  , R = [];
                return T.anonymous || N.push(T.topicHash),
                (0,
                r.assertArgument)(C.length === T.inputs.length, "event arguments/values mismatch", "values", C),
                T.inputs.forEach( (y, k) => {
                    const _ = C[k];
                    if (y.indexed)
                        if (y.type === "string")
                            N.push((0,
                            s.id)(_));
                        else if (y.type === "bytes")
                            N.push((0,
                            t.keccak256)(_));
                        else {
                            if (y.baseType === "tuple" || y.baseType === "array")
                                throw new Error("not implemented");
                            N.push(j(this, b).encode([y.type], [_]))
                        }
                    else
                        A.push(y),
                        R.push(_)
                }
                ),
                {
                    data: j(this, b).encode(A, R),
                    topics: N
                }
            }
            decodeEventLog(T, C, N) {
                if (typeof T == "string") {
                    const B = this.getEvent(T);
                    (0,
                    r.assertArgument)(B, "unknown event", "eventFragment", T),
                    T = B
                }
                if (N != null && !T.anonymous) {
                    const B = T.topicHash;
                    (0,
                    r.assertArgument)((0,
                    r.isHexString)(N[0], 32) && N[0].toLowerCase() === B, "fragment/topic mismatch", "topics[0]", N[0]),
                    N = N.slice(1)
                }
                const A = []
                  , R = []
                  , y = [];
                T.inputs.forEach( (B, I) => {
                    B.indexed ? B.type === "string" || B.type === "bytes" || B.baseType === "tuple" || B.baseType === "array" ? (A.push(h.ParamType.from({
                        type: "bytes32",
                        name: B.name
                    })),
                    y.push(!0)) : (A.push(B),
                    y.push(!1)) : (R.push(B),
                    y.push(!1))
                }
                );
                const k = N != null ? j(this, b).decode(A, (0,
                r.concat)(N)) : null
                  , _ = j(this, b).decode(R, C, !0)
                  , O = []
                  , L = [];
                let U = 0
                  , $ = 0;
                return T.inputs.forEach( (B, I) => {
                    let F = null;
                    if (B.indexed)
                        if (k == null)
                            F = new p(null);
                        else if (y[I])
                            F = new p(k[$++]);
                        else
                            try {
                                F = k[$++]
                            } catch (z) {
                                F = z
                            }
                    else
                        try {
                            F = _[U++]
                        } catch (z) {
                            F = z
                        }
                    O.push(F),
                    L.push(B.name || null)
                }
                ),
                d.Result.fromItems(O, L)
            }
            parseTransaction(T) {
                const C = (0,
                r.getBytes)(T.data, "tx.data")
                  , N = (0,
                r.getBigInt)(T.value != null ? T.value : 0, "tx.value")
                  , A = this.getFunction((0,
                r.hexlify)(C.slice(0, 4)));
                if (!A)
                    return null;
                const R = j(this, b).decode(A.inputs, C.slice(4));
                return new i(A,A.selector,R,N)
            }
            parseCallResult(T) {
                throw new Error("@TODO")
            }
            parseLog(T) {
                const C = this.getEvent(T.topics[0]);
                return !C || C.anonymous ? null : new f(C,C.topicHash,this.decodeEventLog(C, T.data, T.topics))
            }
            parseError(T) {
                const C = (0,
                r.hexlify)(T)
                  , N = this.getError((0,
                r.dataSlice)(C, 0, 4));
                if (!N)
                    return null;
                const A = j(this, b).decode(N.inputs, (0,
                r.dataSlice)(C, 4));
                return new l(N,N.selector,A)
            }
            static from(T) {
                return T instanceof w ? T : typeof T == "string" ? new w(JSON.parse(T)) : typeof T.formatJson == "function" ? new w(T.formatJson()) : typeof T.format == "function" ? new w(T.format("json")) : new w(T)
            }
        }
        ;
        g = new WeakMap,
        P = new WeakMap,
        v = new WeakMap,
        b = new WeakMap,
        x = new WeakSet,
        bs = function(T, C, N) {
            if ((0,
            r.isHexString)(T)) {
                const R = T.toLowerCase();
                for (const y of j(this, v).values())
                    if (R === y.selector)
                        return y;
                return null
            }
            if (T.indexOf("(") === -1) {
                const R = [];
                for (const [y,k] of j(this, v))
                    y.split("(")[0] === T && R.push(k);
                if (C) {
                    const y = C.length > 0 ? C[C.length - 1] : null;
                    let k = C.length
                      , _ = !0;
                    m.Typed.isTyped(y) && y.type === "overrides" && (_ = !1,
                    k--);
                    for (let O = R.length - 1; O >= 0; O--) {
                        const L = R[O].inputs.length;
                        L !== k && (!_ || L !== k - 1) && R.splice(O, 1)
                    }
                    for (let O = R.length - 1; O >= 0; O--) {
                        const L = R[O].inputs;
                        for (let U = 0; U < C.length; U++)
                            if (m.Typed.isTyped(C[U])) {
                                if (U >= L.length) {
                                    if (C[U].type === "overrides")
                                        continue;
                                    R.splice(O, 1);
                                    break
                                }
                                if (C[U].type !== L[U].baseType) {
                                    R.splice(O, 1);
                                    break
                                }
                            }
                    }
                }
                if (R.length === 1 && C && C.length !== R[0].inputs.length) {
                    const y = C[C.length - 1];
                    (y == null || Array.isArray(y) || typeof y != "object") && R.splice(0, 1)
                }
                if (R.length === 0)
                    return null;
                if (R.length > 1 && N) {
                    const y = R.map(k => JSON.stringify(k.format())).join(", ");
                    (0,
                    r.assertArgument)(!1, `ambiguous function description (i.e. matches ${y})`, "key", T)
                }
                return R[0]
            }
            const A = j(this, v).get(h.FunctionFragment.from(T).format());
            return A || null
        }
        ,
        gs = function(T, C, N) {
            if ((0,
            r.isHexString)(T)) {
                const R = T.toLowerCase();
                for (const y of j(this, P).values())
                    if (R === y.topicHash)
                        return y;
                return null
            }
            if (T.indexOf("(") === -1) {
                const R = [];
                for (const [y,k] of j(this, P))
                    y.split("(")[0] === T && R.push(k);
                if (C) {
                    for (let y = R.length - 1; y >= 0; y--)
                        R[y].inputs.length < C.length && R.splice(y, 1);
                    for (let y = R.length - 1; y >= 0; y--) {
                        const k = R[y].inputs;
                        for (let _ = 0; _ < C.length; _++)
                            if (m.Typed.isTyped(C[_]) && C[_].type !== k[_].baseType) {
                                R.splice(y, 1);
                                break
                            }
                    }
                }
                if (R.length === 0)
                    return null;
                if (R.length > 1 && N) {
                    const y = R.map(k => JSON.stringify(k.format())).join(", ");
                    (0,
                    r.assertArgument)(!1, `ambiguous event description (i.e. matches ${y})`, "key", T)
                }
                return R[0]
            }
            const A = j(this, P).get(h.EventFragment.from(T).format());
            return A || null
        }
        ;
        let u = w;
        e.Interface = u
    }(oi)),
    oi
}
var Wa;
function os() {
    return Wa || (Wa = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.Typed = e.Result = e.TransactionDescription = e.LogDescription = e.ErrorDescription = e.Interface = e.Indexed = e.checkResultErrors = e.StructFragment = e.ParamType = e.NamedFragment = e.FunctionFragment = e.Fragment = e.FallbackFragment = e.EventFragment = e.ErrorFragment = e.ConstructorFragment = e.encodeBytes32String = e.decodeBytes32String = e.AbiCoder = void 0;
        var t = Xu();
        Object.defineProperty(e, "AbiCoder", {
            enumerable: !0,
            get: function() {
                return t.AbiCoder
            }
        });
        var s = hf();
        Object.defineProperty(e, "decodeBytes32String", {
            enumerable: !0,
            get: function() {
                return s.decodeBytes32String
            }
        }),
        Object.defineProperty(e, "encodeBytes32String", {
            enumerable: !0,
            get: function() {
                return s.encodeBytes32String
            }
        });
        var r = Qi();
        Object.defineProperty(e, "ConstructorFragment", {
            enumerable: !0,
            get: function() {
                return r.ConstructorFragment
            }
        }),
        Object.defineProperty(e, "ErrorFragment", {
            enumerable: !0,
            get: function() {
                return r.ErrorFragment
            }
        }),
        Object.defineProperty(e, "EventFragment", {
            enumerable: !0,
            get: function() {
                return r.EventFragment
            }
        }),
        Object.defineProperty(e, "FallbackFragment", {
            enumerable: !0,
            get: function() {
                return r.FallbackFragment
            }
        }),
        Object.defineProperty(e, "Fragment", {
            enumerable: !0,
            get: function() {
                return r.Fragment
            }
        }),
        Object.defineProperty(e, "FunctionFragment", {
            enumerable: !0,
            get: function() {
                return r.FunctionFragment
            }
        }),
        Object.defineProperty(e, "NamedFragment", {
            enumerable: !0,
            get: function() {
                return r.NamedFragment
            }
        }),
        Object.defineProperty(e, "ParamType", {
            enumerable: !0,
            get: function() {
                return r.ParamType
            }
        }),
        Object.defineProperty(e, "StructFragment", {
            enumerable: !0,
            get: function() {
                return r.StructFragment
            }
        });
        var n = pf();
        Object.defineProperty(e, "checkResultErrors", {
            enumerable: !0,
            get: function() {
                return n.checkResultErrors
            }
        }),
        Object.defineProperty(e, "Indexed", {
            enumerable: !0,
            get: function() {
                return n.Indexed
            }
        }),
        Object.defineProperty(e, "Interface", {
            enumerable: !0,
            get: function() {
                return n.Interface
            }
        }),
        Object.defineProperty(e, "ErrorDescription", {
            enumerable: !0,
            get: function() {
                return n.ErrorDescription
            }
        }),
        Object.defineProperty(e, "LogDescription", {
            enumerable: !0,
            get: function() {
                return n.LogDescription
            }
        }),
        Object.defineProperty(e, "TransactionDescription", {
            enumerable: !0,
            get: function() {
                return n.TransactionDescription
            }
        }),
        Object.defineProperty(e, "Result", {
            enumerable: !0,
            get: function() {
                return n.Result
            }
        });
        var d = $t();
        Object.defineProperty(e, "Typed", {
            enumerable: !0,
            get: function() {
                return d.Typed
            }
        })
    }(Vs)),
    Vs
}
var ai = {}, Pt = {}, at = {}, Ya;
function as() {
    var g, P, v;
    if (Ya)
        return at;
    Ya = 1,
    Object.defineProperty(at, "__esModule", {
        value: !0
    }),
    at.TransactionResponse = at.TransactionReceipt = at.Log = at.Block = at.copyRequest = at.FeeData = void 0;
    const e = Be()
      , t = lt()
      , s = BigInt(0);
    function r(x) {
        return x ?? null
    }
    function n(x) {
        return x == null ? null : x.toString()
    }
    class d {
        constructor(a, E, w) {
            ue(this, "gasPrice");
            ue(this, "maxFeePerGas");
            ue(this, "maxPriorityFeePerGas");
            (0,
            e.defineProperties)(this, {
                gasPrice: r(a),
                maxFeePerGas: r(E),
                maxPriorityFeePerGas: r(w)
            })
        }
        toJSON() {
            const {gasPrice: a, maxFeePerGas: E, maxPriorityFeePerGas: w} = this;
            return {
                _type: "FeeData",
                gasPrice: n(a),
                maxFeePerGas: n(E),
                maxPriorityFeePerGas: n(w)
            }
        }
    }
    at.FeeData = d;
    function h(x) {
        const a = {};
        x.to && (a.to = x.to),
        x.from && (a.from = x.from),
        x.data && (a.data = (0,
        e.hexlify)(x.data));
        const E = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
        for (const S of E)
            !(S in x) || x[S] == null || (a[S] = (0,
            e.getBigInt)(x[S], `request.${S}`));
        const w = "type,nonce".split(/,/);
        for (const S of w)
            !(S in x) || x[S] == null || (a[S] = (0,
            e.getNumber)(x[S], `request.${S}`));
        return x.accessList && (a.accessList = (0,
        t.accessListify)(x.accessList)),
        x.authorizationList && (a.authorizationList = x.authorizationList.slice()),
        "blockTag"in x && (a.blockTag = x.blockTag),
        "enableCcipRead"in x && (a.enableCcipRead = !!x.enableCcipRead),
        "customData"in x && (a.customData = x.customData),
        "blobVersionedHashes"in x && x.blobVersionedHashes && (a.blobVersionedHashes = x.blobVersionedHashes.slice()),
        "kzg"in x && (a.kzg = x.kzg),
        "blobs"in x && x.blobs && (a.blobs = x.blobs.map(S => (0,
        e.isBytesLike)(S) ? (0,
        e.hexlify)(S) : Object.assign({}, S))),
        a
    }
    at.copyRequest = h;
    class m {
        constructor(a, E) {
            ue(this, "provider");
            ue(this, "number");
            ue(this, "hash");
            ue(this, "timestamp");
            ue(this, "parentHash");
            ue(this, "parentBeaconBlockRoot");
            ue(this, "nonce");
            ue(this, "difficulty");
            ue(this, "gasLimit");
            ue(this, "gasUsed");
            ue(this, "stateRoot");
            ue(this, "receiptsRoot");
            ue(this, "blobGasUsed");
            ue(this, "excessBlobGas");
            ue(this, "miner");
            ue(this, "prevRandao");
            ue(this, "extraData");
            ue(this, "baseFeePerGas");
            he(this, g);
            Q(this, g, a.transactions.map(w => typeof w != "string" ? new l(w,E) : w)),
            (0,
            e.defineProperties)(this, {
                provider: E,
                hash: r(a.hash),
                number: a.number,
                timestamp: a.timestamp,
                parentHash: a.parentHash,
                parentBeaconBlockRoot: a.parentBeaconBlockRoot,
                nonce: a.nonce,
                difficulty: a.difficulty,
                gasLimit: a.gasLimit,
                gasUsed: a.gasUsed,
                blobGasUsed: a.blobGasUsed,
                excessBlobGas: a.excessBlobGas,
                miner: a.miner,
                prevRandao: r(a.prevRandao),
                extraData: a.extraData,
                baseFeePerGas: r(a.baseFeePerGas),
                stateRoot: a.stateRoot,
                receiptsRoot: a.receiptsRoot
            })
        }
        get transactions() {
            return j(this, g).map(a => typeof a == "string" ? a : a.hash)
        }
        get prefetchedTransactions() {
            const a = j(this, g).slice();
            return a.length === 0 ? [] : ((0,
            e.assert)(typeof a[0] == "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
                operation: "transactionResponses()"
            }),
            a)
        }
        toJSON() {
            const {baseFeePerGas: a, difficulty: E, extraData: w, gasLimit: S, gasUsed: T, hash: C, miner: N, prevRandao: A, nonce: R, number: y, parentHash: k, parentBeaconBlockRoot: _, stateRoot: O, receiptsRoot: L, timestamp: U, transactions: $} = this;
            return {
                _type: "Block",
                baseFeePerGas: n(a),
                difficulty: n(E),
                extraData: w,
                gasLimit: n(S),
                gasUsed: n(T),
                blobGasUsed: n(this.blobGasUsed),
                excessBlobGas: n(this.excessBlobGas),
                hash: C,
                miner: N,
                prevRandao: A,
                nonce: R,
                number: y,
                parentHash: k,
                timestamp: U,
                parentBeaconBlockRoot: _,
                stateRoot: O,
                receiptsRoot: L,
                transactions: $
            }
        }
        [Symbol.iterator]() {
            let a = 0;
            const E = this.transactions;
            return {
                next: () => a < this.length ? {
                    value: E[a++],
                    done: !1
                } : {
                    value: void 0,
                    done: !0
                }
            }
        }
        get length() {
            return j(this, g).length
        }
        get date() {
            return this.timestamp == null ? null : new Date(this.timestamp * 1e3)
        }
        async getTransaction(a) {
            let E;
            if (typeof a == "number")
                E = j(this, g)[a];
            else {
                const w = a.toLowerCase();
                for (const S of j(this, g))
                    if (typeof S == "string") {
                        if (S !== w)
                            continue;
                        E = S;
                        break
                    } else {
                        if (S.hash !== w)
                            continue;
                        E = S;
                        break
                    }
            }
            if (E == null)
                throw new Error("no such tx");
            return typeof E == "string" ? await this.provider.getTransaction(E) : E
        }
        getPrefetchedTransaction(a) {
            const E = this.prefetchedTransactions;
            if (typeof a == "number")
                return E[a];
            a = a.toLowerCase();
            for (const w of E)
                if (w.hash === a)
                    return w;
            (0,
            e.assertArgument)(!1, "no matching transaction", "indexOrHash", a)
        }
        isMined() {
            return !!this.hash
        }
        isLondon() {
            return !!this.baseFeePerGas
        }
        orphanedEvent() {
            if (!this.isMined())
                throw new Error("");
            return p(this)
        }
    }
    g = new WeakMap,
    at.Block = m;
    class f {
        constructor(a, E) {
            ue(this, "provider");
            ue(this, "transactionHash");
            ue(this, "blockHash");
            ue(this, "blockNumber");
            ue(this, "removed");
            ue(this, "address");
            ue(this, "data");
            ue(this, "topics");
            ue(this, "index");
            ue(this, "transactionIndex");
            this.provider = E;
            const w = Object.freeze(a.topics.slice());
            (0,
            e.defineProperties)(this, {
                transactionHash: a.transactionHash,
                blockHash: a.blockHash,
                blockNumber: a.blockNumber,
                removed: a.removed,
                address: a.address,
                data: a.data,
                topics: w,
                index: a.index,
                transactionIndex: a.transactionIndex
            })
        }
        toJSON() {
            const {address: a, blockHash: E, blockNumber: w, data: S, index: T, removed: C, topics: N, transactionHash: A, transactionIndex: R} = this;
            return {
                _type: "log",
                address: a,
                blockHash: E,
                blockNumber: w,
                data: S,
                index: T,
                removed: C,
                topics: N,
                transactionHash: A,
                transactionIndex: R
            }
        }
        async getBlock() {
            const a = await this.provider.getBlock(this.blockHash);
            return (0,
            e.assert)(!!a, "failed to find transaction", "UNKNOWN_ERROR", {}),
            a
        }
        async getTransaction() {
            const a = await this.provider.getTransaction(this.transactionHash);
            return (0,
            e.assert)(!!a, "failed to find transaction", "UNKNOWN_ERROR", {}),
            a
        }
        async getTransactionReceipt() {
            const a = await this.provider.getTransactionReceipt(this.transactionHash);
            return (0,
            e.assert)(!!a, "failed to find transaction receipt", "UNKNOWN_ERROR", {}),
            a
        }
        removedEvent() {
            return u(this)
        }
    }
    at.Log = f;
    class i {
        constructor(a, E) {
            ue(this, "provider");
            ue(this, "to");
            ue(this, "from");
            ue(this, "contractAddress");
            ue(this, "hash");
            ue(this, "index");
            ue(this, "blockHash");
            ue(this, "blockNumber");
            ue(this, "logsBloom");
            ue(this, "gasUsed");
            ue(this, "blobGasUsed");
            ue(this, "cumulativeGasUsed");
            ue(this, "gasPrice");
            ue(this, "blobGasPrice");
            ue(this, "type");
            ue(this, "status");
            ue(this, "root");
            he(this, P);
            Q(this, P, Object.freeze(a.logs.map(S => new f(S,E))));
            let w = s;
            a.effectiveGasPrice != null ? w = a.effectiveGasPrice : a.gasPrice != null && (w = a.gasPrice),
            (0,
            e.defineProperties)(this, {
                provider: E,
                to: a.to,
                from: a.from,
                contractAddress: a.contractAddress,
                hash: a.hash,
                index: a.index,
                blockHash: a.blockHash,
                blockNumber: a.blockNumber,
                logsBloom: a.logsBloom,
                gasUsed: a.gasUsed,
                cumulativeGasUsed: a.cumulativeGasUsed,
                blobGasUsed: a.blobGasUsed,
                gasPrice: w,
                blobGasPrice: a.blobGasPrice,
                type: a.type,
                status: a.status,
                root: a.root
            })
        }
        get logs() {
            return j(this, P)
        }
        toJSON() {
            const {to: a, from: E, contractAddress: w, hash: S, index: T, blockHash: C, blockNumber: N, logsBloom: A, logs: R, status: y, root: k} = this;
            return {
                _type: "TransactionReceipt",
                blockHash: C,
                blockNumber: N,
                contractAddress: w,
                cumulativeGasUsed: n(this.cumulativeGasUsed),
                from: E,
                gasPrice: n(this.gasPrice),
                blobGasUsed: n(this.blobGasUsed),
                blobGasPrice: n(this.blobGasPrice),
                gasUsed: n(this.gasUsed),
                hash: S,
                index: T,
                logs: R,
                logsBloom: A,
                root: k,
                status: y,
                to: a
            }
        }
        get length() {
            return this.logs.length
        }
        [Symbol.iterator]() {
            let a = 0;
            return {
                next: () => a < this.length ? {
                    value: this.logs[a++],
                    done: !1
                } : {
                    value: void 0,
                    done: !0
                }
            }
        }
        get fee() {
            return this.gasUsed * this.gasPrice
        }
        async getBlock() {
            const a = await this.provider.getBlock(this.blockHash);
            if (a == null)
                throw new Error("TODO");
            return a
        }
        async getTransaction() {
            const a = await this.provider.getTransaction(this.hash);
            if (a == null)
                throw new Error("TODO");
            return a
        }
        async getResult() {
            return await this.provider.getTransactionResult(this.hash)
        }
        async confirmations() {
            return await this.provider.getBlockNumber() - this.blockNumber + 1
        }
        removedEvent() {
            return c(this)
        }
        reorderedEvent(a) {
            return (0,
            e.assert)(!a || a.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", {
                operation: "reorderedEvent(other)"
            }),
            o(this, a)
        }
    }
    P = new WeakMap,
    at.TransactionReceipt = i;
    const b = class b {
        constructor(a, E) {
            ue(this, "provider");
            ue(this, "blockNumber");
            ue(this, "blockHash");
            ue(this, "index");
            ue(this, "hash");
            ue(this, "type");
            ue(this, "to");
            ue(this, "from");
            ue(this, "nonce");
            ue(this, "gasLimit");
            ue(this, "gasPrice");
            ue(this, "maxPriorityFeePerGas");
            ue(this, "maxFeePerGas");
            ue(this, "maxFeePerBlobGas");
            ue(this, "data");
            ue(this, "value");
            ue(this, "chainId");
            ue(this, "signature");
            ue(this, "accessList");
            ue(this, "blobVersionedHashes");
            ue(this, "authorizationList");
            he(this, v);
            this.provider = E,
            this.blockNumber = a.blockNumber != null ? a.blockNumber : null,
            this.blockHash = a.blockHash != null ? a.blockHash : null,
            this.hash = a.hash,
            this.index = a.index,
            this.type = a.type,
            this.from = a.from,
            this.to = a.to || null,
            this.gasLimit = a.gasLimit,
            this.nonce = a.nonce,
            this.data = a.data,
            this.value = a.value,
            this.gasPrice = a.gasPrice,
            this.maxPriorityFeePerGas = a.maxPriorityFeePerGas != null ? a.maxPriorityFeePerGas : null,
            this.maxFeePerGas = a.maxFeePerGas != null ? a.maxFeePerGas : null,
            this.maxFeePerBlobGas = a.maxFeePerBlobGas != null ? a.maxFeePerBlobGas : null,
            this.chainId = a.chainId,
            this.signature = a.signature,
            this.accessList = a.accessList != null ? a.accessList : null,
            this.blobVersionedHashes = a.blobVersionedHashes != null ? a.blobVersionedHashes : null,
            this.authorizationList = a.authorizationList != null ? a.authorizationList : null,
            Q(this, v, -1)
        }
        toJSON() {
            const {blockNumber: a, blockHash: E, index: w, hash: S, type: T, to: C, from: N, nonce: A, data: R, signature: y, accessList: k, blobVersionedHashes: _} = this;
            return {
                _type: "TransactionResponse",
                accessList: k,
                blockNumber: a,
                blockHash: E,
                blobVersionedHashes: _,
                chainId: n(this.chainId),
                data: R,
                from: N,
                gasLimit: n(this.gasLimit),
                gasPrice: n(this.gasPrice),
                hash: S,
                maxFeePerGas: n(this.maxFeePerGas),
                maxPriorityFeePerGas: n(this.maxPriorityFeePerGas),
                maxFeePerBlobGas: n(this.maxFeePerBlobGas),
                nonce: A,
                signature: y,
                to: C,
                index: w,
                type: T,
                value: n(this.value)
            }
        }
        async getBlock() {
            let a = this.blockNumber;
            if (a == null) {
                const w = await this.getTransaction();
                w && (a = w.blockNumber)
            }
            if (a == null)
                return null;
            const E = this.provider.getBlock(a);
            if (E == null)
                throw new Error("TODO");
            return E
        }
        async getTransaction() {
            return this.provider.getTransaction(this.hash)
        }
        async confirmations() {
            if (this.blockNumber == null) {
                const {tx: E, blockNumber: w} = await (0,
                e.resolveProperties)({
                    tx: this.getTransaction(),
                    blockNumber: this.provider.getBlockNumber()
                });
                return E == null || E.blockNumber == null ? 0 : w - E.blockNumber + 1
            }
            return await this.provider.getBlockNumber() - this.blockNumber + 1
        }
        async wait(a, E) {
            const w = a ?? 1
              , S = E ?? 0;
            let T = j(this, v)
              , C = -1
              , N = T === -1;
            const A = async () => {
                if (N)
                    return null;
                const {blockNumber: _, nonce: O} = await (0,
                e.resolveProperties)({
                    blockNumber: this.provider.getBlockNumber(),
                    nonce: this.provider.getTransactionCount(this.from)
                });
                if (O < this.nonce) {
                    T = _;
                    return
                }
                if (N)
                    return null;
                const L = await this.getTransaction();
                if (!(L && L.blockNumber != null))
                    for (C === -1 && (C = T - 3,
                    C < j(this, v) && (C = j(this, v))); C <= _; ) {
                        if (N)
                            return null;
                        const U = await this.provider.getBlock(C, !0);
                        if (U == null)
                            return;
                        for (const $ of U)
                            if ($ === this.hash)
                                return;
                        for (let $ = 0; $ < U.length; $++) {
                            const B = await U.getTransaction($);
                            if (B.from === this.from && B.nonce === this.nonce) {
                                if (N)
                                    return null;
                                const I = await this.provider.getTransactionReceipt(B.hash);
                                if (I == null || _ - I.blockNumber + 1 < w)
                                    return;
                                let F = "replaced";
                                B.data === this.data && B.to === this.to && B.value === this.value ? F = "repriced" : B.data === "0x" && B.from === B.to && B.value === s && (F = "cancelled"),
                                (0,
                                e.assert)(!1, "transaction was replaced", "TRANSACTION_REPLACED", {
                                    cancelled: F === "replaced" || F === "cancelled",
                                    reason: F,
                                    replacement: B.replaceableTransaction(T),
                                    hash: B.hash,
                                    receipt: I
                                })
                            }
                        }
                        C++
                    }
            }
              , R = _ => {
                if (_ == null || _.status !== 0)
                    return _;
                (0,
                e.assert)(!1, "transaction execution reverted", "CALL_EXCEPTION", {
                    action: "sendTransaction",
                    data: null,
                    reason: null,
                    invocation: null,
                    revert: null,
                    transaction: {
                        to: _.to,
                        from: _.from,
                        data: ""
                    },
                    receipt: _
                })
            }
              , y = await this.provider.getTransactionReceipt(this.hash);
            if (w === 0)
                return R(y);
            if (y) {
                if (w === 1 || await y.confirmations() >= w)
                    return R(y)
            } else if (await A(),
            w === 0)
                return null;
            return await new Promise( (_, O) => {
                const L = []
                  , U = () => {
                    L.forEach(B => B())
                }
                ;
                if (L.push( () => {
                    N = !0
                }
                ),
                S > 0) {
                    const B = setTimeout( () => {
                        U(),
                        O((0,
                        e.makeError)("wait for transaction timeout", "TIMEOUT"))
                    }
                    , S);
                    L.push( () => {
                        clearTimeout(B)
                    }
                    )
                }
                const $ = async B => {
                    if (await B.confirmations() >= w) {
                        U();
                        try {
                            _(R(B))
                        } catch (I) {
                            O(I)
                        }
                    }
                }
                ;
                if (L.push( () => {
                    this.provider.off(this.hash, $)
                }
                ),
                this.provider.on(this.hash, $),
                T >= 0) {
                    const B = async () => {
                        try {
                            await A()
                        } catch (I) {
                            if ((0,
                            e.isError)(I, "TRANSACTION_REPLACED")) {
                                U(),
                                O(I);
                                return
                            }
                        }
                        N || this.provider.once("block", B)
                    }
                    ;
                    L.push( () => {
                        this.provider.off("block", B)
                    }
                    ),
                    this.provider.once("block", B)
                }
            }
            )
        }
        isMined() {
            return this.blockHash != null
        }
        isLegacy() {
            return this.type === 0
        }
        isBerlin() {
            return this.type === 1
        }
        isLondon() {
            return this.type === 2
        }
        isCancun() {
            return this.type === 3
        }
        removedEvent() {
            return (0,
            e.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
                operation: "removeEvent()"
            }),
            c(this)
        }
        reorderedEvent(a) {
            return (0,
            e.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
                operation: "removeEvent()"
            }),
            (0,
            e.assert)(!a || a.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
                operation: "removeEvent()"
            }),
            o(this, a)
        }
        replaceableTransaction(a) {
            (0,
            e.assertArgument)(Number.isInteger(a) && a >= 0, "invalid startBlock", "startBlock", a);
            const E = new b(this,this.provider);
            return Q(E, v, a),
            E
        }
    }
    ;
    v = new WeakMap;
    let l = b;
    at.TransactionResponse = l;
    function p(x) {
        return {
            orphan: "drop-block",
            hash: x.hash,
            number: x.number
        }
    }
    function o(x, a) {
        return {
            orphan: "reorder-transaction",
            tx: x,
            other: a
        }
    }
    function c(x) {
        return {
            orphan: "drop-transaction",
            tx: x
        }
    }
    function u(x) {
        return {
            orphan: "drop-log",
            log: {
                transactionHash: x.transactionHash,
                blockHash: x.blockHash,
                blockNumber: x.blockNumber,
                address: x.address,
                data: x.data,
                topics: Object.freeze(x.topics.slice()),
                index: x.index
            }
        }
    }
    return at
}
var ct = {}, Za;
function el() {
    var f, i;
    if (Za)
        return ct;
    Za = 1,
    Object.defineProperty(ct, "__esModule", {
        value: !0
    }),
    ct.ContractEventPayload = ct.ContractUnknownEventPayload = ct.ContractTransactionResponse = ct.ContractTransactionReceipt = ct.UndecodedEventLog = ct.EventLog = void 0;
    const e = as()
      , t = Be();
    class s extends e.Log {
        constructor(o, c, u) {
            super(o, o.provider);
            ue(this, "interface");
            ue(this, "fragment");
            ue(this, "args");
            const g = c.decodeEventLog(u, o.data, o.topics);
            (0,
            t.defineProperties)(this, {
                args: g,
                fragment: u,
                interface: c
            })
        }
        get eventName() {
            return this.fragment.name
        }
        get eventSignature() {
            return this.fragment.format()
        }
    }
    ct.EventLog = s;
    class r extends e.Log {
        constructor(o, c) {
            super(o, o.provider);
            ue(this, "error");
            (0,
            t.defineProperties)(this, {
                error: c
            })
        }
    }
    ct.UndecodedEventLog = r;
    class n extends e.TransactionReceipt {
        constructor(o, c, u) {
            super(u, c);
            he(this, f);
            Q(this, f, o)
        }
        get logs() {
            return super.logs.map(o => {
                const c = o.topics.length ? j(this, f).getEvent(o.topics[0]) : null;
                if (c)
                    try {
                        return new s(o,j(this, f),c)
                    } catch (u) {
                        return new r(o,u)
                    }
                return o
            }
            )
        }
    }
    f = new WeakMap,
    ct.ContractTransactionReceipt = n;
    class d extends e.TransactionResponse {
        constructor(o, c, u) {
            super(u, c);
            he(this, i);
            Q(this, i, o)
        }
        async wait(o, c) {
            const u = await super.wait(o, c);
            return u == null ? null : new n(j(this, i),this.provider,u)
        }
    }
    i = new WeakMap,
    ct.ContractTransactionResponse = d;
    class h extends t.EventPayload {
        constructor(o, c, u, g) {
            super(o, c, u);
            ue(this, "log");
            (0,
            t.defineProperties)(this, {
                log: g
            })
        }
        async getBlock() {
            return await this.log.getBlock()
        }
        async getTransaction() {
            return await this.log.getTransaction()
        }
        async getTransactionReceipt() {
            return await this.log.getTransactionReceipt()
        }
    }
    ct.ContractUnknownEventPayload = h;
    class m extends h {
        constructor(p, o, c, u, g) {
            super(p, o, c, new s(g,p.interface,u));
            const P = p.interface.decodeEventLog(u, this.log.data, this.log.topics);
            (0,
            t.defineProperties)(this, {
                args: P,
                fragment: u
            })
        }
        get eventName() {
            return this.fragment.name
        }
        get eventSignature() {
            return this.fragment.format()
        }
    }
    return ct.ContractEventPayload = m,
    ct
}
var Xa;
function tl() {
    var U, $;
    if (Xa)
        return Pt;
    Xa = 1,
    Object.defineProperty(Pt, "__esModule", {
        value: !0
    }),
    Pt.Contract = Pt.BaseContract = Pt.resolveArgs = Pt.copyOverrides = void 0;
    const e = os()
      , t = tt()
      , s = as()
      , r = Be()
      , n = el()
      , d = BigInt(0);
    function h(I) {
        return I && typeof I.call == "function"
    }
    function m(I) {
        return I && typeof I.estimateGas == "function"
    }
    function f(I) {
        return I && typeof I.resolveName == "function"
    }
    function i(I) {
        return I && typeof I.sendTransaction == "function"
    }
    function l(I) {
        if (I != null) {
            if (f(I))
                return I;
            if (I.provider)
                return I.provider
        }
    }
    class p {
        constructor(F, z, Y) {
            he(this, U);
            ue(this, "fragment");
            if ((0,
            r.defineProperties)(this, {
                fragment: z
            }),
            z.inputs.length < Y.length)
                throw new Error("too many arguments");
            const ie = o(F.runner, "resolveName")
              , ne = f(ie) ? ie : null;
            Q(this, U, async function() {
                const xe = await Promise.all(z.inputs.map( (W, ee) => Y[ee] == null ? null : W.walkAsync(Y[ee], (fe, be) => fe === "address" ? Array.isArray(be) ? Promise.all(be.map(le => (0,
                t.resolveAddress)(le, ne))) : (0,
                t.resolveAddress)(be, ne) : be)));
                return F.interface.encodeFilterTopics(z, xe)
            }())
        }
        getTopicFilter() {
            return j(this, U)
        }
    }
    U = new WeakMap;
    function o(I, F) {
        return I == null ? null : typeof I[F] == "function" ? I : I.provider && typeof I.provider[F] == "function" ? I.provider : null
    }
    function c(I) {
        return I == null ? null : I.provider || null
    }
    async function u(I, F) {
        const z = e.Typed.dereference(I, "overrides");
        (0,
        r.assertArgument)(typeof z == "object", "invalid overrides parameter", "overrides", I);
        const Y = (0,
        s.copyRequest)(z);
        return (0,
        r.assertArgument)(Y.to == null || (F || []).indexOf("to") >= 0, "cannot override to", "overrides.to", Y.to),
        (0,
        r.assertArgument)(Y.data == null || (F || []).indexOf("data") >= 0, "cannot override data", "overrides.data", Y.data),
        Y.from && (Y.from = Y.from),
        Y
    }
    Pt.copyOverrides = u;
    async function g(I, F, z) {
        const Y = o(I, "resolveName")
          , ie = f(Y) ? Y : null;
        return await Promise.all(F.map( (ne, xe) => ne.walkAsync(z[xe], (W, ee) => (ee = e.Typed.dereference(ee, W),
        W === "address" ? (0,
        t.resolveAddress)(ee, ie) : ee))))
    }
    Pt.resolveArgs = g;
    function P(I) {
        const F = async function(xe) {
            const W = await u(xe, ["data"]);
            W.to = await I.getAddress(),
            W.from && (W.from = await (0,
            t.resolveAddress)(W.from, l(I.runner)));
            const ee = I.interface
              , te = (0,
            r.getBigInt)(W.value || d, "overrides.value") === d
              , fe = (W.data || "0x") === "0x";
            ee.fallback && !ee.fallback.payable && ee.receive && !fe && !te && (0,
            r.assertArgument)(!1, "cannot send data to receive or send value to non-payable fallback", "overrides", xe),
            (0,
            r.assertArgument)(ee.fallback || fe, "cannot send data to receive-only contract", "overrides.data", W.data);
            const be = ee.receive || ee.fallback && ee.fallback.payable;
            return (0,
            r.assertArgument)(be || te, "cannot send value to non-payable fallback", "overrides.value", W.value),
            (0,
            r.assertArgument)(ee.fallback || fe, "cannot send data to receive-only contract", "overrides.data", W.data),
            W
        }
          , z = async function(xe) {
            const W = o(I.runner, "call");
            (0,
            r.assert)(h(W), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                operation: "call"
            });
            const ee = await F(xe);
            try {
                return await W.call(ee)
            } catch (te) {
                throw (0,
                r.isCallException)(te) && te.data ? I.interface.makeError(te.data, ee) : te
            }
        }
          , Y = async function(xe) {
            const W = I.runner;
            (0,
            r.assert)(i(W), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
            });
            const ee = await W.sendTransaction(await F(xe))
              , te = c(I.runner);
            return new n.ContractTransactionResponse(I.interface,te,ee)
        }
          , ie = async function(xe) {
            const W = o(I.runner, "estimateGas");
            return (0,
            r.assert)(m(W), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                operation: "estimateGas"
            }),
            await W.estimateGas(await F(xe))
        }
          , ne = async xe => await Y(xe);
        return (0,
        r.defineProperties)(ne, {
            _contract: I,
            estimateGas: ie,
            populateTransaction: F,
            send: Y,
            staticCall: z
        }),
        ne
    }
    function v(I, F) {
        const z = function(...te) {
            const fe = I.interface.getFunction(F, te);
            return (0,
            r.assert)(fe, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: F,
                    args: te
                }
            }),
            fe
        }
          , Y = async function(...te) {
            const fe = z(...te);
            let be = {};
            if (fe.inputs.length + 1 === te.length && (be = await u(te.pop()),
            be.from && (be.from = await (0,
            t.resolveAddress)(be.from, l(I.runner)))),
            fe.inputs.length !== te.length)
                throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
            const le = await g(I.runner, fe.inputs, te);
            return Object.assign({}, be, await (0,
            r.resolveProperties)({
                to: I.getAddress(),
                data: I.interface.encodeFunctionData(fe, le)
            }))
        }
          , ie = async function(...te) {
            const fe = await W(...te);
            return fe.length === 1 ? fe[0] : fe
        }
          , ne = async function(...te) {
            const fe = I.runner;
            (0,
            r.assert)(i(fe), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
            });
            const be = await fe.sendTransaction(await Y(...te))
              , le = c(I.runner);
            return new n.ContractTransactionResponse(I.interface,le,be)
        }
          , xe = async function(...te) {
            const fe = o(I.runner, "estimateGas");
            return (0,
            r.assert)(m(fe), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
                operation: "estimateGas"
            }),
            await fe.estimateGas(await Y(...te))
        }
          , W = async function(...te) {
            const fe = o(I.runner, "call");
            (0,
            r.assert)(h(fe), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
                operation: "call"
            });
            const be = await Y(...te);
            let le = "0x";
            try {
                le = await fe.call(be)
            } catch (M) {
                throw (0,
                r.isCallException)(M) && M.data ? I.interface.makeError(M.data, be) : M
            }
            const re = z(...te);
            return I.interface.decodeFunctionResult(re, le)
        }
          , ee = async (...te) => z(...te).constant ? await ie(...te) : await ne(...te);
        return (0,
        r.defineProperties)(ee, {
            name: I.interface.getFunctionName(F),
            _contract: I,
            _key: F,
            getFragment: z,
            estimateGas: xe,
            populateTransaction: Y,
            send: ne,
            staticCall: ie,
            staticCallResult: W
        }),
        Object.defineProperty(ee, "fragment", {
            configurable: !1,
            enumerable: !0,
            get: () => {
                const te = I.interface.getFunction(F);
                return (0,
                r.assert)(te, "no matching fragment", "UNSUPPORTED_OPERATION", {
                    operation: "fragment",
                    info: {
                        key: F
                    }
                }),
                te
            }
        }),
        ee
    }
    function b(I, F) {
        const z = function(...ie) {
            const ne = I.interface.getEvent(F, ie);
            return (0,
            r.assert)(ne, "no matching fragment", "UNSUPPORTED_OPERATION", {
                operation: "fragment",
                info: {
                    key: F,
                    args: ie
                }
            }),
            ne
        }
          , Y = function(...ie) {
            return new p(I,z(...ie),ie)
        };
        return (0,
        r.defineProperties)(Y, {
            name: I.interface.getEventName(F),
            _contract: I,
            _key: F,
            getFragment: z
        }),
        Object.defineProperty(Y, "fragment", {
            configurable: !1,
            enumerable: !0,
            get: () => {
                const ie = I.interface.getEvent(F);
                return (0,
                r.assert)(ie, "no matching fragment", "UNSUPPORTED_OPERATION", {
                    operation: "fragment",
                    info: {
                        key: F
                    }
                }),
                ie
            }
        }),
        Y
    }
    const x = Symbol.for("_ethersInternal_contract")
      , a = new WeakMap;
    function E(I, F) {
        a.set(I[x], F)
    }
    function w(I) {
        return a.get(I[x])
    }
    function S(I) {
        return I && typeof I == "object" && "getTopicFilter"in I && typeof I.getTopicFilter == "function" && I.fragment
    }
    async function T(I, F) {
        let z, Y = null;
        if (Array.isArray(F)) {
            const ne = function(xe) {
                if ((0,
                r.isHexString)(xe, 32))
                    return xe;
                const W = I.interface.getEvent(xe);
                return (0,
                r.assertArgument)(W, "unknown fragment", "name", xe),
                W.topicHash
            };
            z = F.map(xe => xe == null ? null : Array.isArray(xe) ? xe.map(ne) : ne(xe))
        } else
            F === "*" ? z = [null] : typeof F == "string" ? (0,
            r.isHexString)(F, 32) ? z = [F] : (Y = I.interface.getEvent(F),
            (0,
            r.assertArgument)(Y, "unknown fragment", "event", F),
            z = [Y.topicHash]) : S(F) ? z = await F.getTopicFilter() : "fragment"in F ? (Y = F.fragment,
            z = [Y.topicHash]) : (0,
            r.assertArgument)(!1, "unknown event name", "event", F);
        z = z.map(ne => {
            if (ne == null)
                return null;
            if (Array.isArray(ne)) {
                const xe = Array.from(new Set(ne.map(W => W.toLowerCase())).values());
                return xe.length === 1 ? xe[0] : (xe.sort(),
                xe)
            }
            return ne.toLowerCase()
        }
        );
        const ie = z.map(ne => ne == null ? "null" : Array.isArray(ne) ? ne.join("|") : ne).join("&");
        return {
            fragment: Y,
            tag: ie,
            topics: z
        }
    }
    async function C(I, F) {
        const {subs: z} = w(I);
        return z.get((await T(I, F)).tag) || null
    }
    async function N(I, F, z) {
        const Y = c(I.runner);
        (0,
        r.assert)(Y, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", {
            operation: F
        });
        const {fragment: ie, tag: ne, topics: xe} = await T(I, z)
          , {addr: W, subs: ee} = w(I);
        let te = ee.get(ne);
        if (!te) {
            const be = {
                address: W || I,
                topics: xe
            }
              , le = V => {
                let oe = ie;
                if (oe == null)
                    try {
                        oe = I.interface.getEvent(V.topics[0])
                    } catch {}
                if (oe) {
                    const me = oe
                      , Pe = ie ? I.interface.decodeEventLog(ie, V.data, V.topics) : [];
                    y(I, z, Pe, se => new n.ContractEventPayload(I,se,z,me,V))
                } else
                    y(I, z, [], me => new n.ContractUnknownEventPayload(I,me,z,V))
            }
            ;
            let re = [];
            te = {
                tag: ne,
                listeners: [],
                start: () => {
                    re.length || re.push(Y.on(be, le))
                }
                ,
                stop: async () => {
                    if (re.length == 0)
                        return;
                    let V = re;
                    re = [],
                    await Promise.all(V),
                    Y.off(be, le)
                }
            },
            ee.set(ne, te)
        }
        return te
    }
    let A = Promise.resolve();
    async function R(I, F, z, Y) {
        await A;
        const ie = await C(I, F);
        if (!ie)
            return !1;
        const ne = ie.listeners.length;
        return ie.listeners = ie.listeners.filter( ({listener: xe, once: W}) => {
            const ee = Array.from(z);
            Y && ee.push(Y(W ? null : xe));
            try {
                xe.call(I, ...ee)
            } catch {}
            return !W
        }
        ),
        ie.listeners.length === 0 && (ie.stop(),
        w(I).subs.delete(ie.tag)),
        ne > 0
    }
    async function y(I, F, z, Y) {
        try {
            await A
        } catch {}
        const ie = R(I, F, z, Y);
        return A = ie,
        await ie
    }
    const k = ["then"];
    $ = x;
    const B = class B {
        constructor(F, z, Y, ie) {
            ue(this, "target");
            ue(this, "interface");
            ue(this, "runner");
            ue(this, "filters");
            ue(this, $);
            ue(this, "fallback");
            (0,
            r.assertArgument)(typeof F == "string" || (0,
            t.isAddressable)(F), "invalid value for Contract target", "target", F),
            Y == null && (Y = null);
            const ne = e.Interface.from(z);
            (0,
            r.defineProperties)(this, {
                target: F,
                runner: Y,
                interface: ne
            }),
            Object.defineProperty(this, x, {
                value: {}
            });
            let xe, W = null, ee = null;
            if (ie) {
                const be = c(Y);
                ee = new n.ContractTransactionResponse(this.interface,be,ie)
            }
            let te = new Map;
            if (typeof F == "string")
                if ((0,
                r.isHexString)(F))
                    W = F,
                    xe = Promise.resolve(F);
                else {
                    const be = o(Y, "resolveName");
                    if (!f(be))
                        throw (0,
                        r.makeError)("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                            operation: "resolveName"
                        });
                    xe = be.resolveName(F).then(le => {
                        if (le == null)
                            throw (0,
                            r.makeError)("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                                value: F
                            });
                        return w(this).addr = le,
                        le
                    }
                    )
                }
            else
                xe = F.getAddress().then(be => {
                    if (be == null)
                        throw new Error("TODO");
                    return w(this).addr = be,
                    be
                }
                );
            E(this, {
                addrPromise: xe,
                addr: W,
                deployTx: ee,
                subs: te
            });
            const fe = new Proxy({},{
                get: (be, le, re) => {
                    if (typeof le == "symbol" || k.indexOf(le) >= 0)
                        return Reflect.get(be, le, re);
                    try {
                        return this.getEvent(le)
                    } catch (M) {
                        if (!(0,
                        r.isError)(M, "INVALID_ARGUMENT") || M.argument !== "key")
                            throw M
                    }
                }
                ,
                has: (be, le) => k.indexOf(le) >= 0 ? Reflect.has(be, le) : Reflect.has(be, le) || this.interface.hasEvent(String(le))
            });
            return (0,
            r.defineProperties)(this, {
                filters: fe
            }),
            (0,
            r.defineProperties)(this, {
                fallback: ne.receive || ne.fallback ? P(this) : null
            }),
            new Proxy(this,{
                get: (be, le, re) => {
                    if (typeof le == "symbol" || le in be || k.indexOf(le) >= 0)
                        return Reflect.get(be, le, re);
                    try {
                        return be.getFunction(le)
                    } catch (M) {
                        if (!(0,
                        r.isError)(M, "INVALID_ARGUMENT") || M.argument !== "key")
                            throw M
                    }
                }
                ,
                has: (be, le) => typeof le == "symbol" || le in be || k.indexOf(le) >= 0 ? Reflect.has(be, le) : be.interface.hasFunction(le)
            })
        }
        connect(F) {
            return new B(this.target,this.interface,F)
        }
        attach(F) {
            return new B(F,this.interface,this.runner)
        }
        async getAddress() {
            return await w(this).addrPromise
        }
        async getDeployedCode() {
            const F = c(this.runner);
            (0,
            r.assert)(F, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
                operation: "getDeployedCode"
            });
            const z = await F.getCode(await this.getAddress());
            return z === "0x" ? null : z
        }
        async waitForDeployment() {
            const F = this.deploymentTransaction();
            if (F)
                return await F.wait(),
                this;
            if (await this.getDeployedCode() != null)
                return this;
            const Y = c(this.runner);
            return (0,
            r.assert)(Y != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", {
                operation: "waitForDeployment"
            }),
            new Promise( (ie, ne) => {
                const xe = async () => {
                    try {
                        if (await this.getDeployedCode() != null)
                            return ie(this);
                        Y.once("block", xe)
                    } catch (W) {
                        ne(W)
                    }
                }
                ;
                xe()
            }
            )
        }
        deploymentTransaction() {
            return w(this).deployTx
        }
        getFunction(F) {
            return typeof F != "string" && (F = F.format()),
            v(this, F)
        }
        getEvent(F) {
            return typeof F != "string" && (F = F.format()),
            b(this, F)
        }
        async queryTransaction(F) {
            throw new Error("@TODO")
        }
        async queryFilter(F, z, Y) {
            z == null && (z = 0),
            Y == null && (Y = "latest");
            const {addr: ie, addrPromise: ne} = w(this)
              , xe = ie || await ne
              , {fragment: W, topics: ee} = await T(this, F)
              , te = {
                address: xe,
                topics: ee,
                fromBlock: z,
                toBlock: Y
            }
              , fe = c(this.runner);
            return (0,
            r.assert)(fe, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", {
                operation: "queryFilter"
            }),
            (await fe.getLogs(te)).map(be => {
                let le = W;
                if (le == null)
                    try {
                        le = this.interface.getEvent(be.topics[0])
                    } catch {}
                if (le)
                    try {
                        return new n.EventLog(be,this.interface,le)
                    } catch (re) {
                        return new n.UndecodedEventLog(be,re)
                    }
                return new s.Log(be,fe)
            }
            )
        }
        async on(F, z) {
            const Y = await N(this, "on", F);
            return Y.listeners.push({
                listener: z,
                once: !1
            }),
            Y.start(),
            this
        }
        async once(F, z) {
            const Y = await N(this, "once", F);
            return Y.listeners.push({
                listener: z,
                once: !0
            }),
            Y.start(),
            this
        }
        async emit(F, ...z) {
            return await y(this, F, z, null)
        }
        async listenerCount(F) {
            if (F) {
                const ie = await C(this, F);
                return ie ? ie.listeners.length : 0
            }
            const {subs: z} = w(this);
            let Y = 0;
            for (const {listeners: ie} of z.values())
                Y += ie.length;
            return Y
        }
        async listeners(F) {
            if (F) {
                const ie = await C(this, F);
                return ie ? ie.listeners.map( ({listener: ne}) => ne) : []
            }
            const {subs: z} = w(this);
            let Y = [];
            for (const {listeners: ie} of z.values())
                Y = Y.concat(ie.map( ({listener: ne}) => ne));
            return Y
        }
        async off(F, z) {
            const Y = await C(this, F);
            if (!Y)
                return this;
            if (z) {
                const ie = Y.listeners.map( ({listener: ne}) => ne).indexOf(z);
                ie >= 0 && Y.listeners.splice(ie, 1)
            }
            return (z == null || Y.listeners.length === 0) && (Y.stop(),
            w(this).subs.delete(Y.tag)),
            this
        }
        async removeAllListeners(F) {
            if (F) {
                const z = await C(this, F);
                if (!z)
                    return this;
                z.stop(),
                w(this).subs.delete(z.tag)
            } else {
                const {subs: z} = w(this);
                for (const {tag: Y, stop: ie} of z.values())
                    ie(),
                    z.delete(Y)
            }
            return this
        }
        async addListener(F, z) {
            return await this.on(F, z)
        }
        async removeListener(F, z) {
            return await this.off(F, z)
        }
        static buildClass(F) {
            class z extends B {
                constructor(ie, ne=null) {
                    super(ie, F, ne)
                }
            }
            return z
        }
        static from(F, z, Y) {
            return Y == null && (Y = null),
            new this(F,z,Y)
        }
    }
    ;
    let _ = B;
    Pt.BaseContract = _;
    function O() {
        return _
    }
    class L extends O() {
    }
    return Pt.Contract = L,
    Pt
}
var yn = {}, ec;
function bf() {
    if (ec)
        return yn;
    ec = 1,
    Object.defineProperty(yn, "__esModule", {
        value: !0
    }),
    yn.ContractFactory = void 0;
    const e = os()
      , t = tt()
      , s = Be()
      , r = tl();
    class n {
        constructor(h, m, f) {
            ue(this, "interface");
            ue(this, "bytecode");
            ue(this, "runner");
            const i = e.Interface.from(h);
            m instanceof Uint8Array || (typeof m == "object" && (m = m.object),
            m.startsWith("0x") || (m = "0x" + m)),
            m = (0,
            s.hexlify)((0,
            s.getBytes)(m)),
            (0,
            s.defineProperties)(this, {
                bytecode: m,
                interface: i,
                runner: f || null
            })
        }
        attach(h) {
            return new r.BaseContract(h,this.interface,this.runner)
        }
        async getDeployTransaction(...h) {
            let m = {};
            const f = this.interface.deploy;
            if (f.inputs.length + 1 === h.length && (m = await (0,
            r.copyOverrides)(h.pop())),
            f.inputs.length !== h.length)
                throw new Error("incorrect number of arguments to constructor");
            const i = await (0,
            r.resolveArgs)(this.runner, f.inputs, h)
              , l = (0,
            s.concat)([this.bytecode, this.interface.encodeDeploy(i)]);
            return Object.assign({}, m, {
                data: l
            })
        }
        async deploy(...h) {
            const m = await this.getDeployTransaction(...h);
            (0,
            s.assert)(this.runner && typeof this.runner.sendTransaction == "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
            });
            const f = await this.runner.sendTransaction(m)
              , i = (0,
            t.getCreateAddress)(f);
            return new r.BaseContract(i,this.interface,this.runner,f)
        }
        connect(h) {
            return new n(this.interface,this.bytecode,h)
        }
        static fromSolidity(h, m) {
            (0,
            s.assertArgument)(h != null, "bad compiler output", "output", h),
            typeof h == "string" && (h = JSON.parse(h));
            const f = h.abi;
            let i = "";
            return h.bytecode ? i = h.bytecode : h.evm && h.evm.bytecode && (i = h.evm.bytecode),
            new this(f,i,m)
        }
    }
    return yn.ContractFactory = n,
    yn
}
var tc;
function Cs() {
    return tc || (tc = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.UndecodedEventLog = e.EventLog = e.ContractTransactionResponse = e.ContractTransactionReceipt = e.ContractUnknownEventPayload = e.ContractEventPayload = e.ContractFactory = e.Contract = e.BaseContract = void 0;
        var t = tl();
        Object.defineProperty(e, "BaseContract", {
            enumerable: !0,
            get: function() {
                return t.BaseContract
            }
        }),
        Object.defineProperty(e, "Contract", {
            enumerable: !0,
            get: function() {
                return t.Contract
            }
        });
        var s = bf();
        Object.defineProperty(e, "ContractFactory", {
            enumerable: !0,
            get: function() {
                return s.ContractFactory
            }
        });
        var r = el();
        Object.defineProperty(e, "ContractEventPayload", {
            enumerable: !0,
            get: function() {
                return r.ContractEventPayload
            }
        }),
        Object.defineProperty(e, "ContractUnknownEventPayload", {
            enumerable: !0,
            get: function() {
                return r.ContractUnknownEventPayload
            }
        }),
        Object.defineProperty(e, "ContractTransactionReceipt", {
            enumerable: !0,
            get: function() {
                return r.ContractTransactionReceipt
            }
        }),
        Object.defineProperty(e, "ContractTransactionResponse", {
            enumerable: !0,
            get: function() {
                return r.ContractTransactionResponse
            }
        }),
        Object.defineProperty(e, "EventLog", {
            enumerable: !0,
            get: function() {
                return r.EventLog
            }
        }),
        Object.defineProperty(e, "UndecodedEventLog", {
            enumerable: !0,
            get: function() {
                return r.UndecodedEventLog
            }
        })
    }(ai)),
    ai
}
var ci = {}, mr = {}, Ft = {}, rc;
function nl() {
    var o, c, u, Nr, P, rl;
    if (rc)
        return Ft;
    rc = 1,
    Object.defineProperty(Ft, "__esModule", {
        value: !0
    }),
    Ft.EnsResolver = Ft.BasicMulticoinProviderPlugin = Ft.MulticoinProviderPlugin = void 0;
    const e = tt()
      , t = is()
      , s = Cs()
      , r = qt()
      , n = Be();
    function d(x) {
        return x.match(/^ipfs:\/\/ipfs\//i) ? x = x.substring(12) : x.match(/^ipfs:\/\//i) ? x = x.substring(7) : (0,
        n.assertArgument)(!1, "unsupported IPFS format", "link", x),
        `https://gateway.ipfs.io/ipfs/${x}`
    }
    class h {
        constructor(a) {
            ue(this, "name");
            (0,
            n.defineProperties)(this, {
                name: a
            })
        }
        connect(a) {
            return this
        }
        supportsCoinType(a) {
            return !1
        }
        async encodeAddress(a, E) {
            throw new Error("unsupported coin")
        }
        async decodeAddress(a, E) {
            throw new Error("unsupported coin")
        }
    }
    Ft.MulticoinProviderPlugin = h;
    const m = "org.ethers.plugins.provider.BasicMulticoin";
    class f extends h {
        constructor() {
            super(m)
        }
    }
    Ft.BasicMulticoinProviderPlugin = f;
    const i = new RegExp("^(ipfs)://(.*)$","i")
      , l = [new RegExp("^(https)://(.*)$","i"), new RegExp("^(data):(.*)$","i"), i, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$","i")]
      , b = class b {
        constructor(a, E, w) {
            he(this, u);
            ue(this, "provider");
            ue(this, "address");
            ue(this, "name");
            he(this, o);
            he(this, c);
            (0,
            n.defineProperties)(this, {
                provider: a,
                address: E,
                name: w
            }),
            Q(this, o, null),
            Q(this, c, new s.Contract(E,["function supportsInterface(bytes4) view returns (bool)", "function resolve(bytes, bytes) view returns (bytes)", "function addr(bytes32) view returns (address)", "function addr(bytes32, uint) view returns (bytes)", "function text(bytes32, string) view returns (string)", "function contenthash(bytes32) view returns (bytes)"],a))
        }
        async supportsWildcard() {
            return j(this, o) == null && Q(this, o, (async () => {
                try {
                    return await j(this, c).supportsInterface("0x9061b923")
                } catch (a) {
                    if ((0,
                    n.isError)(a, "CALL_EXCEPTION"))
                        return !1;
                    throw Q(this, o, null),
                    a
                }
            }
            )()),
            await j(this, o)
        }
        async getAddress(a) {
            if (a == null && (a = 60),
            a === 60)
                try {
                    const T = await we(this, u, Nr).call(this, "addr(bytes32)");
                    return T == null || T === t.ZeroAddress ? null : T
                } catch (T) {
                    if ((0,
                    n.isError)(T, "CALL_EXCEPTION"))
                        return null;
                    throw T
                }
            if (a >= 0 && a < 2147483648) {
                let T = a + 2147483648;
                const C = await we(this, u, Nr).call(this, "addr(bytes32,uint)", [T]);
                if ((0,
                n.isHexString)(C, 20))
                    return (0,
                    e.getAddress)(C)
            }
            let E = null;
            for (const T of this.provider.plugins)
                if (T instanceof h && T.supportsCoinType(a)) {
                    E = T;
                    break
                }
            if (E == null)
                return null;
            const w = await we(this, u, Nr).call(this, "addr(bytes32,uint)", [a]);
            if (w == null || w === "0x")
                return null;
            const S = await E.decodeAddress(a, w);
            if (S != null)
                return S;
            (0,
            n.assert)(!1, "invalid coin data", "UNSUPPORTED_OPERATION", {
                operation: `getAddress(${a})`,
                info: {
                    coinType: a,
                    data: w
                }
            })
        }
        async getText(a) {
            const E = await we(this, u, Nr).call(this, "text(bytes32,string)", [a]);
            return E == null || E === "0x" ? null : E
        }
        async getContentHash() {
            const a = await we(this, u, Nr).call(this, "contenthash(bytes32)");
            if (a == null || a === "0x")
                return null;
            const E = a.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (E) {
                const S = E[1] === "e3010170" ? "ipfs" : "ipns"
                  , T = parseInt(E[4], 16);
                if (E[5].length === T * 2)
                    return `${S}://${(0,
                    n.encodeBase58)("0x" + E[2])}`
            }
            const w = a.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (w && w[1].length === 64)
                return `bzz://${w[1]}`;
            (0,
            n.assert)(!1, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
                operation: "getContentHash()",
                info: {
                    data: a
                }
            })
        }
        async getAvatar() {
            return (await this._getAvatar()).url
        }
        async _getAvatar() {
            const a = [{
                type: "name",
                value: this.name
            }];
            try {
                const E = await this.getText("avatar");
                if (E == null)
                    return a.push({
                        type: "!avatar",
                        value: ""
                    }),
                    {
                        url: null,
                        linkage: a
                    };
                a.push({
                    type: "avatar",
                    value: E
                });
                for (let w = 0; w < l.length; w++) {
                    const S = E.match(l[w]);
                    if (S == null)
                        continue;
                    const T = S[1].toLowerCase();
                    switch (T) {
                    case "https":
                    case "data":
                        return a.push({
                            type: "url",
                            value: E
                        }),
                        {
                            linkage: a,
                            url: E
                        };
                    case "ipfs":
                        {
                            const C = d(E);
                            return a.push({
                                type: "ipfs",
                                value: E
                            }),
                            a.push({
                                type: "url",
                                value: C
                            }),
                            {
                                linkage: a,
                                url: C
                            }
                        }
                    case "erc721":
                    case "erc1155":
                        {
                            const C = T === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
                            a.push({
                                type: T,
                                value: E
                            });
                            const N = await this.getAddress();
                            if (N == null)
                                return a.push({
                                    type: "!owner",
                                    value: ""
                                }),
                                {
                                    url: null,
                                    linkage: a
                                };
                            const A = (S[2] || "").split("/");
                            if (A.length !== 2)
                                return a.push({
                                    type: `!${T}caip`,
                                    value: S[2] || ""
                                }),
                                {
                                    url: null,
                                    linkage: a
                                };
                            const R = A[1]
                              , y = new s.Contract(A[0],["function tokenURI(uint) view returns (string)", "function ownerOf(uint) view returns (address)", "function uri(uint) view returns (string)", "function balanceOf(address, uint256) view returns (uint)"],this.provider);
                            if (T === "erc721") {
                                const U = await y.ownerOf(R);
                                if (N !== U)
                                    return a.push({
                                        type: "!owner",
                                        value: U
                                    }),
                                    {
                                        url: null,
                                        linkage: a
                                    };
                                a.push({
                                    type: "owner",
                                    value: U
                                })
                            } else if (T === "erc1155") {
                                const U = await y.balanceOf(N, R);
                                if (!U)
                                    return a.push({
                                        type: "!balance",
                                        value: "0"
                                    }),
                                    {
                                        url: null,
                                        linkage: a
                                    };
                                a.push({
                                    type: "balance",
                                    value: U.toString()
                                })
                            }
                            let k = await y[C](R);
                            if (k == null || k === "0x")
                                return a.push({
                                    type: "!metadata-url",
                                    value: ""
                                }),
                                {
                                    url: null,
                                    linkage: a
                                };
                            a.push({
                                type: "metadata-url-base",
                                value: k
                            }),
                            T === "erc1155" && (k = k.replace("{id}", (0,
                            n.toBeHex)(R, 32).substring(2)),
                            a.push({
                                type: "metadata-url-expanded",
                                value: k
                            })),
                            k.match(/^ipfs:/i) && (k = d(k)),
                            a.push({
                                type: "metadata-url",
                                value: k
                            });
                            let _ = {};
                            const O = await new n.FetchRequest(k).send();
                            O.assertOk();
                            try {
                                _ = O.bodyJson
                            } catch {
                                try {
                                    a.push({
                                        type: "!metadata",
                                        value: O.bodyText
                                    })
                                } catch {
                                    const B = O.body;
                                    return B && a.push({
                                        type: "!metadata",
                                        value: (0,
                                        n.hexlify)(B)
                                    }),
                                    {
                                        url: null,
                                        linkage: a
                                    }
                                }
                                return {
                                    url: null,
                                    linkage: a
                                }
                            }
                            if (!_)
                                return a.push({
                                    type: "!metadata",
                                    value: ""
                                }),
                                {
                                    url: null,
                                    linkage: a
                                };
                            a.push({
                                type: "metadata",
                                value: JSON.stringify(_)
                            });
                            let L = _.image;
                            if (typeof L != "string")
                                return a.push({
                                    type: "!imageUrl",
                                    value: ""
                                }),
                                {
                                    url: null,
                                    linkage: a
                                };
                            if (!L.match(/^(https:\/\/|data:)/i)) {
                                if (L.match(i) == null)
                                    return a.push({
                                        type: "!imageUrl-ipfs",
                                        value: L
                                    }),
                                    {
                                        url: null,
                                        linkage: a
                                    };
                                a.push({
                                    type: "imageUrl-ipfs",
                                    value: L
                                }),
                                L = d(L)
                            }
                            return a.push({
                                type: "url",
                                value: L
                            }),
                            {
                                linkage: a,
                                url: L
                            }
                        }
                    }
                }
            } catch {}
            return {
                linkage: a,
                url: null
            }
        }
        static async getEnsAddress(a) {
            const E = await a.getNetwork()
              , w = E.getPlugin("org.ethers.plugins.network.Ens");
            return (0,
            n.assert)(w, "network does not support ENS", "UNSUPPORTED_OPERATION", {
                operation: "getEnsAddress",
                info: {
                    network: E
                }
            }),
            w.address
        }
        static async fromName(a, E) {
            var S;
            let w = E;
            for (; ; ) {
                if (w === "" || w === "." || E !== "eth" && w === "eth")
                    return null;
                const T = await we(S = b, P, rl).call(S, a, w);
                if (T != null) {
                    const C = new b(a,T,E);
                    return w !== E && !await C.supportsWildcard() ? null : C
                }
                w = w.split(".").slice(1).join(".")
            }
        }
    }
    ;
    o = new WeakMap,
    c = new WeakMap,
    u = new WeakSet,
    Nr = async function(a, E) {
        E = (E || []).slice();
        const w = j(this, c).interface;
        E.unshift((0,
        r.namehash)(this.name));
        let S = null;
        await this.supportsWildcard() && (S = w.getFunction(a),
        (0,
        n.assert)(S, "missing fragment", "UNKNOWN_ERROR", {
            info: {
                funcName: a
            }
        }),
        E = [(0,
        r.dnsEncode)(this.name, 255), w.encodeFunctionData(S, E)],
        a = "resolve(bytes,bytes)"),
        E.push({
            enableCcipRead: !0
        });
        try {
            const T = await j(this, c)[a](...E);
            return S ? w.decodeFunctionResult(S, T)[0] : T
        } catch (T) {
            if (!(0,
            n.isError)(T, "CALL_EXCEPTION"))
                throw T
        }
        return null
    }
    ,
    P = new WeakSet,
    rl = async function(a, E) {
        const w = await b.getEnsAddress(a);
        try {
            const T = await new s.Contract(w,["function resolver(bytes32) view returns (address)"],a).resolver((0,
            r.namehash)(E), {
                enableCcipRead: !0
            });
            return T === t.ZeroAddress ? null : T
        } catch (S) {
            throw S
        }
        return null
    }
    ,
    he(b, P);
    let p = b;
    return Ft.EnsResolver = p,
    Ft
}
var Ve = {}, nc;
function gf() {
    if (nc)
        return Ve;
    nc = 1,
    Object.defineProperty(Ve, "__esModule", {
        value: !0
    }),
    Ve.formatTransactionResponse = Ve.formatTransactionReceipt = Ve.formatReceiptLog = Ve.formatBlock = Ve.formatLog = Ve.formatUint256 = Ve.formatHash = Ve.formatData = Ve.formatBoolean = Ve.object = Ve.arrayOf = Ve.allowNull = void 0;
    const e = tt()
      , t = st()
      , s = lt()
      , r = Be()
      , n = BigInt(0);
    function d(E, w) {
        return function(S) {
            return S == null ? w : E(S)
        }
    }
    Ve.allowNull = d;
    function h(E, w) {
        return S => {
            if (w && S == null)
                return null;
            if (!Array.isArray(S))
                throw new Error("not an array");
            return S.map(T => E(T))
        }
    }
Ve.arrayOf = h;
    function m(E, w) {
        return S => {
            const T = {};
            for (const C in E) {
                let N = C;
                if (w && C in w && !(N in S)) {
                    for (const A of w[C])
                        if (A in S) {
                            N = A;
                            break
                        }
                }
                try {
                    const A = E[C](S[N]);
                    A !== void 0 && (T[C] = A)
                } catch (A) {
                    const R = A instanceof Error ? A.message : "not-an-error";
                    (0,
                    r.assert)(!1, `invalid value for value.${C} (${R})`, "BAD_DATA", {
                        value: S
                    })
                }
            }
            return T
        }
    }
    Ve.object = m;
    function f(E) {
        switch (E) {
        case !0:
        case "true":
            return !0;
        case !1:
        case "false":
            return !1
        }
        (0,
        r.assertArgument)(!1, `invalid boolean; ${JSON.stringify(E)}`, "value", E)
    }
    Ve.formatBoolean = f;
    function i(E) {
        return (0,
        r.assertArgument)((0,
        r.isHexString)(E, !0), "invalid data", "value", E),
        E
    }
    Ve.formatData = i;
    function l(E) {
        return (0,
        r.assertArgument)((0,
        r.isHexString)(E, 32), "invalid hash", "value", E),
        E
    }
    Ve.formatHash = l;
    function p(E) {
        if (!(0,
        r.isHexString)(E))
            throw new Error("invalid uint256");
        return (0,
        r.zeroPadValue)(E, 32)
    }
    Ve.formatUint256 = p;
    const o = m({
        address: e.getAddress,
        blockHash: l,
        blockNumber: r.getNumber,
        data: i,
        index: r.getNumber,
        removed: d(f, !1),
        topics: h(l),
        transactionHash: l,
        transactionIndex: r.getNumber
    }, {
        index: ["logIndex"]
    });
    function c(E) {
        return o(E)
    }
    Ve.formatLog = c;
    const u = m({
        hash: d(l),
        parentHash: l,
        parentBeaconBlockRoot: d(l, null),
        number: r.getNumber,
        timestamp: r.getNumber,
        nonce: d(i),
        difficulty: r.getBigInt,
        gasLimit: r.getBigInt,
        gasUsed: r.getBigInt,
        stateRoot: d(l, null),
        receiptsRoot: d(l, null),
        blobGasUsed: d(r.getBigInt, null),
        excessBlobGas: d(r.getBigInt, null),
        miner: d(e.getAddress),
        prevRandao: d(l, null),
        extraData: i,
        baseFeePerGas: d(r.getBigInt)
    }, {
        prevRandao: ["mixHash"]
    });
    function g(E) {
        const w = u(E);
        return w.transactions = E.transactions.map(S => typeof S == "string" ? S : a(S)),
        w
    }
    Ve.formatBlock = g;
    const P = m({
        transactionIndex: r.getNumber,
        blockNumber: r.getNumber,
        transactionHash: l,
        address: e.getAddress,
        topics: h(l),
        data: i,
        index: r.getNumber,
        blockHash: l
    }, {
        index: ["logIndex"]
    });
    function v(E) {
        return P(E)
    }
    Ve.formatReceiptLog = v;
    const b = m({
        to: d(e.getAddress, null),
        from: d(e.getAddress, null),
        contractAddress: d(e.getAddress, null),
        index: r.getNumber,
        root: d(r.hexlify),
        gasUsed: r.getBigInt,
        blobGasUsed: d(r.getBigInt, null),
        logsBloom: d(i),
        blockHash: l,
        hash: l,
        logs: h(v),
        blockNumber: r.getNumber,
        cumulativeGasUsed: r.getBigInt,
        effectiveGasPrice: d(r.getBigInt),
        blobGasPrice: d(r.getBigInt, null),
        status: d(r.getNumber),
        type: d(r.getNumber, 0)
    }, {
        effectiveGasPrice: ["gasPrice"],
        hash: ["transactionHash"],
        index: ["transactionIndex"]
    });
    function x(E) {
        return b(E)
    }
    Ve.formatTransactionReceipt = x;
    function a(E) {
        E.to && (0,
        r.getBigInt)(E.to) === n && (E.to = "0x0000000000000000000000000000000000000000");
        const w = m({
            hash: l,
            index: d(r.getNumber, void 0),
            type: S => S === "0x" || S == null ? 0 : (0,
            r.getNumber)(S),
            accessList: d(s.accessListify, null),
            blobVersionedHashes: d(h(l, !0), null),
            authorizationList: d(h(S => {
                let T;
                if (S.signature)
                    T = S.signature;
                else {
                    let C = S.yParity;
                    C === "0x1b" ? C = 0 : C === "0x1c" && (C = 1),
                    T = Object.assign({}, S, {
                        yParity: C
                    })
                }
                return {
                    address: (0,
                    e.getAddress)(S.address),
                    chainId: (0,
                    r.getBigInt)(S.chainId),
                    nonce: (0,
                    r.getBigInt)(S.nonce),
                    signature: t.Signature.from(T)
                }
            }
            , !1), null),
            blockHash: d(l, null),
            blockNumber: d(r.getNumber, null),
            transactionIndex: d(r.getNumber, null),
            from: e.getAddress,
            gasPrice: d(r.getBigInt),
            maxPriorityFeePerGas: d(r.getBigInt),
            maxFeePerGas: d(r.getBigInt),
            maxFeePerBlobGas: d(r.getBigInt, null),
            gasLimit: r.getBigInt,
            to: d(e.getAddress, null),
            value: r.getBigInt,
            nonce: r.getNumber,
            data: i,
            creates: d(e.getAddress, null),
            chainId: d(r.getBigInt, null)
        }, {
            data: ["input"],
            gasLimit: ["gas"],
            index: ["transactionIndex"]
        })(E);
        if (w.to == null && w.creates == null && (w.creates = (0,
        e.getCreateAddress)(w)),
        (E.type === 1 || E.type === 2) && E.accessList == null && (w.accessList = []),
        E.signature ? w.signature = t.Signature.from(E.signature) : w.signature = t.Signature.from(E),
        w.chainId == null) {
            const S = w.signature.legacyChainId;
            S != null && (w.chainId = S)
        }
        return w.blockHash && (0,
        r.getBigInt)(w.blockHash) === n && (w.blockHash = null),
        w
    }
    return Ve.formatTransactionResponse = a,
    Ve
}
var xn = {}, gt = {}, sc;
function Wi() {
    var f, l, p;
    if (sc)
        return gt;
    sc = 1,
    Object.defineProperty(gt, "__esModule", {
        value: !0
    }),
    gt.FetchUrlFeeDataNetworkPlugin = gt.FeeDataNetworkPlugin = gt.EnsPlugin = gt.GasCostPlugin = gt.NetworkPlugin = void 0;
    const e = Tr()
      , t = Be()
      , s = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
    class r {
        constructor(c) {
            ue(this, "name");
            (0,
            e.defineProperties)(this, {
                name: c
            })
        }
        clone() {
            return new r(this.name)
        }
    }
    gt.NetworkPlugin = r;
    class n extends r {
        constructor(u, g) {
            u == null && (u = 0);
            super(`org.ethers.network.plugins.GasCost#${u || 0}`);
            ue(this, "effectiveBlock");
            ue(this, "txBase");
            ue(this, "txCreate");
            ue(this, "txDataZero");
            ue(this, "txDataNonzero");
            ue(this, "txAccessListStorageKey");
            ue(this, "txAccessListAddress");
            const P = {
                effectiveBlock: u
            };
            function v(b, x) {
                let a = (g || {})[b];
                a == null && (a = x),
                (0,
                t.assertArgument)(typeof a == "number", `invalud value for ${b}`, "costs", g),
                P[b] = a
            }
            v("txBase", 21e3),
            v("txCreate", 32e3),
            v("txDataZero", 4),
            v("txDataNonzero", 16),
            v("txAccessListStorageKey", 1900),
            v("txAccessListAddress", 2400),
            (0,
            e.defineProperties)(this, P)
        }
        clone() {
            return new n(this.effectiveBlock,this)
        }
    }
    gt.GasCostPlugin = n;
    class d extends r {
        constructor(u, g) {
            super("org.ethers.plugins.network.Ens");
            ue(this, "address");
            ue(this, "targetNetwork");
            (0,
            e.defineProperties)(this, {
                address: u || s,
                targetNetwork: g ?? 1
            })
        }
        clone() {
            return new d(this.address,this.targetNetwork)
        }
    }
    gt.EnsPlugin = d;
    const i = class i extends r {
        constructor(u) {
            super("org.ethers.plugins.network.FeeData");
            he(this, f);
            Q(this, f, u)
        }
        get feeDataFunc() {
            return j(this, f)
        }
        async getFeeData(u) {
            return await j(this, f).call(this, u)
        }
        clone() {
            return new i(j(this, f))
        }
    }
    ;
    f = new WeakMap;
    let h = i;
    gt.FeeDataNetworkPlugin = h;
    class m extends r {
        constructor(u, g) {
            super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
            he(this, l);
            he(this, p);
            Q(this, l, u),
            Q(this, p, g)
        }
        get url() {
            return j(this, l)
        }
        get processFunc() {
            return j(this, p)
        }
        clone() {
            return this
        }
    }
    return l = new WeakMap,
    p = new WeakMap,
    gt.FetchUrlFeeDataNetworkPlugin = m,
    gt
}
var ic;
function dt() {
    var i, l, p;
    if (ic)
        return xn;
    ic = 1,
    Object.defineProperty(xn, "__esModule", {
        value: !0
    }),
    xn.Network = void 0;
    const e = lt()
      , t = Be()
      , s = Wi()
      , r = new Map
      , o = class o {
        constructor(u, g) {
            he(this, i);
            he(this, l);
            he(this, p);
            Q(this, i, u),
            Q(this, l, (0,
            t.getBigInt)(g)),
            Q(this, p, new Map)
        }
        toJSON() {
            return {
                name: this.name,
                chainId: String(this.chainId)
            }
        }
        get name() {
            return j(this, i)
        }
        set name(u) {
            Q(this, i, u)
        }
        get chainId() {
            return j(this, l)
        }
        set chainId(u) {
            Q(this, l, (0,
            t.getBigInt)(u, "chainId"))
        }
        matches(u) {
            if (u == null)
                return !1;
            if (typeof u == "string") {
                try {
                    return this.chainId === (0,
                    t.getBigInt)(u)
                } catch {}
                return this.name === u
            }
            if (typeof u == "number" || typeof u == "bigint") {
                try {
                    return this.chainId === (0,
                    t.getBigInt)(u)
                } catch {}
                return !1
            }
            if (typeof u == "object") {
                if (u.chainId != null) {
                    try {
                        return this.chainId === (0,
                        t.getBigInt)(u.chainId)
                    } catch {}
                    return !1
                }
                return u.name != null ? this.name === u.name : !1
            }
            return !1
        }
        get plugins() {
            return Array.from(j(this, p).values())
        }
        attachPlugin(u) {
            if (j(this, p).get(u.name))
                throw new Error(`cannot replace existing plugin: ${u.name} `);
            return j(this, p).set(u.name, u.clone()),
            this
        }
        getPlugin(u) {
            return j(this, p).get(u) || null
        }
        getPlugins(u) {
            return this.plugins.filter(g => g.name.split("#")[0] === u)
        }
        clone() {
            const u = new o(this.name,this.chainId);
            return this.plugins.forEach(g => {
                u.attachPlugin(g.clone())
            }
            ),
            u
        }
        computeIntrinsicGas(u) {
            const g = this.getPlugin("org.ethers.plugins.network.GasCost") || new s.GasCostPlugin;
            let P = g.txBase;
            if (u.to == null && (P += g.txCreate),
            u.data)
                for (let v = 2; v < u.data.length; v += 2)
                    u.data.substring(v, v + 2) === "00" ? P += g.txDataZero : P += g.txDataNonzero;
            if (u.accessList) {
                const v = (0,
                e.accessListify)(u.accessList);
                for (const b in v)
                    P += g.txAccessListAddress + g.txAccessListStorageKey * v[b].storageKeys.length
            }
            return P
        }
        static from(u) {
            if (f(),
            u == null)
                return o.from("mainnet");
            if (typeof u == "number" && (u = BigInt(u)),
            typeof u == "string" || typeof u == "bigint") {
                const g = r.get(u);
                if (g)
                    return g();
                if (typeof u == "bigint")
                    return new o("unknown",u);
                (0,
                t.assertArgument)(!1, "unknown network", "network", u)
            }
            if (typeof u.clone == "function")
                return u.clone();
            if (typeof u == "object") {
                (0,
                t.assertArgument)(typeof u.name == "string" && typeof u.chainId == "number", "invalid network object name or chainId", "network", u);
                const g = new o(u.name,u.chainId);
                return (u.ensAddress || u.ensNetwork != null) && g.attachPlugin(new s.EnsPlugin(u.ensAddress,u.ensNetwork)),
                g
            }
            (0,
            t.assertArgument)(!1, "invalid network", "network", u)
        }
        static register(u, g) {
            typeof u == "number" && (u = BigInt(u));
            const P = r.get(u);
            P && (0,
            t.assertArgument)(!1, `conflicting network for ${JSON.stringify(P.name)}`, "nameOrChainId", u),
            r.set(u, g)
        }
    }
    ;
    i = new WeakMap,
    l = new WeakMap,
    p = new WeakMap;
    let n = o;
    xn.Network = n;
    function d(c, u) {
        const g = String(c);
        if (!g.match(/^[0-9.]+$/))
            throw new Error(`invalid gwei value: ${c}`);
        const P = g.split(".");
        if (P.length === 1 && P.push(""),
        P.length !== 2)
            throw new Error(`invalid gwei value: ${c}`);
        for (; P[1].length < u; )
            P[1] += "0";
        if (P[1].length > 9) {
            let v = BigInt(P[1].substring(0, 9));
            P[1].substring(9).match(/^0+$/) || v++,
            P[1] = v.toString()
        }
        return BigInt(P[0] + P[1])
    }
    function h(c) {
        return new s.FetchUrlFeeDataNetworkPlugin(c,async (u, g, P) => {
            P.setHeader("User-Agent", "ethers");
            let v;
            try {
                const [b,x] = await Promise.all([P.send(), u()]);
                v = b;
                const a = v.bodyJson.standard;
                return {
                    gasPrice: x.gasPrice,
                    maxFeePerGas: d(a.maxFee, 9),
                    maxPriorityFeePerGas: d(a.maxPriorityFee, 9)
                }
            } catch (b) {
                (0,
                t.assert)(!1, `error encountered with polygon gas station (${JSON.stringify(P.url)})`, "SERVER_ERROR", {
                    request: P,
                    response: v,
                    error: b
                })
            }
        }
        )
    }
    let m = !1;
    function f() {
        if (m)
            return;
        m = !0;
        function c(u, g, P) {
            const v = function() {
                const b = new n(u,g);
                return P.ensNetwork != null && b.attachPlugin(new s.EnsPlugin(null,P.ensNetwork)),
                b.attachPlugin(new s.GasCostPlugin),
                (P.plugins || []).forEach(x => {
                    b.attachPlugin(x)
                }
                ),
                b
            };
            n.register(u, v),
            n.register(g, v),
            P.altNames && P.altNames.forEach(b => {
                n.register(b, v)
            }
            )
        }
        c("mainnet", 1, {
            ensNetwork: 1,
            altNames: ["homestead"]
        }),
        c("ropsten", 3, {
            ensNetwork: 3
        }),
        c("rinkeby", 4, {
            ensNetwork: 4
        }),
        c("goerli", 5, {
            ensNetwork: 5
        }),
        c("kovan", 42, {
            ensNetwork: 42
        }),
        c("sepolia", 11155111, {
            ensNetwork: 11155111
        }),
        c("holesky", 17e3, {
            ensNetwork: 17e3
        }),
        c("classic", 61, {}),
        c("classicKotti", 6, {}),
        c("arbitrum", 42161, {
            ensNetwork: 1
        }),
        c("arbitrum-goerli", 421613, {}),
        c("arbitrum-sepolia", 421614, {}),
        c("base", 8453, {
            ensNetwork: 1
        }),
        c("base-goerli", 84531, {}),
        c("base-sepolia", 84532, {}),
        c("bnb", 56, {
            ensNetwork: 1
        }),
        c("bnbt", 97, {}),
        c("linea", 59144, {
            ensNetwork: 1
        }),
        c("linea-goerli", 59140, {}),
        c("linea-sepolia", 59141, {}),
        c("matic", 137, {
            ensNetwork: 1,
            plugins: [h("https://gasstation.polygon.technology/v2")]
        }),
        c("matic-amoy", 80002, {}),
        c("matic-mumbai", 80001, {
            altNames: ["maticMumbai", "maticmum"],
            plugins: [h("https://gasstation-testnet.polygon.technology/v2")]
        }),
        c("optimism", 10, {
            ensNetwork: 1,
            plugins: []
        }),
        c("optimism-goerli", 420, {}),
        c("optimism-sepolia", 11155420, {}),
        c("xdai", 100, {
            ensNetwork: 1
        })
    }
    return xn
}
var it = {}, oc;
function Yi() {
    var i, l, p, o, c, ms, g, P, v, b, x, a, E, w, S, T, C, N, A, sl;
    if (oc)
        return it;
    oc = 1,
    Object.defineProperty(it, "__esModule", {
        value: !0
    }),
    it.PollingEventSubscriber = it.PollingTransactionSubscriber = it.PollingOrphanSubscriber = it.PollingBlockTagSubscriber = it.OnBlockSubscriber = it.PollingBlockSubscriber = it.getPollingSubscriber = void 0;
    const e = Be();
    function t(y) {
        return JSON.parse(JSON.stringify(y))
    }
    function s(y, k) {
        if (k === "block")
            return new r(y);
        if ((0,
        e.isHexString)(k, 32))
            return new m(y,k);
        (0,
        e.assert)(!1, "unsupported polling event", "UNSUPPORTED_OPERATION", {
            operation: "getPollingSubscriber",
            info: {
                event: k
            }
        })
    }
    it.getPollingSubscriber = s;
    class r {
        constructor(k) {
            he(this, c);
            he(this, i);
            he(this, l);
            he(this, p);
            he(this, o);
            Q(this, i, k),
            Q(this, l, null),
            Q(this, p, 4e3),
            Q(this, o, -2)
        }
        get pollingInterval() {
            return j(this, p)
        }
        set pollingInterval(k) {
            Q(this, p, k)
        }
        start() {
            j(this, l) || (Q(this, l, j(this, i)._setTimeout(we(this, c, ms).bind(this), j(this, p))),
            we(this, c, ms).call(this))
        }
        stop() {
            j(this, l) && (j(this, i)._clearTimeout(j(this, l)),
            Q(this, l, null))
        }
        pause(k) {
            this.stop(),
            k && Q(this, o, -2)
        }
        resume() {
            this.start()
        }
    }
    i = new WeakMap,
    l = new WeakMap,
    p = new WeakMap,
    o = new WeakMap,
    c = new WeakSet,
    ms = async function() {
        try {
            const k = await j(this, i).getBlockNumber();
            if (j(this, o) === -2) {
                Q(this, o, k);
                return
            }
            if (k !== j(this, o)) {
                for (let _ = j(this, o) + 1; _ <= k; _++) {
                    if (j(this, l) == null)
                        return;
                    await j(this, i).emit("block", _)
                }
                Q(this, o, k)
            }
        } catch {}
        j(this, l) != null && Q(this, l, j(this, i)._setTimeout(we(this, c, ms).bind(this), j(this, p)))
    }
    ,
    it.PollingBlockSubscriber = r;
    class n {
        constructor(k) {
            he(this, g);
            he(this, P);
            he(this, v);
            Q(this, g, k),
            Q(this, v, !1),
            Q(this, P, _ => {
                this._poll(_, j(this, g))
            }
            )
        }
        async _poll(k, _) {
            throw new Error("sub-classes must override this")
        }
        start() {
            j(this, v) || (Q(this, v, !0),
            j(this, P).call(this, -2),
            j(this, g).on("block", j(this, P)))
        }
        stop() {
            j(this, v) && (Q(this, v, !1),
            j(this, g).off("block", j(this, P)))
        }
        pause(k) {
            this.stop()
        }
        resume() {
            this.start()
        }
    }
    g = new WeakMap,
    P = new WeakMap,
    v = new WeakMap,
    it.OnBlockSubscriber = n;
    class d extends n {
        constructor(_, O) {
            super(_);
            he(this, b);
            he(this, x);
            Q(this, b, O),
            Q(this, x, -2)
        }
        pause(_) {
            _ && Q(this, x, -2),
            super.pause(_)
        }
        async _poll(_, O) {
            const L = await O.getBlock(j(this, b));
            L != null && (j(this, x) === -2 ? Q(this, x, L.number) : L.number > j(this, x) && (O.emit(j(this, b), L.number),
            Q(this, x, L.number)))
        }
    }
    b = new WeakMap,
    x = new WeakMap,
    it.PollingBlockTagSubscriber = d;
    class h extends n {
        constructor(_, O) {
            super(_);
            he(this, a);
            Q(this, a, t(O))
        }
        async _poll(_, O) {
            throw new Error("@TODO")
        }
    }
    a = new WeakMap,
    it.PollingOrphanSubscriber = h;
    class m extends n {
        constructor(_, O) {
            super(_);
            he(this, E);
            Q(this, E, O)
        }
        async _poll(_, O) {
            const L = await O.getTransactionReceipt(j(this, E));
            L && O.emit(j(this, E), L)
        }
    }
    E = new WeakMap,
    it.PollingTransactionSubscriber = m;
    class f {
        constructor(k, _) {
            he(this, A);
            he(this, w);
            he(this, S);
            he(this, T);
            he(this, C);
            he(this, N);
            Q(this, w, k),
            Q(this, S, t(_)),
            Q(this, T, we(this, A, sl).bind(this)),
            Q(this, C, !1),
            Q(this, N, -2)
        }
        start() {
            j(this, C) || (Q(this, C, !0),
            j(this, N) === -2 && j(this, w).getBlockNumber().then(k => {
                Q(this, N, k)
            }
            ),
            j(this, w).on("block", j(this, T)))
        }
        stop() {
            j(this, C) && (Q(this, C, !1),
            j(this, w).off("block", j(this, T)))
        }
        pause(k) {
            this.stop(),
            k && Q(this, N, -2)
        }
        resume() {
            this.start()
        }
    }
    return w = new WeakMap,
    S = new WeakMap,
    T = new WeakMap,
    C = new WeakMap,
    N = new WeakMap,
    A = new WeakSet,
    sl = async function(k) {
        if (j(this, N) === -2)
            return;
        const _ = t(j(this, S));
        _.fromBlock = j(this, N) + 1,
        _.toBlock = k;
        const O = await j(this, w).getLogs(_);
        if (O.length === 0) {
            j(this, N) < k - 60 && Q(this, N, k - 60);
            return
        }
        for (const L of O)
            j(this, w).emit(j(this, S), L),
            Q(this, N, L.blockNumber)
    }
    ,
    it.PollingEventSubscriber = f,
    it
}
var ac;
function cs() {
    var k, _, O, L, U, $, B, I, F, z, Y, ie, ne, xt, Ai, vi, es, Ei, ts, ys;
    if (ac)
        return mr;
    ac = 1,
    Object.defineProperty(mr, "__esModule", {
        value: !0
    }),
    mr.AbstractProvider = mr.UnmanagedSubscriber = void 0;
    const e = tt()
      , t = is()
      , s = Cs()
      , r = qt()
      , n = lt()
      , d = Be()
      , h = nl()
      , m = gf()
      , f = dt()
      , i = as()
      , l = Yi()
      , p = BigInt(2)
      , o = 10;
    function c(re) {
        return re && typeof re.then == "function"
    }
    function u(re, M) {
        return re + ":" + JSON.stringify(M, (K, V) => {
            if (V == null)
                return "null";
            if (typeof V == "bigint")
                return `bigint:${V.toString()}`;
            if (typeof V == "string")
                return V.toLowerCase();
            if (typeof V == "object" && !Array.isArray(V)) {
                const oe = Object.keys(V);
                return oe.sort(),
                oe.reduce( (me, Pe) => (me[Pe] = V[Pe],
                me), {})
            }
            return V
        }
        )
    }
    class g {
        constructor(M) {
            ue(this, "name");
            (0,
            d.defineProperties)(this, {
                name: M
            })
        }
        start() {}
        stop() {}
        pause(M) {}
        resume() {}
    }
    mr.UnmanagedSubscriber = g;
    function P(re) {
        return JSON.parse(JSON.stringify(re))
    }
    function v(re) {
        return re = Array.from(new Set(re).values()),
        re.sort(),
        re
    }
    async function b(re, M) {
        if (re == null)
            throw new Error("invalid event");
        if (Array.isArray(re) && (re = {
            topics: re
        }),
        typeof re == "string")
            switch (re) {
            case "block":
            case "debug":
            case "error":
            case "finalized":
            case "network":
            case "pending":
            case "safe":
                return {
                    type: re,
                    tag: re
                }
            }
        if ((0,
        d.isHexString)(re, 32)) {
            const K = re.toLowerCase();
            return {
                type: "transaction",
                tag: u("tx", {
                    hash: K
                }),
                hash: K
            }
        }
        if (re.orphan) {
            const K = re;
            return {
                type: "orphan",
                tag: u("orphan", K),
                filter: P(K)
            }
        }
        if (re.address || re.topics) {
            const K = re
              , V = {
                topics: (K.topics || []).map(oe => oe == null ? null : Array.isArray(oe) ? v(oe.map(me => me.toLowerCase())) : oe.toLowerCase())
            };
            if (K.address) {
                const oe = []
                  , me = []
                  , Pe = se => {
                    (0,
                    d.isHexString)(se) ? oe.push(se) : me.push((async () => {
                        oe.push(await (0,
                        e.resolveAddress)(se, M))
                    }
                    )())
                }
                ;
                Array.isArray(K.address) ? K.address.forEach(Pe) : Pe(K.address),
                me.length && await Promise.all(me),
                V.address = v(oe.map(se => se.toLowerCase()))
            }
            return {
                filter: V,
                tag: u("event", V),
                type: "event"
            }
        }
        (0,
        d.assertArgument)(!1, "unknown ProviderEvent", "event", re)
    }
    function x() {
        return new Date().getTime()
    }
    const a = {
        cacheTimeout: 250,
        pollingInterval: 4e3
    };
    class E {
        constructor(M, K) {
            he(this, ne);
            he(this, k);
            he(this, _);
            he(this, O);
            he(this, L);
            he(this, U);
            he(this, $);
            he(this, B);
            he(this, I);
            he(this, F);
            he(this, z);
            he(this, Y);
            he(this, ie);
            if (Q(this, ie, Object.assign({}, a, K || {})),
            M === "any")
                Q(this, $, !0),
                Q(this, U, null);
            else if (M) {
                const V = f.Network.from(M);
                Q(this, $, !1),
                Q(this, U, Promise.resolve(V)),
                setTimeout( () => {
                    this.emit("network", V, null)
                }
                , 0)
            } else
                Q(this, $, !1),
                Q(this, U, null);
            Q(this, I, -1),
            Q(this, B, new Map),
            Q(this, k, new Map),
            Q(this, _, new Map),
            Q(this, O, null),
            Q(this, L, !1),
            Q(this, F, 1),
            Q(this, z, new Map),
            Q(this, Y, !1)
        }
        get pollingInterval() {
            return j(this, ie).pollingInterval
        }
        get provider() {
            return this
        }
        get plugins() {
            return Array.from(j(this, _).values())
        }
        attachPlugin(M) {
            if (j(this, _).get(M.name))
                throw new Error(`cannot replace existing plugin: ${M.name} `);
            return j(this, _).set(M.name, M.connect(this)),
            this
        }
        getPlugin(M) {
            return j(this, _).get(M) || null
        }
        get disableCcipRead() {
            return j(this, Y)
        }
        set disableCcipRead(M) {
            Q(this, Y, !!M)
        }
        async ccipReadFetch(M, K, V) {
            if (this.disableCcipRead || V.length === 0 || M.to == null)
                return null;
            const oe = M.to.toLowerCase()
              , me = K.toLowerCase()
              , Pe = [];
            for (let se = 0; se < V.length; se++) {
                const H = V[se]
                  , G = H.replace("{sender}", oe).replace("{data}", me)
                  , q = new d.FetchRequest(G);
                H.indexOf("{data}") === -1 && (q.body = {
                    data: me,
                    sender: oe
                }),
                this.emit("debug", {
                    action: "sendCcipReadFetchRequest",
                    request: q,
                    index: se,
                    urls: V
                });
                let ae = "unknown error", Z;
                try {
                    Z = await q.send()
                } catch (J) {
                    Pe.push(J.message),
                    this.emit("debug", {
                        action: "receiveCcipReadFetchError",
                        request: q,
                        result: {
                            error: J
                        }
                    });
                    continue
                }
                try {
                    const J = Z.bodyJson;
                    if (J.data)
                        return this.emit("debug", {
                            action: "receiveCcipReadFetchResult",
                            request: q,
                            result: J
                        }),
                        J.data;
                    J.message && (ae = J.message),
                    this.emit("debug", {
                        action: "receiveCcipReadFetchError",
                        request: q,
                        result: J
                    })
                } catch {}
                (0,
                d.assert)(Z.statusCode < 400 || Z.statusCode >= 500, `response not found during CCIP fetch: ${ae}`, "OFFCHAIN_FAULT", {
                    reason: "404_MISSING_RESOURCE",
                    transaction: M,
                    info: {
                        url: H,
                        errorMessage: ae
                    }
                }),
                Pe.push(ae)
            }
            (0,
            d.assert)(!1, `error encountered during CCIP fetch: ${Pe.map(se => JSON.stringify(se)).join(", ")}`, "OFFCHAIN_FAULT", {
                reason: "500_SERVER_ERROR",
                transaction: M,
                info: {
                    urls: V,
                    errorMessages: Pe
                }
            })
        }
        _wrapBlock(M, K) {
            return new i.Block((0,
            m.formatBlock)(M),this)
        }
        _wrapLog(M, K) {
            return new i.Log((0,
            m.formatLog)(M),this)
        }
        _wrapTransactionReceipt(M, K) {
            return new i.TransactionReceipt((0,
            m.formatTransactionReceipt)(M),this)
        }
        _wrapTransactionResponse(M, K) {
            return new i.TransactionResponse((0,
            m.formatTransactionResponse)(M),this)
        }
        _detectNetwork() {
            (0,
            d.assert)(!1, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
                operation: "_detectNetwork"
            })
        }
        async _perform(M) {
            (0,
            d.assert)(!1, `unsupported method: ${M.method}`, "UNSUPPORTED_OPERATION", {
                operation: M.method,
                info: M
            })
        }
        async getBlockNumber() {
            const M = (0,
            d.getNumber)(await we(this, ne, xt).call(this, {
                method: "getBlockNumber"
            }), "%response");
            return j(this, I) >= 0 && Q(this, I, M),
            M
        }
        _getAddress(M) {
            return (0,
            e.resolveAddress)(M, this)
        }
        _getBlockTag(M) {
            if (M == null)
                return "latest";
            switch (M) {
            case "earliest":
                return "0x0";
            case "finalized":
            case "latest":
            case "pending":
            case "safe":
                return M
            }
            if ((0,
            d.isHexString)(M))
                return (0,
                d.isHexString)(M, 32) ? M : (0,
                d.toQuantity)(M);
            if (typeof M == "bigint" && (M = (0,
            d.getNumber)(M, "blockTag")),
            typeof M == "number")
                return M >= 0 ? (0,
                d.toQuantity)(M) : j(this, I) >= 0 ? (0,
                d.toQuantity)(j(this, I) + M) : this.getBlockNumber().then(K => (0,
                d.toQuantity)(K + M));
            (0,
            d.assertArgument)(!1, "invalid blockTag", "blockTag", M)
        }
        _getFilter(M) {
            const K = (M.topics || []).map(H => H == null ? null : Array.isArray(H) ? v(H.map(G => G.toLowerCase())) : H.toLowerCase())
              , V = "blockHash"in M ? M.blockHash : void 0
              , oe = (H, G, q) => {
                let ae;
                switch (H.length) {
                case 0:
                    break;
                case 1:
                    ae = H[0];
                    break;
                default:
                    H.sort(),
                    ae = H
                }
                if (V && (G != null || q != null))
                    throw new Error("invalid filter");
                const Z = {};
                return ae && (Z.address = ae),
                K.length && (Z.topics = K),
                G && (Z.fromBlock = G),
                q && (Z.toBlock = q),
                V && (Z.blockHash = V),
                Z
            }
            ;
            let me = [];
            if (M.address)
                if (Array.isArray(M.address))
                    for (const H of M.address)
                        me.push(this._getAddress(H));
                else
                    me.push(this._getAddress(M.address));
            let Pe;
            "fromBlock"in M && (Pe = this._getBlockTag(M.fromBlock));
            let se;
            return "toBlock"in M && (se = this._getBlockTag(M.toBlock)),
            me.filter(H => typeof H != "string").length || Pe != null && typeof Pe != "string" || se != null && typeof se != "string" ? Promise.all([Promise.all(me), Pe, se]).then(H => oe(H[0], H[1], H[2])) : oe(me, Pe, se)
        }
        _getTransactionRequest(M) {
            const K = (0,
            i.copyRequest)(M)
              , V = [];
            if (["to", "from"].forEach(oe => {
                if (K[oe] == null)
                    return;
                const me = (0,
                e.resolveAddress)(K[oe], this);
                c(me) ? V.push(async function() {
                    K[oe] = await me
                }()) : K[oe] = me
            }
            ),
            K.blockTag != null) {
                const oe = this._getBlockTag(K.blockTag);
                c(oe) ? V.push(async function() {
                    K.blockTag = await oe
                }()) : K.blockTag = oe
            }
            return V.length ? async function() {
                return await Promise.all(V),
                K
            }() : K
        }
        async getNetwork() {
            if (j(this, U) == null) {
                const oe = (async () => {
                    try {
                        const me = await this._detectNetwork();
                        return this.emit("network", me, null),
                        me
                    } catch (me) {
                        throw j(this, U) === oe && Q(this, U, null),
                        me
                    }
                }
                )();
                return Q(this, U, oe),
                (await oe).clone()
            }
            const M = j(this, U)
              , [K,V] = await Promise.all([M, this._detectNetwork()]);
            return K.chainId !== V.chainId && (j(this, $) ? (this.emit("network", V, K),
            j(this, U) === M && Q(this, U, Promise.resolve(V))) : (0,
            d.assert)(!1, `network changed: ${K.chainId} => ${V.chainId} `, "NETWORK_ERROR", {
                event: "changed"
            })),
            K.clone()
        }
        async getFeeData() {
            const M = await this.getNetwork()
              , K = async () => {
                const {_block: oe, gasPrice: me, priorityFee: Pe} = await (0,
                d.resolveProperties)({
                    _block: we(this, ne, Ei).call(this, "latest", !1),
                    gasPrice: (async () => {
                        try {
                            const q = await we(this, ne, xt).call(this, {
                                method: "getGasPrice"
                            });
                            return (0,
                            d.getBigInt)(q, "%response")
                        } catch {}
                        return null
                    }
                    )(),
                    priorityFee: (async () => {
                        try {
                            const q = await we(this, ne, xt).call(this, {
                                method: "getPriorityFee"
                            });
                            return (0,
                            d.getBigInt)(q, "%response")
                        } catch {}
                        return null
                    }
                    )()
                });
                let se = null
                  , H = null;
                const G = this._wrapBlock(oe, M);
                return G && G.baseFeePerGas && (H = Pe ?? BigInt("1000000000"),
                se = G.baseFeePerGas * p + H),
                new i.FeeData(me,se,H)
            }
              , V = M.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
            if (V) {
                const oe = new d.FetchRequest(V.url)
                  , me = await V.processFunc(K, this, oe);
                return new i.FeeData(me.gasPrice,me.maxFeePerGas,me.maxPriorityFeePerGas)
            }
            return await K()
        }
        async estimateGas(M) {
            let K = this._getTransactionRequest(M);
            return c(K) && (K = await K),
            (0,
            d.getBigInt)(await we(this, ne, xt).call(this, {
                method: "estimateGas",
                transaction: K
            }), "%response")
        }
        async call(M) {
            const {tx: K, blockTag: V} = await (0,
            d.resolveProperties)({
                tx: this._getTransactionRequest(M),
                blockTag: this._getBlockTag(M.blockTag)
            });
            return await we(this, ne, vi).call(this, we(this, ne, Ai).call(this, K, V, M.enableCcipRead ? 0 : -1))
        }
        async getBalance(M, K) {
            return (0,
            d.getBigInt)(await we(this, ne, es).call(this, {
                method: "getBalance"
            }, M, K), "%response")
        }
        async getTransactionCount(M, K) {
            return (0,
            d.getNumber)(await we(this, ne, es).call(this, {
                method: "getTransactionCount"
            }, M, K), "%response")
        }
        async getCode(M, K) {
            return (0,
            d.hexlify)(await we(this, ne, es).call(this, {
                method: "getCode"
            }, M, K))
        }
        async getStorage(M, K, V) {
            const oe = (0,
            d.getBigInt)(K, "position");
            return (0,
            d.hexlify)(await we(this, ne, es).call(this, {
                method: "getStorage",
                position: oe
            }, M, V))
        }
        async broadcastTransaction(M) {
            const {blockNumber: K, hash: V, network: oe} = await (0,
            d.resolveProperties)({
                blockNumber: this.getBlockNumber(),
                hash: this._perform({
                    method: "broadcastTransaction",
                    signedTransaction: M
                }),
                network: this.getNetwork()
            })
              , me = n.Transaction.from(M);
            if (me.hash !== V)
                throw new Error("@TODO: the returned hash did not match");
            return this._wrapTransactionResponse(me, oe).replaceableTransaction(K)
        }
        async getBlock(M, K) {
            const {network: V, params: oe} = await (0,
            d.resolveProperties)({
                network: this.getNetwork(),
                params: we(this, ne, Ei).call(this, M, !!K)
            });
            return oe == null ? null : this._wrapBlock(oe, V)
        }
        async getTransaction(M) {
            const {network: K, params: V} = await (0,
            d.resolveProperties)({
                network: this.getNetwork(),
                params: we(this, ne, xt).call(this, {
                    method: "getTransaction",
                    hash: M
                })
            });
            return V == null ? null : this._wrapTransactionResponse(V, K)
        }
        async getTransactionReceipt(M) {
            const {network: K, params: V} = await (0,
            d.resolveProperties)({
                network: this.getNetwork(),
                params: we(this, ne, xt).call(this, {
                    method: "getTransactionReceipt",
                    hash: M
                })
            });
            if (V == null)
                return null;
            if (V.gasPrice == null && V.effectiveGasPrice == null) {
                const oe = await we(this, ne, xt).call(this, {
                    method: "getTransaction",
                    hash: M
                });
                if (oe == null)
                    throw new Error("report this; could not find tx or effectiveGasPrice");
                V.effectiveGasPrice = oe.gasPrice
            }
            return this._wrapTransactionReceipt(V, K)
        }
        async getTransactionResult(M) {
            const {result: K} = await (0,
            d.resolveProperties)({
                network: this.getNetwork(),
                result: we(this, ne, xt).call(this, {
                    method: "getTransactionResult",
                    hash: M
                })
            });
            return K == null ? null : (0,
            d.hexlify)(K)
        }
        async getLogs(M) {
            let K = this._getFilter(M);
            c(K) && (K = await K);
            const {network: V, params: oe} = await (0,
            d.resolveProperties)({
                network: this.getNetwork(),
                params: we(this, ne, xt).call(this, {
                    method: "getLogs",
                    filter: K
                })
            });
            return oe.map(me => this._wrapLog(me, V))
        }
        _getProvider(M) {
            (0,
            d.assert)(!1, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
                operation: "_getProvider()"
            })
        }
        async getResolver(M) {
            return await h.EnsResolver.fromName(this, M)
        }
        async getAvatar(M) {
            const K = await this.getResolver(M);
            return K ? await K.getAvatar() : null
        }
        async resolveName(M) {
            const K = await this.getResolver(M);
            return K ? await K.getAddress() : null
        }
        async lookupAddress(M) {
            M = (0,
            e.getAddress)(M);
            const K = (0,
            r.namehash)(M.substring(2).toLowerCase() + ".addr.reverse");
            try {
                const V = await h.EnsResolver.getEnsAddress(this)
                  , me = await new s.Contract(V,["function resolver(bytes32) view returns (address)"],this).resolver(K);
                if (me == null || me === t.ZeroAddress)
                    return null;
                const se = await new s.Contract(me,["function name(bytes32) view returns (string)"],this).name(K);
                return await this.resolveName(se) !== M ? null : se
            } catch (V) {
                if ((0,
                d.isError)(V, "BAD_DATA") && V.value === "0x" || (0,
                d.isError)(V, "CALL_EXCEPTION"))
                    return null;
                throw V
            }
            return null
        }
        async waitForTransaction(M, K, V) {
            const oe = K ?? 1;
            return oe === 0 ? this.getTransactionReceipt(M) : new Promise(async (me, Pe) => {
                let se = null;
                const H = async G => {
                    try {
                        const q = await this.getTransactionReceipt(M);
                        if (q != null && G - q.blockNumber + 1 >= oe) {
                            me(q),
                            se && (clearTimeout(se),
                            se = null);
                            return
                        }
                    } catch (q) {
                        console.log("EEE", q)
                    }
                    this.once("block", H)
                }
                ;
                V != null && (se = setTimeout( () => {
                    se != null && (se = null,
                    this.off("block", H),
                    Pe((0,
                    d.makeError)("timeout", "TIMEOUT", {
                        reason: "timeout"
                    })))
                }
                , V)),
                H(await this.getBlockNumber())
            }
            )
        }
        async waitForBlock(M) {
            (0,
            d.assert)(!1, "not implemented yet", "NOT_IMPLEMENTED", {
                operation: "waitForBlock"
            })
        }
        _clearTimeout(M) {
            const K = j(this, z).get(M);
            K && (K.timer && clearTimeout(K.timer),
            j(this, z).delete(M))
        }
        _setTimeout(M, K) {
            K == null && (K = 0);
            const V = Br(this, F)._++
              , oe = () => {
                j(this, z).delete(V),
                M()
            }
            ;
            if (this.paused)
                j(this, z).set(V, {
                    timer: null,
                    func: oe,
                    time: K
                });
            else {
                const me = setTimeout(oe, K);
                j(this, z).set(V, {
                    timer: me,
                    func: oe,
                    time: x()
                })
            }
            return V
        }
        _forEachSubscriber(M) {
            for (const K of j(this, k).values())
                M(K.subscriber)
        }
        _getSubscriber(M) {
            switch (M.type) {
            case "debug":
            case "error":
            case "network":
                return new g(M.type);
            case "block":
                {
                    const K = new l.PollingBlockSubscriber(this);
                    return K.pollingInterval = this.pollingInterval,
                    K
                }
            case "safe":
            case "finalized":
                return new l.PollingBlockTagSubscriber(this,M.type);
            case "event":
                return new l.PollingEventSubscriber(this,M.filter);
            case "transaction":
                return new l.PollingTransactionSubscriber(this,M.hash);
            case "orphan":
                return new l.PollingOrphanSubscriber(this,M.filter)
            }
            throw new Error(`unsupported event: ${M.type}`)
        }
        _recoverSubscriber(M, K) {
            for (const V of j(this, k).values())
                if (V.subscriber === M) {
                    V.started && V.subscriber.stop(),
                    V.subscriber = K,
                    V.started && K.start(),
                    j(this, O) != null && K.pause(j(this, O));
                    break
                }
        }
        async on(M, K) {
            const V = await we(this, ne, ys).call(this, M);
            return V.listeners.push({
                listener: K,
                once: !1
            }),
            V.started || (V.subscriber.start(),
            V.started = !0,
            j(this, O) != null && V.subscriber.pause(j(this, O))),
            this
        }
        async once(M, K) {
            const V = await we(this, ne, ys).call(this, M);
            return V.listeners.push({
                listener: K,
                once: !0
            }),
            V.started || (V.subscriber.start(),
            V.started = !0,
            j(this, O) != null && V.subscriber.pause(j(this, O))),
            this
        }
        async emit(M, ...K) {
            const V = await we(this, ne, ts).call(this, M, K);
            if (!V || V.listeners.length === 0)
                return !1;
            const oe = V.listeners.length;
            return V.listeners = V.listeners.filter( ({listener: me, once: Pe}) => {
                const se = new d.EventPayload(this,Pe ? null : me,M);
                try {
                    me.call(this, ...K, se)
                } catch {}
                return !Pe
            }
            ),
            V.listeners.length === 0 && (V.started && V.subscriber.stop(),
            j(this, k).delete(V.tag)),
            oe > 0
        }
        async listenerCount(M) {
            if (M) {
                const V = await we(this, ne, ts).call(this, M);
                return V ? V.listeners.length : 0
            }
            let K = 0;
            for (const {listeners: V} of j(this, k).values())
                K += V.length;
            return K
        }
        async listeners(M) {
            if (M) {
                const V = await we(this, ne, ts).call(this, M);
                return V ? V.listeners.map( ({listener: oe}) => oe) : []
            }
            let K = [];
            for (const {listeners: V} of j(this, k).values())
                K = K.concat(V.map( ({listener: oe}) => oe));
            return K
        }
        async off(M, K) {
            const V = await we(this, ne, ts).call(this, M);
            if (!V)
                return this;
            if (K) {
                const oe = V.listeners.map( ({listener: me}) => me).indexOf(K);
                oe >= 0 && V.listeners.splice(oe, 1)
            }
            return (!K || V.listeners.length === 0) && (V.started && V.subscriber.stop(),
            j(this, k).delete(V.tag)),
            this
        }
        async removeAllListeners(M) {
            if (M) {
                const {tag: K, started: V, subscriber: oe} = await we(this, ne, ys).call(this, M);
                V && oe.stop(),
                j(this, k).delete(K)
            } else
                for (const [K,{started: V, subscriber: oe}] of j(this, k))
                    V && oe.stop(),
                    j(this, k).delete(K);
            return this
        }
        async addListener(M, K) {
            return await this.on(M, K)
        }
        async removeListener(M, K) {
            return this.off(M, K)
        }
        get destroyed() {
            return j(this, L)
        }
        destroy() {
            this.removeAllListeners();
            for (const M of j(this, z).keys())
                this._clearTimeout(M);
            Q(this, L, !0)
        }
        get paused() {
            return j(this, O) != null
        }
        set paused(M) {
            !!M !== this.paused && (this.paused ? this.resume() : this.pause(!1))
        }
        pause(M) {
            if (Q(this, I, -1),
            j(this, O) != null) {
                if (j(this, O) == !!M)
                    return;
                (0,
                d.assert)(!1, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
                    operation: "pause"
                })
            }
            this._forEachSubscriber(K => K.pause(M)),
            Q(this, O, !!M);
            for (const K of j(this, z).values())
                K.timer && clearTimeout(K.timer),
                K.time = x() - K.time
        }
        resume() {
            if (j(this, O) != null) {
                this._forEachSubscriber(M => M.resume()),
                Q(this, O, null);
                for (const M of j(this, z).values()) {
                    let K = M.time;
                    K < 0 && (K = 0),
                    M.time = x(),
                    setTimeout(M.func, K)
                }
            }
        }
    }
    k = new WeakMap,
    _ = new WeakMap,
    O = new WeakMap,
    L = new WeakMap,
    U = new WeakMap,
    $ = new WeakMap,
    B = new WeakMap,
    I = new WeakMap,
    F = new WeakMap,
    z = new WeakMap,
    Y = new WeakMap,
    ie = new WeakMap,
    ne = new WeakSet,
    xt = async function(M) {
        const K = j(this, ie).cacheTimeout;
        if (K < 0)
            return await this._perform(M);
        const V = u(M.method, M);
        let oe = j(this, B).get(V);
        return oe || (oe = this._perform(M),
        j(this, B).set(V, oe),
        setTimeout( () => {
            j(this, B).get(V) === oe && j(this, B).delete(V)
        }
        , K)),
        await oe
    }
    ,
    Ai = async function(M, K, V) {
        (0,
        d.assert)(V < o, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
            reason: "TOO_MANY_REDIRECTS",
            transaction: Object.assign({}, M, {
                blockTag: K,
                enableCcipRead: !0
            })
        });
        const oe = (0,
        i.copyRequest)(M);
        try {
            return (0,
            d.hexlify)(await this._perform({
                method: "call",
                transaction: oe,
                blockTag: K
            }))
        } catch (me) {
            if (!this.disableCcipRead && (0,
            d.isCallException)(me) && me.data && V >= 0 && K === "latest" && oe.to != null && (0,
            d.dataSlice)(me.data, 0, 4) === "0x556f1830") {
                const Pe = me.data
                  , se = await (0,
                e.resolveAddress)(oe.to, this);
                let H;
                try {
                    H = y((0,
                    d.dataSlice)(me.data, 4))
                } catch (ae) {
                    (0,
                    d.assert)(!1, ae.message, "OFFCHAIN_FAULT", {
                        reason: "BAD_DATA",
                        transaction: oe,
                        info: {
                            data: Pe
                        }
                    })
                }
                (0,
                d.assert)(H.sender.toLowerCase() === se.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
                    action: "call",
                    data: Pe,
                    reason: "OffchainLookup",
                    transaction: oe,
                    invocation: null,
                    revert: {
                        signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                        name: "OffchainLookup",
                        args: H.errorArgs
                    }
                });
                const G = await this.ccipReadFetch(oe, H.calldata, H.urls);
                (0,
                d.assert)(G != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
                    reason: "FETCH_FAILED",
                    transaction: oe,
                    info: {
                        data: me.data,
                        errorArgs: H.errorArgs
                    }
                });
                const q = {
                    to: se,
                    data: (0,
                    d.concat)([H.selector, A([G, H.extraData])])
                };
                this.emit("debug", {
                    action: "sendCcipReadCall",
                    transaction: q
                });
                try {
                    const ae = await we(this, ne, Ai).call(this, q, K, V + 1);
                    return this.emit("debug", {
                        action: "receiveCcipReadCallResult",
                        transaction: Object.assign({}, q),
                        result: ae
                    }),
                    ae
                } catch (ae) {
                    throw this.emit("debug", {
                        action: "receiveCcipReadCallError",
                        transaction: Object.assign({}, q),
                        error: ae
                    }),
                    ae
                }
            }
            throw me
        }
    }
    ,
    vi = async function(M) {
        const {value: K} = await (0,
        d.resolveProperties)({
            network: this.getNetwork(),
            value: M
        });
        return K
    }
    ,
    es = async function(M, K, V) {
        let oe = this._getAddress(K)
          , me = this._getBlockTag(V);
        return (typeof oe != "string" || typeof me != "string") && ([oe,me] = await Promise.all([oe, me])),
        await we(this, ne, vi).call(this, we(this, ne, xt).call(this, Object.assign(M, {
            address: oe,
            blockTag: me
        })))
    }
    ,
    Ei = async function(M, K) {
        if ((0,
        d.isHexString)(M, 32))
            return await we(this, ne, xt).call(this, {
                method: "getBlock",
                blockHash: M,
                includeTransactions: K
            });
        let V = this._getBlockTag(M);
        return typeof V != "string" && (V = await V),
        await we(this, ne, xt).call(this, {
            method: "getBlock",
            blockTag: V,
            includeTransactions: K
        })
    }
    ,
    ts = async function(M, K) {
        let V = await b(M, this);
        return V.type === "event" && K && K.length > 0 && K[0].removed === !0 && (V = await b({
            orphan: "drop-log",
            log: K[0]
        }, this)),
        j(this, k).get(V.tag) || null
    }
    ,
    ys = async function(M) {
        const K = await b(M, this)
          , V = K.tag;
        let oe = j(this, k).get(V);
        return oe || (oe = {
            subscriber: this._getSubscriber(K),
            tag: V,
            addressableMap: new WeakMap,
            nameMap: new Map,
            started: !1,
            listeners: []
        },
        j(this, k).set(V, oe)),
        oe
    }
    ,
    mr.AbstractProvider = E;
    function w(re, M) {
        try {
            const K = S(re, M);
            if (K)
                return (0,
                d.toUtf8String)(K)
        } catch {}
        return null
    }
    function S(re, M) {
        if (re === "0x")
            return null;
        try {
            const K = (0,
            d.getNumber)((0,
            d.dataSlice)(re, M, M + 32))
              , V = (0,
            d.getNumber)((0,
            d.dataSlice)(re, K, K + 32));
            return (0,
            d.dataSlice)(re, K + 32, K + 32 + V)
        } catch {}
        return null
    }
    function T(re) {
        const M = (0,
        d.toBeArray)(re);
        if (M.length > 32)
            throw new Error("internal; should not happen");
        const K = new Uint8Array(32);
        return K.set(M, 32 - M.length),
        K
    }
    function C(re) {
        if (re.length % 32 === 0)
            return re;
        const M = new Uint8Array(Math.ceil(re.length / 32) * 32);
        return M.set(re),
        M
    }
    const N = new Uint8Array([]);
    function A(re) {
        const M = [];
        let K = 0;
        for (let V = 0; V < re.length; V++)
            M.push(N),
            K += 32;
        for (let V = 0; V < re.length; V++) {
            const oe = (0,
            d.getBytes)(re[V]);
            M[V] = T(K),
            M.push(T(oe.length)),
            M.push(C(oe)),
            K += 32 + Math.ceil(oe.length / 32) * 32
        }
        return (0,
        d.concat)(M)
    }
    const R = "0x0000000000000000000000000000000000000000000000000000000000000000";
    function y(re) {
        const M = {
            sender: "",
            urls: [],
            calldata: "",
            selector: "",
            extraData: "",
            errorArgs: []
        };
        (0,
        d.assert)((0,
        d.dataLength)(re) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
            reason: "insufficient OffchainLookup data"
        });
        const K = (0,
        d.dataSlice)(re, 0, 32);
        (0,
        d.assert)((0,
        d.dataSlice)(K, 0, 12) === (0,
        d.dataSlice)(R, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup sender"
        }),
        M.sender = (0,
        d.dataSlice)(K, 12);
        try {
            const V = []
              , oe = (0,
            d.getNumber)((0,
            d.dataSlice)(re, 32, 64))
              , me = (0,
            d.getNumber)((0,
            d.dataSlice)(re, oe, oe + 32))
              , Pe = (0,
            d.dataSlice)(re, oe + 32);
            for (let se = 0; se < me; se++) {
                const H = w(Pe, se * 32);
                if (H == null)
                    throw new Error("abort");
                V.push(H)
            }
            M.urls = V
        } catch {
            (0,
            d.assert)(!1, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
                reason: "corrupt OffchainLookup urls"
            })
        }
        try {
            const V = S(re, 64);
            if (V == null)
                throw new Error("abort");
            M.calldata = V
        } catch {
            (0,
            d.assert)(!1, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
                reason: "corrupt OffchainLookup calldata"
            })
        }
        (0,
        d.assert)((0,
        d.dataSlice)(re, 100, 128) === (0,
        d.dataSlice)(R, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
            reason: "corrupt OffchainLookup callbaackSelector"
        }),
        M.selector = (0,
        d.dataSlice)(re, 96, 100);
        try {
            const V = S(re, 128);
            if (V == null)
                throw new Error("abort");
            M.extraData = V
        } catch {
            (0,
            d.assert)(!1, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
                reason: "corrupt OffchainLookup extraData"
            })
        }
        return M.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map(V => M[V]),
        M
    }
    return mr
}
var yr = {}, cc;
function Zi() {
    var f, xs;
    if (cc)
        return yr;
    cc = 1,
    Object.defineProperty(yr, "__esModule", {
        value: !0
    }),
    yr.VoidSigner = yr.AbstractSigner = void 0;
    const e = tt()
      , t = lt()
      , s = Be()
      , r = as();
    function n(p, o) {
        if (p.provider)
            return p.provider;
        (0,
        s.assert)(!1, "missing provider", "UNSUPPORTED_OPERATION", {
            operation: o
        })
    }
    async function d(p, o) {
        let c = (0,
        r.copyRequest)(o);
        if (c.to != null && (c.to = (0,
        e.resolveAddress)(c.to, p)),
        c.from != null) {
            const u = c.from;
            c.from = Promise.all([p.getAddress(), (0,
            e.resolveAddress)(u, p)]).then( ([g,P]) => ((0,
            s.assertArgument)(g.toLowerCase() === P.toLowerCase(), "transaction from mismatch", "tx.from", P),
            g))
        } else
            c.from = p.getAddress();
        return await (0,
        s.resolveProperties)(c)
    }
    class h {
        constructor(o) {
            ue(this, "provider");
            (0,
            s.defineProperties)(this, {
                provider: o || null
            })
        }
        async getNonce(o) {
            return n(this, "getTransactionCount").getTransactionCount(await this.getAddress(), o)
        }
        async populateCall(o) {
            return await d(this, o)
        }
        async populateTransaction(o) {
            const c = n(this, "populateTransaction")
              , u = await d(this, o);
            u.nonce == null && (u.nonce = await this.getNonce("pending")),
            u.gasLimit == null && (u.gasLimit = await this.estimateGas(u));
            const g = await this.provider.getNetwork();
            if (u.chainId != null) {
                const v = (0,
                s.getBigInt)(u.chainId);
                (0,
                s.assertArgument)(v === g.chainId, "transaction chainId mismatch", "tx.chainId", o.chainId)
            } else
                u.chainId = g.chainId;
            const P = u.maxFeePerGas != null || u.maxPriorityFeePerGas != null;
            if (u.gasPrice != null && (u.type === 2 || P) ? (0,
            s.assertArgument)(!1, "eip-1559 transaction do not support gasPrice", "tx", o) : (u.type === 0 || u.type === 1) && P && (0,
            s.assertArgument)(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", o),
            (u.type === 2 || u.type == null) && u.maxFeePerGas != null && u.maxPriorityFeePerGas != null)
                u.type = 2;
            else if (u.type === 0 || u.type === 1) {
                const v = await c.getFeeData();
                (0,
                s.assert)(v.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                    operation: "getGasPrice"
                }),
                u.gasPrice == null && (u.gasPrice = v.gasPrice)
            } else {
                const v = await c.getFeeData();
                if (u.type == null)
                    if (v.maxFeePerGas != null && v.maxPriorityFeePerGas != null)
                        if (u.authorizationList && u.authorizationList.length ? u.type = 4 : u.type = 2,
                        u.gasPrice != null) {
                            const b = u.gasPrice;
                            delete u.gasPrice,
                            u.maxFeePerGas = b,
                            u.maxPriorityFeePerGas = b
                        } else
                            u.maxFeePerGas == null && (u.maxFeePerGas = v.maxFeePerGas),
                            u.maxPriorityFeePerGas == null && (u.maxPriorityFeePerGas = v.maxPriorityFeePerGas);
                    else
                        v.gasPrice != null ? ((0,
                        s.assert)(!P, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                            operation: "populateTransaction"
                        }),
                        u.gasPrice == null && (u.gasPrice = v.gasPrice),
                        u.type = 0) : (0,
                        s.assert)(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                            operation: "signer.getFeeData"
                        });
                else
                    (u.type === 2 || u.type === 3 || u.type === 4) && (u.maxFeePerGas == null && (u.maxFeePerGas = v.maxFeePerGas),
                    u.maxPriorityFeePerGas == null && (u.maxPriorityFeePerGas = v.maxPriorityFeePerGas))
            }
            return await (0,
            s.resolveProperties)(u)
        }
        async populateAuthorization(o) {
            const c = Object.assign({}, o);
            return c.chainId == null && (c.chainId = (await n(this, "getNetwork").getNetwork()).chainId),
            c.nonce == null && (c.nonce = await this.getNonce()),
            c
        }
        async estimateGas(o) {
            return n(this, "estimateGas").estimateGas(await this.populateCall(o))
        }
        async call(o) {
            return n(this, "call").call(await this.populateCall(o))
        }
        async resolveName(o) {
            return await n(this, "resolveName").resolveName(o)
        }
        async sendTransaction(o) {
            const c = n(this, "sendTransaction")
              , u = await this.populateTransaction(o);
            delete u.from;
            const g = t.Transaction.from(u);
            return await c.broadcastTransaction(await this.signTransaction(g))
        }
        authorize(o) {
            (0,
            s.assert)(!1, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", {
                operation: "authorize"
            })
        }
    }
    yr.AbstractSigner = h;
    const l = class l extends h {
        constructor(c, u) {
            super(u);
            he(this, f);
            ue(this, "address");
            (0,
            s.defineProperties)(this, {
                address: c
            })
        }
        async getAddress() {
            return this.address
        }
        connect(c) {
            return new l(this.address,c)
        }
        async signTransaction(c) {
            we(this, f, xs).call(this, "transactions", "signTransaction")
        }
        async signMessage(c) {
            we(this, f, xs).call(this, "messages", "signMessage")
        }
        async signTypedData(c, u, g) {
            we(this, f, xs).call(this, "typed-data", "signTypedData")
        }
    }
    ;
    f = new WeakSet,
    xs = function(c, u) {
        (0,
        s.assert)(!1, `VoidSigner cannot sign ${c}`, "UNSUPPORTED_OPERATION", {
            operation: u
        })
    }
    ;
    let m = l;
    return yr.VoidSigner = m,
    yr
}
var wn = {}, uc;
function Vt() {
    if (uc)
        return wn;
    uc = 1,
    Object.defineProperty(wn, "__esModule", {
        value: !0
    }),
    wn.showThrottleMessage = void 0;
    const e = new Set;
    function t(s) {
        e.has(s) || (e.add(s),
        console.log("========= NOTICE ========="),
        console.log(`Request-Rate Exceeded for ${s} (this message will not be repeated)`),
        console.log(""),
        console.log("The default API keys for each service are provided as a highly-throttled,"),
        console.log("community resource for low-traffic projects and early prototyping."),
        console.log(""),
        console.log("While your application will continue to function, we highly recommended"),
        console.log("signing up for your own API keys to improve performance, increase your"),
        console.log("request rate/limit and enable other perks, such as metrics and advanced APIs."),
        console.log(""),
        console.log("For more details: https://docs.ethers.org/api-keys/"),
        console.log("=========================="))
    }
    return wn.showThrottleMessage = t,
    wn
}
var An = {}, vn = {}, kt = {}, Dt = {}, lc;
function mf() {
    var h, m, f, i, l, p, o, Pi, ki, g;
    if (lc)
        return Dt;
    lc = 1,
    Object.defineProperty(Dt, "__esModule", {
        value: !0
    }),
    Dt.FilterIdPendingSubscriber = Dt.FilterIdEventSubscriber = Dt.FilterIdSubscriber = void 0;
    const e = Be()
      , t = Yi();
    function s(P) {
        return JSON.parse(JSON.stringify(P))
    }
    class r {
        constructor(v) {
            he(this, o);
            he(this, h);
            he(this, m);
            he(this, f);
            he(this, i);
            he(this, l);
            he(this, p);
            Q(this, h, v),
            Q(this, m, null),
            Q(this, f, we(this, o, Pi).bind(this)),
            Q(this, i, !1),
            Q(this, l, null),
            Q(this, p, !1)
        }
        _subscribe(v) {
            throw new Error("subclasses must override this")
        }
        _emitResults(v, b) {
            throw new Error("subclasses must override this")
        }
        _recover(v) {
            throw new Error("subclasses must override this")
        }
        start() {
            j(this, i) || (Q(this, i, !0),
            we(this, o, Pi).call(this, -2))
        }
        stop() {
            j(this, i) && (Q(this, i, !1),
            Q(this, p, !0),
            we(this, o, ki).call(this),
            j(this, h).off("block", j(this, f)))
        }
        pause(v) {
            v && we(this, o, ki).call(this),
            j(this, h).off("block", j(this, f))
        }
        resume() {
            this.start()
        }
    }
    h = new WeakMap,
    m = new WeakMap,
    f = new WeakMap,
    i = new WeakMap,
    l = new WeakMap,
    p = new WeakMap,
    o = new WeakSet,
    Pi = async function(v) {
        try {
            j(this, m) == null && Q(this, m, this._subscribe(j(this, h)));
            let b = null;
            try {
                b = await j(this, m)
            } catch (E) {
                if (!(0,
                e.isError)(E, "UNSUPPORTED_OPERATION") || E.operation !== "eth_newFilter")
                    throw E
            }
            if (b == null) {
                Q(this, m, null),
                j(this, h)._recoverSubscriber(this, this._recover(j(this, h)));
                return
            }
            const x = await j(this, h).getNetwork();
            if (j(this, l) || Q(this, l, x),
            j(this, l).chainId !== x.chainId)
                throw new Error("chaid changed");
            if (j(this, p))
                return;
            const a = await j(this, h).send("eth_getFilterChanges", [b]);
            await this._emitResults(j(this, h), a)
        } catch (b) {
            console.log("@TODO", b)
        }
        j(this, h).once("block", j(this, f))
    }
    ,
    ki = function() {
        const v = j(this, m);
        v && (Q(this, m, null),
        v.then(b => {
            j(this, h).destroyed || j(this, h).send("eth_uninstallFilter", [b])
        }
        ))
    }
    ,
    Dt.FilterIdSubscriber = r;
    class n extends r {
        constructor(b, x) {
            super(b);
            he(this, g);
            Q(this, g, s(x))
        }
        _recover(b) {
            return new t.PollingEventSubscriber(b,j(this, g))
        }
        async _subscribe(b) {
            return await b.send("eth_newFilter", [j(this, g)])
        }
        async _emitResults(b, x) {
            for (const a of x)
                b.emit(j(this, g), b._wrapLog(a, b._network))
        }
    }
    g = new WeakMap,
    Dt.FilterIdEventSubscriber = n;
    class d extends r {
        async _subscribe(v) {
            return await v.send("eth_newPendingTransactionFilter", [])
        }
        async _emitResults(v, b) {
            for (const x of b)
                v.emit("pending", x)
        }
    }
    return Dt.FilterIdPendingSubscriber = d,
    Dt
}
var dc;
function wt() {
    var S, T, C, N, A, R, y, k, _i, O, L;
    if (dc)
        return kt;
    dc = 1,
    Object.defineProperty(kt, "__esModule", {
        value: !0
    }),
    kt.JsonRpcProvider = kt.JsonRpcApiPollingProvider = kt.JsonRpcApiProvider = kt.JsonRpcSigner = void 0;
    const e = os()
      , t = tt()
      , s = qt()
      , r = lt()
      , n = Be()
      , d = cs()
      , h = Zi()
      , m = dt()
      , f = mf()
      , i = Yi()
      , l = "bigint,boolean,function,number,string,symbol".split(/,/g);
    function p(U) {
        if (U == null || l.indexOf(typeof U) >= 0 || typeof U.getAddress == "function")
            return U;
        if (Array.isArray(U))
            return U.map(p);
        if (typeof U == "object")
            return Object.keys(U).reduce( ($, B) => ($[B] = U[B],
            $), {});
        throw new Error(`should not happen: ${U} (${typeof U})`)
    }
    function o(U) {
        return new Promise($ => {
            setTimeout($, U)
        }
        )
    }
    function c(U) {
        return U && U.toLowerCase()
    }
    function u(U) {
        return U && typeof U.pollingInterval == "number"
    }
    const g = {
        polling: !1,
        staticNetwork: null,
        batchStallTime: 10,
        batchMaxSize: 1 << 20,
        batchMaxCount: 100,
        cacheTimeout: 250,
        pollingInterval: 4e3
    };
    class P extends h.AbstractSigner {
        constructor(B, I) {
            super(B);
            ue(this, "address");
            I = (0,
            t.getAddress)(I),
            (0,
            n.defineProperties)(this, {
                address: I
            })
        }
        connect(B) {
            (0,
            n.assert)(!1, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
                operation: "signer.connect"
            })
        }
        async getAddress() {
            return this.address
        }
        async populateTransaction(B) {
            return await this.populateCall(B)
        }
        async sendUncheckedTransaction(B) {
            const I = p(B)
              , F = [];
            if (I.from) {
                const Y = I.from;
                F.push((async () => {
                    const ie = await (0,
                    t.resolveAddress)(Y, this.provider);
                    (0,
                    n.assertArgument)(ie != null && ie.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", B),
                    I.from = ie
                }
                )())
            } else
                I.from = this.address;
            if (I.gasLimit == null && F.push((async () => {
                I.gasLimit = await this.provider.estimateGas({
                    ...I,
                    from: this.address
                })
            }
            )()),
            I.to != null) {
                const Y = I.to;
                F.push((async () => {
                    I.to = await (0,
                    t.resolveAddress)(Y, this.provider)
                }
                )())
            }
            F.length && await Promise.all(F);
            const z = this.provider.getRpcTransaction(I);
            return this.provider.send("eth_sendTransaction", [z])
        }
        async sendTransaction(B) {
            const I = await this.provider.getBlockNumber()
              , F = await this.sendUncheckedTransaction(B);
            return await new Promise( (z, Y) => {
                const ie = [1e3, 100];
                let ne = 0;
                const xe = async () => {
                    try {
                        const W = await this.provider.getTransaction(F);
                        if (W != null) {
                            z(W.replaceableTransaction(I));
                            return
                        }
                    } catch (W) {
                        if ((0,
                        n.isError)(W, "CANCELLED") || (0,
                        n.isError)(W, "BAD_DATA") || (0,
                        n.isError)(W, "NETWORK_ERROR") || (0,
                        n.isError)(W, "UNSUPPORTED_OPERATION")) {
                            W.info == null && (W.info = {}),
                            W.info.sendTransactionHash = F,
                            Y(W);
                            return
                        }
                        if ((0,
                        n.isError)(W, "INVALID_ARGUMENT") && (ne++,
                        W.info == null && (W.info = {}),
                        W.info.sendTransactionHash = F,
                        ne > 10)) {
                            Y(W);
                            return
                        }
                        this.provider.emit("error", (0,
                        n.makeError)("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", {
                            error: W
                        }))
                    }
                    this.provider._setTimeout( () => {
                        xe()
                    }
                    , ie.pop() || 4e3)
                }
                ;
                xe()
            }
            )
        }
        async signTransaction(B) {
            const I = p(B);
            if (I.from) {
                const z = await (0,
                t.resolveAddress)(I.from, this.provider);
                (0,
                n.assertArgument)(z != null && z.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", B),
                I.from = z
            } else
                I.from = this.address;
            const F = this.provider.getRpcTransaction(I);
            return await this.provider.send("eth_signTransaction", [F])
        }
        async signMessage(B) {
            const I = typeof B == "string" ? (0,
            n.toUtf8Bytes)(B) : B;
            return await this.provider.send("personal_sign", [(0,
            n.hexlify)(I), this.address.toLowerCase()])
        }
        async signTypedData(B, I, F) {
            const z = p(F)
              , Y = await s.TypedDataEncoder.resolveNames(B, I, z, async ie => {
                const ne = await (0,
                t.resolveAddress)(ie);
                return (0,
                n.assertArgument)(ne != null, "TypedData does not support null address", "value", ie),
                ne
            }
            );
            return await this.provider.send("eth_signTypedData_v4", [this.address.toLowerCase(), JSON.stringify(s.TypedDataEncoder.getPayload(Y.domain, I, Y.value))])
        }
        async unlock(B) {
            return this.provider.send("personal_unlockAccount", [this.address.toLowerCase(), B, null])
        }
        async _legacySignMessage(B) {
            const I = typeof B == "string" ? (0,
            n.toUtf8Bytes)(B) : B;
            return await this.provider.send("eth_sign", [this.address.toLowerCase(), (0,
            n.hexlify)(I)])
        }
    }
    kt.JsonRpcSigner = P;
    class v extends d.AbstractProvider {
        constructor(B, I) {
            super(B, I);
            he(this, k);
            he(this, S);
            he(this, T);
            he(this, C);
            he(this, N);
            he(this, A);
            he(this, R);
            he(this, y);
            Q(this, T, 1),
            Q(this, S, Object.assign({}, g, I || {})),
            Q(this, C, []),
            Q(this, N, null),
            Q(this, R, null),
            Q(this, y, null);
            {
                let z = null;
                const Y = new Promise(ie => {
                    z = ie
                }
                );
                Q(this, A, {
                    promise: Y,
                    resolve: z
                })
            }
            const F = this._getOption("staticNetwork");
            typeof F == "boolean" ? ((0,
            n.assertArgument)(!F || B !== "any", "staticNetwork cannot be used on special network 'any'", "options", I),
            F && B != null && Q(this, R, m.Network.from(B))) : F && ((0,
            n.assertArgument)(B == null || F.matches(B), "staticNetwork MUST match network object", "options", I),
            Q(this, R, F))
        }
        _getOption(B) {
            return j(this, S)[B]
        }
        get _network() {
            return (0,
            n.assert)(j(this, R), "network is not available yet", "NETWORK_ERROR"),
            j(this, R)
        }
        async _perform(B) {
            if (B.method === "call" || B.method === "estimateGas") {
                let F = B.transaction;
                if (F && F.type != null && (0,
                n.getBigInt)(F.type) && F.maxFeePerGas == null && F.maxPriorityFeePerGas == null) {
                    const z = await this.getFeeData();
                    z.maxFeePerGas == null && z.maxPriorityFeePerGas == null && (B = Object.assign({}, B, {
                        transaction: Object.assign({}, F, {
                            type: void 0
                        })
                    }))
                }
            }
            const I = this.getRpcRequest(B);
            return I != null ? await this.send(I.method, I.args) : super._perform(B)
        }
        async _detectNetwork() {
            const B = this._getOption("staticNetwork");
            if (B)
                if (B === !0) {
                    if (j(this, R))
                        return j(this, R)
                } else
                    return B;
            return j(this, y) ? await j(this, y) : this.ready ? (Q(this, y, (async () => {
                try {
                    const I = m.Network.from((0,
                    n.getBigInt)(await this.send("eth_chainId", [])));
                    return Q(this, y, null),
                    I
                } catch (I) {
                    throw Q(this, y, null),
                    I
                }
            }
            )()),
            await j(this, y)) : (Q(this, y, (async () => {
                const I = {
                    id: Br(this, T)._++,
                    method: "eth_chainId",
                    params: [],
                    jsonrpc: "2.0"
                };
                this.emit("debug", {
                    action: "sendRpcPayload",
                    payload: I
                });
                let F;
                try {
                    F = (await this._send(I))[0],
                    Q(this, y, null)
                } catch (z) {
                    throw Q(this, y, null),
                    this.emit("debug", {
                        action: "receiveRpcError",
                        error: z
                    }),
                    z
                }
                if (this.emit("debug", {
                    action: "receiveRpcResult",
                    result: F
                }),
                "result"in F)
                    return m.Network.from((0,
                    n.getBigInt)(F.result));
                throw this.getRpcError(I, F)
            }
            )()),
            await j(this, y))
        }
        _start() {
            j(this, A) == null || j(this, A).resolve == null || (j(this, A).resolve(),
            Q(this, A, null),
            (async () => {
                for (; j(this, R) == null && !this.destroyed; )
                    try {
                        Q(this, R, await this._detectNetwork())
                    } catch (B) {
                        if (this.destroyed)
                            break;
                        console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"),
                        this.emit("error", (0,
                        n.makeError)("failed to bootstrap network detection", "NETWORK_ERROR", {
                            event: "initial-network-discovery",
                            info: {
                                error: B
                            }
                        })),
                        await o(1e3)
                    }
                we(this, k, _i).call(this)
            }
            )())
        }
        async _waitUntilReady() {
            if (j(this, A) != null)
                return await j(this, A).promise
        }
        _getSubscriber(B) {
            return B.type === "pending" ? new f.FilterIdPendingSubscriber(this) : B.type === "event" ? this._getOption("polling") ? new i.PollingEventSubscriber(this,B.filter) : new f.FilterIdEventSubscriber(this,B.filter) : B.type === "orphan" && B.filter.orphan === "drop-log" ? new d.UnmanagedSubscriber("orphan") : super._getSubscriber(B)
        }
        get ready() {
            return j(this, A) == null
        }
        getRpcTransaction(B) {
            const I = {};
            return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(F => {
                if (B[F] == null)
                    return;
                let z = F;
                F === "gasLimit" && (z = "gas"),
                I[z] = (0,
                n.toQuantity)((0,
                n.getBigInt)(B[F], `tx.${F}`))
            }
            ),
            ["from", "to", "data"].forEach(F => {
                B[F] != null && (I[F] = (0,
                n.hexlify)(B[F]))
            }
            ),
            B.accessList && (I.accessList = (0,
            r.accessListify)(B.accessList)),
            B.blobVersionedHashes && (I.blobVersionedHashes = B.blobVersionedHashes.map(F => F.toLowerCase())),
            B.authorizationList && (I.authorizationList = B.authorizationList.map(F => {
                const z = (0,
                r.authorizationify)(F);
                return {
                    address: z.address,
                    nonce: (0,
                    n.toQuantity)(z.nonce),
                    chainId: (0,
                    n.toQuantity)(z.chainId),
                    yParity: (0,
                    n.toQuantity)(z.signature.yParity),
                    r: (0,
                    n.toQuantity)(z.signature.r),
                    s: (0,
                    n.toQuantity)(z.signature.s)
                }
            }
            )),
            I
        }
        getRpcRequest(B) {
            switch (B.method) {
            case "chainId":
                return {
                    method: "eth_chainId",
                    args: []
                };
            case "getBlockNumber":
                return {
                    method: "eth_blockNumber",
                    args: []
                };
            case "getGasPrice":
                return {
                    method: "eth_gasPrice",
                    args: []
                };
            case "getPriorityFee":
                return {
                    method: "eth_maxPriorityFeePerGas",
                    args: []
                };
            case "getBalance":
                return {
                    method: "eth_getBalance",
                    args: [c(B.address), B.blockTag]
                };
            case "getTransactionCount":
                return {
                    method: "eth_getTransactionCount",
                    args: [c(B.address), B.blockTag]
                };
            case "getCode":
                return {
                    method: "eth_getCode",
                    args: [c(B.address), B.blockTag]
                };
            case "getStorage":
                return {
                    method: "eth_getStorageAt",
                    args: [c(B.address), "0x" + B.position.toString(16), B.blockTag]
                };
            case "broadcastTransaction":
                return {
                    method: "eth_sendRawTransaction",
                    args: [B.signedTransaction]
                };
            case "getBlock":
                if ("blockTag"in B)
                    return {
                        method: "eth_getBlockByNumber",
                        args: [B.blockTag, !!B.includeTransactions]
                    };
                if ("blockHash"in B)
                    return {
                        method: "eth_getBlockByHash",
                        args: [B.blockHash, !!B.includeTransactions]
                    };
                break;
            case "getTransaction":
                return {
                    method: "eth_getTransactionByHash",
                    args: [B.hash]
                };
            case "getTransactionReceipt":
                return {
                    method: "eth_getTransactionReceipt",
                    args: [B.hash]
                };
            case "call":
                return {
                    method: "eth_call",
                    args: [this.getRpcTransaction(B.transaction), B.blockTag]
                };
            case "estimateGas":
                return {
                    method: "eth_estimateGas",
                    args: [this.getRpcTransaction(B.transaction)]
                };
            case "getLogs":
                return B.filter && B.filter.address != null && (Array.isArray(B.filter.address) ? B.filter.address = B.filter.address.map(c) : B.filter.address = c(B.filter.address)),
                {
                    method: "eth_getLogs",
                    args: [B.filter]
                }
            }
            return null
        }
        getRpcError(B, I) {
            const {method: F} = B
              , {error: z} = I;
            if (F === "eth_estimateGas" && z.message) {
                const ne = z.message;
                if (!ne.match(/revert/i) && ne.match(/insufficient funds/i))
                    return (0,
                    n.makeError)("insufficient funds", "INSUFFICIENT_FUNDS", {
                        transaction: B.params[0],
                        info: {
                            payload: B,
                            error: z
                        }
                    });
                if (ne.match(/nonce/i) && ne.match(/too low/i))
                    return (0,
                    n.makeError)("nonce has already been used", "NONCE_EXPIRED", {
                        transaction: B.params[0],
                        info: {
                            payload: B,
                            error: z
                        }
                    })
            }
            if (F === "eth_call" || F === "eth_estimateGas") {
                const ne = a(z)
                  , xe = e.AbiCoder.getBuiltinCallException(F === "eth_call" ? "call" : "estimateGas", B.params[0], ne ? ne.data : null);
                return xe.info = {
                    error: z,
                    payload: B
                },
                xe
            }
            const Y = JSON.stringify(w(z));
            if (typeof z.message == "string" && z.message.match(/user denied|ethers-user-denied/i)) {
                const ne = {
                    eth_sign: "signMessage",
                    personal_sign: "signMessage",
                    eth_signTypedData_v4: "signTypedData",
                    eth_signTransaction: "signTransaction",
                    eth_sendTransaction: "sendTransaction",
                    eth_requestAccounts: "requestAccess",
                    wallet_requestAccounts: "requestAccess"
                };
                return (0,
                n.makeError)("user rejected action", "ACTION_REJECTED", {
                    action: ne[F] || "unknown",
                    reason: "rejected",
                    info: {
                        payload: B,
                        error: z
                    }
                })
            }
            if (F === "eth_sendRawTransaction" || F === "eth_sendTransaction") {
                const ne = B.params[0];
                if (Y.match(/insufficient funds|base fee exceeds gas limit/i))
                    return (0,
                    n.makeError)("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                        transaction: ne,
                        info: {
                            error: z
                        }
                    });
                if (Y.match(/nonce/i) && Y.match(/too low/i))
                    return (0,
                    n.makeError)("nonce has already been used", "NONCE_EXPIRED", {
                        transaction: ne,
                        info: {
                            error: z
                        }
                    });
                if (Y.match(/replacement transaction/i) && Y.match(/underpriced/i))
                    return (0,
                    n.makeError)("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                        transaction: ne,
                        info: {
                            error: z
                        }
                    });
                if (Y.match(/only replay-protected/i))
                    return (0,
                    n.makeError)("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
                        operation: F,
                        info: {
                            transaction: ne,
                            info: {
                                error: z
                            }
                        }
                    })
            }
            let ie = !!Y.match(/the method .* does not exist/i);
            return ie || z && z.details && z.details.startsWith("Unauthorized method:") && (ie = !0),
            ie ? (0,
            n.makeError)("unsupported operation", "UNSUPPORTED_OPERATION", {
                operation: B.method,
                info: {
                    error: z,
                    payload: B
                }
            }) : (0,
            n.makeError)("could not coalesce error", "UNKNOWN_ERROR", {
                error: z,
                payload: B
            })
        }
        send(B, I) {
            if (this.destroyed)
                return Promise.reject((0,
                n.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                    operation: B
                }));
            const F = Br(this, T)._++
              , z = new Promise( (Y, ie) => {
                j(this, C).push({
                    resolve: Y,
                    reject: ie,
                    payload: {
                        method: B,
                        params: I,
                        id: F,
                        jsonrpc: "2.0"
                    }
                })
            }
            );
            return we(this, k, _i).call(this),
            z
        }
        async getSigner(B) {
            B == null && (B = 0);
            const I = this.send("eth_accounts", []);
            if (typeof B == "number") {
                const z = await I;
                if (B >= z.length)
                    throw new Error("no such account");
                return new P(this,z[B])
            }
            const {accounts: F} = await (0,
            n.resolveProperties)({
                network: this.getNetwork(),
                accounts: I
            });
            B = (0,
            t.getAddress)(B);
            for (const z of F)
                if ((0,
                t.getAddress)(z) === B)
                    return new P(this,B);
            throw new Error("invalid account")
        }
        async listAccounts() {
            return (await this.send("eth_accounts", [])).map(I => new P(this,I))
        }
        destroy() {
            j(this, N) && (clearTimeout(j(this, N)),
            Q(this, N, null));
            for (const {payload: B, reject: I} of j(this, C))
                I((0,
                n.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                    operation: B.method
                }));
            Q(this, C, []),
            super.destroy()
        }
    }
    S = new WeakMap,
    T = new WeakMap,
    C = new WeakMap,
    N = new WeakMap,
    A = new WeakMap,
    R = new WeakMap,
    y = new WeakMap,
    k = new WeakSet,
    _i = function() {
        if (j(this, N))
            return;
        const B = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
        Q(this, N, setTimeout( () => {
            Q(this, N, null);
            const I = j(this, C);
            for (Q(this, C, []); I.length; ) {
                const F = [I.shift()];
                for (; I.length && F.length !== j(this, S).batchMaxCount; )
                    if (F.push(I.shift()),
                    JSON.stringify(F.map(Y => Y.payload)).length > j(this, S).batchMaxSize) {
                        I.unshift(F.pop());
                        break
                    }
                (async () => {
                    const z = F.length === 1 ? F[0].payload : F.map(Y => Y.payload);
                    this.emit("debug", {
                        action: "sendRpcPayload",
                        payload: z
                    });
                    try {
                        const Y = await this._send(z);
                        this.emit("debug", {
                            action: "receiveRpcResult",
                            result: Y
                        });
                        for (const {resolve: ie, reject: ne, payload: xe} of F) {
                            if (this.destroyed) {
                                ne((0,
                                n.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                                    operation: xe.method
                                }));
                                continue
                            }
                            const W = Y.filter(ee => ee.id === xe.id)[0];
                            if (W == null) {
                                const ee = (0,
                                n.makeError)("missing response for request", "BAD_DATA", {
                                    value: Y,
                                    info: {
                                        payload: xe
                                    }
                                });
                                this.emit("error", ee),
                                ne(ee);
                                continue
                            }
                            if ("error"in W) {
                                ne(this.getRpcError(xe, W));
                                continue
                            }
                            ie(W.result)
                        }
                    } catch (Y) {
                        this.emit("debug", {
                            action: "receiveRpcError",
                            error: Y
                        });
                        for (const {reject: ie} of F)
                            ie(Y)
                    }
                }
                )()
            }
        }
        , B))
    }
    ,
    kt.JsonRpcApiProvider = v;
    class b extends v {
        constructor(B, I) {
            super(B, I);
            he(this, O);
            let F = this._getOption("pollingInterval");
            F == null && (F = g.pollingInterval),
            Q(this, O, F)
        }
        _getSubscriber(B) {
            const I = super._getSubscriber(B);
            return u(I) && (I.pollingInterval = j(this, O)),
            I
        }
        get pollingInterval() {
            return j(this, O)
        }
        set pollingInterval(B) {
            if (!Number.isInteger(B) || B < 0)
                throw new Error("invalid interval");
            Q(this, O, B),
            this._forEachSubscriber(I => {
                u(I) && (I.pollingInterval = j(this, O))
            }
            )
        }
    }
    O = new WeakMap,
    kt.JsonRpcApiPollingProvider = b;
    class x extends b {
        constructor(B, I, F) {
            B == null && (B = "http://localhost:8545");
            super(I, F);
            he(this, L);
            typeof B == "string" ? Q(this, L, new n.FetchRequest(B)) : Q(this, L, B.clone())
        }
        _getConnection() {
            return j(this, L).clone()
        }
        async send(B, I) {
            return await this._start(),
            await super.send(B, I)
        }
        async _send(B) {
            const I = this._getConnection();
            I.body = JSON.stringify(B),
            I.setHeader("content-type", "application/json");
            const F = await I.send();
            F.assertOk();
            let z = F.bodyJson;
            return Array.isArray(z) || (z = [z]),
            z
        }
    }
    L = new WeakMap,
    kt.JsonRpcProvider = x;
    function a(U) {
        if (U == null)
            return null;
        if (typeof U.message == "string" && U.message.match(/revert/i) && (0,
        n.isHexString)(U.data))
            return {
                message: U.message,
                data: U.data
            };
        if (typeof U == "object") {
            for (const $ in U) {
                const B = a(U[$]);
                if (B)
                    return B
            }
            return null
        }
        if (typeof U == "string")
            try {
                return a(JSON.parse(U))
            } catch {}
        return null
    }
    function E(U, $) {
        if (U != null) {
            if (typeof U.message == "string" && $.push(U.message),
            typeof U == "object")
                for (const B in U)
                    E(U[B], $);
            if (typeof U == "string")
                try {
                    return E(JSON.parse(U), $)
                } catch {}
        }
    }
    function w(U) {
        const $ = [];
        return E(U, $),
        $
    }
    return kt
}
var fc;
function il() {
    if (fc)
        return vn;
    fc = 1,
    Object.defineProperty(vn, "__esModule", {
        value: !0
    }),
    vn.AnkrProvider = void 0;
    const e = Be()
      , t = Vt()
      , s = dt()
      , r = wt()
      , n = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
    function d(m) {
        switch (m) {
        case "mainnet":
            return "rpc.ankr.com/eth";
        case "goerli":
            return "rpc.ankr.com/eth_goerli";
        case "sepolia":
            return "rpc.ankr.com/eth_sepolia";
        case "arbitrum":
            return "rpc.ankr.com/arbitrum";
        case "base":
            return "rpc.ankr.com/base";
        case "base-goerli":
            return "rpc.ankr.com/base_goerli";
        case "base-sepolia":
            return "rpc.ankr.com/base_sepolia";
        case "bnb":
            return "rpc.ankr.com/bsc";
        case "bnbt":
            return "rpc.ankr.com/bsc_testnet_chapel";
        case "matic":
            return "rpc.ankr.com/polygon";
        case "matic-mumbai":
            return "rpc.ankr.com/polygon_mumbai";
        case "optimism":
            return "rpc.ankr.com/optimism";
        case "optimism-goerli":
            return "rpc.ankr.com/optimism_testnet";
        case "optimism-sepolia":
            return "rpc.ankr.com/optimism_sepolia"
        }
        (0,
        e.assertArgument)(!1, "unsupported network", "network", m)
    }
    class h extends r.JsonRpcProvider {
        constructor(i, l) {
            i == null && (i = "mainnet");
            const p = s.Network.from(i);
            l == null && (l = n);
            const o = {
                polling: !0,
                staticNetwork: p
            }
              , c = h.getRequest(p, l);
            super(c, p, o);
            ue(this, "apiKey");
            (0,
            e.defineProperties)(this, {
                apiKey: l
            })
        }
        _getProvider(i) {
            try {
                return new h(i,this.apiKey)
            } catch {}
            return super._getProvider(i)
        }
        static getRequest(i, l) {
            l == null && (l = n);
            const p = new e.FetchRequest(`https://${d(i.name)}/${l}`);
            return p.allowGzip = !0,
            l === n && (p.retryFunc = async (o, c, u) => ((0,
            t.showThrottleMessage)("AnkrProvider"),
            !0)),
            p
        }
        getRpcError(i, l) {
            return i.method === "eth_sendRawTransaction" && l && l.error && l.error.message === "INTERNAL_ERROR: could not replace existing tx" && (l.error.message = "replacement transaction underpriced"),
            super.getRpcError(i, l)
        }
        isCommunityResource() {
            return this.apiKey === n
        }
    }
    return vn.AnkrProvider = h,
    vn
}
var En = {}, hc;
function ol() {
    if (hc)
        return En;
    hc = 1,
    Object.defineProperty(En, "__esModule", {
        value: !0
    }),
    En.AlchemyProvider = void 0;
    const e = Be()
      , t = Vt()
      , s = dt()
      , r = wt()
      , n = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
    function d(m) {
        switch (m) {
        case "mainnet":
            return "eth-mainnet.alchemyapi.io";
        case "goerli":
            return "eth-goerli.g.alchemy.com";
        case "sepolia":
            return "eth-sepolia.g.alchemy.com";
        case "arbitrum":
            return "arb-mainnet.g.alchemy.com";
        case "arbitrum-goerli":
            return "arb-goerli.g.alchemy.com";
        case "arbitrum-sepolia":
            return "arb-sepolia.g.alchemy.com";
        case "base":
            return "base-mainnet.g.alchemy.com";
        case "base-goerli":
            return "base-goerli.g.alchemy.com";
        case "base-sepolia":
            return "base-sepolia.g.alchemy.com";
        case "matic":
            return "polygon-mainnet.g.alchemy.com";
        case "matic-amoy":
            return "polygon-amoy.g.alchemy.com";
        case "matic-mumbai":
            return "polygon-mumbai.g.alchemy.com";
        case "optimism":
            return "opt-mainnet.g.alchemy.com";
        case "optimism-goerli":
            return "opt-goerli.g.alchemy.com";
        case "optimism-sepolia":
            return "opt-sepolia.g.alchemy.com"
        }
        (0,
        e.assertArgument)(!1, "unsupported network", "network", m)
    }
    class h extends r.JsonRpcProvider {
        constructor(i, l) {
            i == null && (i = "mainnet");
            const p = s.Network.from(i);
            l == null && (l = n);
            const o = h.getRequest(p, l);
            super(o, p, {
                staticNetwork: p
            });
            ue(this, "apiKey");
            (0,
            e.defineProperties)(this, {
                apiKey: l
            })
        }
        _getProvider(i) {
            try {
                return new h(i,this.apiKey)
            } catch {}
            return super._getProvider(i)
        }
        async _perform(i) {
            if (i.method === "getTransactionResult") {
                const {trace: l, tx: p} = await (0,
                e.resolveProperties)({
                    trace: this.send("trace_transaction", [i.hash]),
                    tx: this.getTransaction(i.hash)
                });
                if (l == null || p == null)
                    return null;
                let o, c = !1;
                try {
                    o = l[0].result.output,
                    c = l[0].error === "Reverted"
                } catch {}
                if (o)
                    return (0,
                    e.assert)(!c, "an error occurred during transaction executions", "CALL_EXCEPTION", {
                        action: "getTransactionResult",
                        data: o,
                        reason: null,
                        transaction: p,
                        invocation: null,
                        revert: null
                    }),
                    o;
                (0,
                e.assert)(!1, "could not parse trace result", "BAD_DATA", {
                    value: l
                })
            }
            return await super._perform(i)
        }
        isCommunityResource() {
            return this.apiKey === n
        }
        static getRequest(i, l) {
            l == null && (l = n);
            const p = new e.FetchRequest(`https://${d(i.name)}/v2/${l}`);
            return p.allowGzip = !0,
            l === n && (p.retryFunc = async (o, c, u) => ((0,
            t.showThrottleMessage)("alchemy"),
            !0)),
            p
        }
    }
    return En.AlchemyProvider = h,
    En
}
var Pn = {}, pc;
function al() {
    if (pc)
        return Pn;
    pc = 1,
    Object.defineProperty(Pn, "__esModule", {
        value: !0
    }),
    Pn.ChainstackProvider = void 0;
    const e = Be()
      , t = Vt()
      , s = dt()
      , r = wt();
    function n(m) {
        switch (m) {
        case "mainnet":
            return "39f1d67cedf8b7831010a665328c9197";
        case "arbitrum":
            return "0550c209db33c3abf4cc927e1e18cea1";
        case "bnb":
            return "98b5a77e531614387366f6fc5da097f8";
        case "matic":
            return "cd9d4d70377471aa7c142ec4a4205249"
        }
        (0,
        e.assertArgument)(!1, "unsupported network", "network", m)
    }
    function d(m) {
        switch (m) {
        case "mainnet":
            return "ethereum-mainnet.core.chainstack.com";
        case "arbitrum":
            return "arbitrum-mainnet.core.chainstack.com";
        case "bnb":
            return "bsc-mainnet.core.chainstack.com";
        case "matic":
            return "polygon-mainnet.core.chainstack.com"
        }
        (0,
        e.assertArgument)(!1, "unsupported network", "network", m)
    }
    class h extends r.JsonRpcProvider {
        constructor(i, l) {
            i == null && (i = "mainnet");
            const p = s.Network.from(i);
            l == null && (l = n(p.name));
            const o = h.getRequest(p, l);
            super(o, p, {
                staticNetwork: p
            });
            ue(this, "apiKey");
            (0,
            e.defineProperties)(this, {
                apiKey: l
            })
        }
        _getProvider(i) {
            try {
                return new h(i,this.apiKey)
            } catch {}
            return super._getProvider(i)
        }
        isCommunityResource() {
            return this.apiKey === n(this._network.name)
        }
        static getRequest(i, l) {
            l == null && (l = n(i.name));
            const p = new e.FetchRequest(`https://${d(i.name)}/${l}`);
            return p.allowGzip = !0,
            l === n(i.name) && (p.retryFunc = async (o, c, u) => ((0,
            t.showThrottleMessage)("ChainstackProvider"),
            !0)),
            p
        }
    }
    return Pn.ChainstackProvider = h,
    Pn
}
var kn = {}, bc;
function cl() {
    if (bc)
        return kn;
    bc = 1,
    Object.defineProperty(kn, "__esModule", {
        value: !0
    }),
    kn.CloudflareProvider = void 0;
    const e = Be()
      , t = dt()
      , s = wt();
    class r extends s.JsonRpcProvider {
        constructor(d) {
            d == null && (d = "mainnet");
            const h = t.Network.from(d);
            (0,
            e.assertArgument)(h.name === "mainnet", "unsupported network", "network", d),
            super("https://cloudflare-eth.com/", h, {
                staticNetwork: h
            })
        }
    }
    return kn.CloudflareProvider = r,
    kn
}
var xr = {}, gc;
function ul() {
    var g;
    if (gc)
        return xr;
    gc = 1,
    Object.defineProperty(xr, "__esModule", {
        value: !0
    }),
    xr.EtherscanProvider = xr.EtherscanPlugin = void 0;
    const e = os()
      , t = Cs()
      , s = lt()
      , r = Be()
      , n = cs()
      , d = dt()
      , h = Wi()
      , m = Vt()
      , f = 2e3;
    function i(P) {
        return P && typeof P.then == "function"
    }
    const l = "org.ethers.plugins.provider.Etherscan";
    class p extends h.NetworkPlugin {
        constructor(b) {
            super(l);
            ue(this, "baseUrl");
            (0,
            r.defineProperties)(this, {
                baseUrl: b
            })
        }
        clone() {
            return new p(this.baseUrl)
        }
    }
    xr.EtherscanPlugin = p;
    const o = ["enableCcipRead"];
    let c = 1;
    class u extends n.AbstractProvider {
        constructor(b, x) {
            const a = x ?? null;
            super();
            ue(this, "network");
            ue(this, "apiKey");
            he(this, g);
            const E = d.Network.from(b);
            Q(this, g, E.getPlugin(l)),
            (0,
            r.defineProperties)(this, {
                apiKey: a,
                network: E
            })
        }
        getBaseUrl() {
            if (j(this, g))
                return j(this, g).baseUrl;
            switch (this.network.name) {
            case "mainnet":
                return "https://api.etherscan.io";
            case "goerli":
                return "https://api-goerli.etherscan.io";
            case "sepolia":
                return "https://api-sepolia.etherscan.io";
            case "holesky":
                return "https://api-holesky.etherscan.io";
            case "arbitrum":
                return "https://api.arbiscan.io";
            case "arbitrum-goerli":
                return "https://api-goerli.arbiscan.io";
            case "base":
                return "https://api.basescan.org";
            case "base-sepolia":
                return "https://api-sepolia.basescan.org";
            case "bnb":
                return "https://api.bscscan.com";
            case "bnbt":
                return "https://api-testnet.bscscan.com";
            case "matic":
                return "https://api.polygonscan.com";
            case "matic-amoy":
                return "https://api-amoy.polygonscan.com";
            case "matic-mumbai":
                return "https://api-testnet.polygonscan.com";
            case "optimism":
                return "https://api-optimistic.etherscan.io";
            case "optimism-goerli":
                return "https://api-goerli-optimistic.etherscan.io"
            }
            (0,
            r.assertArgument)(!1, "unsupported network", "network", this.network)
        }
        getUrl(b, x) {
            let a = Object.keys(x).reduce( (E, w) => {
                const S = x[w];
                return S != null && (E += `&${w}=${S}`),
                E
            }
            , "");
            return this.apiKey && (a += `&apikey=${this.apiKey}`),
            `https://api.etherscan.io/v2/api?chainid=${this.network.chainId}&module=${b}${a}`
        }
        getPostUrl() {
            return `https://api.etherscan.io/v2/api?chainid=${this.network.chainId}`
        }
        getPostData(b, x) {
            return x.module = b,
            x.apikey = this.apiKey,
            x.chainid = this.network.chainId,
            x
        }
        async detectNetwork() {
            return this.network
        }
        async fetch(b, x, a) {
            const E = c++
              , w = a ? this.getPostUrl() : this.getUrl(b, x)
              , S = a ? this.getPostData(b, x) : null;
            this.emit("debug", {
                action: "sendRequest",
                id: E,
                url: w,
                payload: S
            });
            const T = new r.FetchRequest(w);
            T.setThrottleParams({
                slotInterval: 1e3
            }),
            T.retryFunc = (A, R, y) => (this.isCommunityResource() && (0,
            m.showThrottleMessage)("Etherscan"),
            Promise.resolve(!0)),
            T.processFunc = async (A, R) => {
                const y = R.hasBody() ? JSON.parse((0,
                r.toUtf8String)(R.body)) : {}
                  , k = (typeof y.result == "string" ? y.result : "").toLowerCase().indexOf("rate limit") >= 0;
                return b === "proxy" ? y && y.status == 0 && y.message == "NOTOK" && k && (this.emit("debug", {
                    action: "receiveError",
                    id: E,
                    reason: "proxy-NOTOK",
                    error: y
                }),
                R.throwThrottleError(y.result, f)) : k && (this.emit("debug", {
                    action: "receiveError",
                    id: E,
                    reason: "null result",
                    error: y.result
                }),
                R.throwThrottleError(y.result, f)),
                R
            }
            ,
            S && (T.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8"),
            T.body = Object.keys(S).map(A => `${A}=${S[A]}`).join("&"));
            const C = await T.send();
            try {
                C.assertOk()
            } catch (A) {
                this.emit("debug", {
                    action: "receiveError",
                    id: E,
                    error: A,
                    reason: "assertOk"
                }),
                (0,
                r.assert)(!1, "response error", "SERVER_ERROR", {
                    request: T,
                    response: C
                })
            }
            C.hasBody() || (this.emit("debug", {
                action: "receiveError",
                id: E,
                error: "missing body",
                reason: "null body"
            }),
            (0,
            r.assert)(!1, "missing response", "SERVER_ERROR", {
                request: T,
                response: C
            }));
            const N = JSON.parse((0,
            r.toUtf8String)(C.body));
            return b === "proxy" ? (N.jsonrpc != "2.0" && (this.emit("debug", {
                action: "receiveError",
                id: E,
                result: N,
                reason: "invalid JSON-RPC"
            }),
            (0,
            r.assert)(!1, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", {
                request: T,
                response: C,
                info: {
                    result: N
                }
            })),
            N.error && (this.emit("debug", {
                action: "receiveError",
                id: E,
                result: N,
                reason: "JSON-RPC error"
            }),
            (0,
            r.assert)(!1, "error response", "SERVER_ERROR", {
                request: T,
                response: C,
                info: {
                    result: N
                }
            })),
            this.emit("debug", {
                action: "receiveRequest",
                id: E,
                result: N
            }),
            N.result) : N.status == 0 && (N.message === "No records found" || N.message === "No transactions found") ? (this.emit("debug", {
                action: "receiveRequest",
                id: E,
                result: N
            }),
            N.result) : ((N.status != 1 || typeof N.message == "string" && !N.message.match(/^OK/)) && (this.emit("debug", {
                action: "receiveError",
                id: E,
                result: N
            }),
            (0,
            r.assert)(!1, "error response", "SERVER_ERROR", {
                request: T,
                response: C,
                info: {
                    result: N
                }
            })),
            this.emit("debug", {
                action: "receiveRequest",
                id: E,
                result: N
            }),
            N.result)
        }
        _getTransactionPostData(b) {
            const x = {};
            for (let a in b) {
                if (o.indexOf(a) >= 0 || b[a] == null)
                    continue;
                let E = b[a];
                if (!(a === "type" && E === 0) && !(a === "blockTag" && E === "latest")) {
                    if ({
                        type: !0,
                        gasLimit: !0,
                        gasPrice: !0,
                        maxFeePerGs: !0,
                        maxPriorityFeePerGas: !0,
                        nonce: !0,
                        value: !0
                    }[a])
                        E = (0,
                        r.toQuantity)(E);
                    else if (a === "accessList")
                        E = "[" + (0,
                        s.accessListify)(E).map(w => `{address:"${w.address}",storageKeys:["${w.storageKeys.join('","')}"]}`).join(",") + "]";
                    else if (a === "blobVersionedHashes") {
                        if (E.length === 0)
                            continue;
                        (0,
                        r.assert)(!1, "Etherscan API does not support blobVersionedHashes", "UNSUPPORTED_OPERATION", {
                            operation: "_getTransactionPostData",
                            info: {
                                transaction: b
                            }
                        })
                    } else
                        E = (0,
                        r.hexlify)(E);
                    x[a] = E
                }
            }
            return x
        }
        _checkError(b, x, a) {
            let E = "";
            if ((0,
            r.isError)(x, "SERVER_ERROR")) {
                try {
                    E = x.info.result.error.message
                } catch {}
                if (!E)
                    try {
                        E = x.info.message
                    } catch {}
            }
            if (b.method === "estimateGas" && !E.match(/revert/i) && E.match(/insufficient funds/i) && (0,
            r.assert)(!1, "insufficient funds", "INSUFFICIENT_FUNDS", {
                transaction: b.transaction
            }),
            (b.method === "call" || b.method === "estimateGas") && E.match(/execution reverted/i)) {
                let w = "";
                try {
                    w = x.info.result.error.data
                } catch {}
                const S = e.AbiCoder.getBuiltinCallException(b.method, b.transaction, w);
                throw S.info = {
                    request: b,
                    error: x
                },
                S
            }
            if (E && b.method === "broadcastTransaction") {
                const w = s.Transaction.from(b.signedTransaction);
                E.match(/replacement/i) && E.match(/underpriced/i) && (0,
                r.assert)(!1, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                    transaction: w
                }),
                E.match(/insufficient funds/) && (0,
                r.assert)(!1, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                    transaction: w
                }),
                E.match(/same hash was already imported|transaction nonce is too low|nonce too low/) && (0,
                r.assert)(!1, "nonce has already been used", "NONCE_EXPIRED", {
                    transaction: w
                })
            }
            throw x
        }
        async _detectNetwork() {
            return this.network
        }
        async _perform(b) {
            switch (b.method) {
            case "chainId":
                return this.network.chainId;
            case "getBlockNumber":
                return this.fetch("proxy", {
                    action: "eth_blockNumber"
                });
            case "getGasPrice":
                return this.fetch("proxy", {
                    action: "eth_gasPrice"
                });
            case "getPriorityFee":
                if (this.network.name === "mainnet")
                    return "1000000000";
                if (this.network.name === "optimism")
                    return "1000000";
                throw new Error("fallback onto the AbstractProvider default");
            case "getBalance":
                return this.fetch("account", {
                    action: "balance",
                    address: b.address,
                    tag: b.blockTag
                });
            case "getTransactionCount":
                return this.fetch("proxy", {
                    action: "eth_getTransactionCount",
                    address: b.address,
                    tag: b.blockTag
                });
            case "getCode":
                return this.fetch("proxy", {
                    action: "eth_getCode",
                    address: b.address,
                    tag: b.blockTag
                });
            case "getStorage":
                return this.fetch("proxy", {
                    action: "eth_getStorageAt",
                    address: b.address,
                    position: b.position,
                    tag: b.blockTag
                });
            case "broadcastTransaction":
                return this.fetch("proxy", {
                    action: "eth_sendRawTransaction",
                    hex: b.signedTransaction
                }, !0).catch(x => this._checkError(b, x, b.signedTransaction));
            case "getBlock":
                if ("blockTag"in b)
                    return this.fetch("proxy", {
                        action: "eth_getBlockByNumber",
                        tag: b.blockTag,
                        boolean: b.includeTransactions ? "true" : "false"
                    });
                (0,
                r.assert)(!1, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
                    operation: "getBlock(blockHash)"
                });
            case "getTransaction":
                return this.fetch("proxy", {
                    action: "eth_getTransactionByHash",
                    txhash: b.hash
                });
            case "getTransactionReceipt":
                return this.fetch("proxy", {
                    action: "eth_getTransactionReceipt",
                    txhash: b.hash
                });
            case "call":
                {
                    if (b.blockTag !== "latest")
                        throw new Error("EtherscanProvider does not support blockTag for call");
                    const x = this._getTransactionPostData(b.transaction);
                    x.module = "proxy",
                    x.action = "eth_call";
                    try {
                        return await this.fetch("proxy", x, !0)
                    } catch (a) {
                        return this._checkError(b, a, b.transaction)
                    }
                }
            case "estimateGas":
                {
                    const x = this._getTransactionPostData(b.transaction);
                    x.module = "proxy",
                    x.action = "eth_estimateGas";
                    try {
                        return await this.fetch("proxy", x, !0)
                    } catch (a) {
                        return this._checkError(b, a, b.transaction)
                    }
                }
            }
            return super._perform(b)
        }
        async getNetwork() {
            return this.network
        }
        async getEtherPrice() {
            return this.network.name !== "mainnet" ? 0 : parseFloat((await this.fetch("stats", {
                action: "ethprice"
            })).ethusd)
        }
        async getContract(b) {
            let x = this._getAddress(b);
            i(x) && (x = await x);
            try {
                const a = await this.fetch("contract", {
                    action: "getabi",
                    address: x
                })
                  , E = JSON.parse(a);
                return new t.Contract(x,E,this)
            } catch {
                return null
            }
        }
        isCommunityResource() {
            return this.apiKey == null
        }
    }
    return g = new WeakMap,
    xr.EtherscanProvider = u,
    xr
}
var wr = {}, _n = {}, Tn = {}, mc;
function yf() {
    if (mc)
        return Tn;
    mc = 1,
    Object.defineProperty(Tn, "__esModule", {
        value: !0
    }),
    Tn.WebSocket = void 0;
    function e() {
        if (typeof self < "u")
            return self;
        if (typeof window < "u")
            return window;
        if (typeof He < "u")
            return He;
        throw new Error("unable to locate global object")
    }
    const t = e().WebSocket;
    return Tn.WebSocket = t,
    Tn
}
var mt = {}, yc;
function Ti() {
    var f, i, l, p, o, c, u, g, P;
    if (yc)
        return mt;
    yc = 1,
    Object.defineProperty(mt, "__esModule", {
        value: !0
    }),
    mt.SocketProvider = mt.SocketEventSubscriber = mt.SocketPendingSubscriber = mt.SocketBlockSubscriber = mt.SocketSubscriber = void 0;
    const e = cs()
      , t = Be()
      , s = wt();
    class r {
        constructor(b, x) {
            he(this, f);
            he(this, i);
            he(this, l);
            he(this, p);
            he(this, o);
            Q(this, f, b),
            Q(this, i, JSON.stringify(x)),
            Q(this, l, null),
            Q(this, p, null),
            Q(this, o, null)
        }
        get filter() {
            return JSON.parse(j(this, i))
        }
        start() {
            Q(this, l, j(this, f).send("eth_subscribe", this.filter).then(b => (j(this, f)._register(b, this),
            b)))
        }
        stop() {
            j(this, l).then(b => {
                j(this, f).destroyed || j(this, f).send("eth_unsubscribe", [b])
            }
            ),
            Q(this, l, null)
        }
        pause(b) {
            (0,
            t.assert)(b, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", {
                operation: "pause(false)"
            }),
            Q(this, p, !!b)
        }
        resume() {
            Q(this, p, null)
        }
        _handleMessage(b) {
            if (j(this, l) != null && j(this, p) === null) {
                let x = j(this, o);
                x == null ? x = this._emit(j(this, f), b) : x = x.then(async () => {
                    await this._emit(j(this, f), b)
                }
                ),
                Q(this, o, x.then( () => {
                    j(this, o) === x && Q(this, o, null)
                }
                ))
            }
        }
        async _emit(b, x) {
            throw new Error("sub-classes must implemente this; _emit")
        }
    }
    f = new WeakMap,
    i = new WeakMap,
    l = new WeakMap,
    p = new WeakMap,
    o = new WeakMap,
    mt.SocketSubscriber = r;
    class n extends r {
        constructor(b) {
            super(b, ["newHeads"])
        }
        async _emit(b, x) {
            b.emit("block", parseInt(x.number))
        }
    }
    mt.SocketBlockSubscriber = n;
    class d extends r {
        constructor(b) {
            super(b, ["newPendingTransactions"])
        }
        async _emit(b, x) {
            b.emit("pending", x)
        }
    }
    mt.SocketPendingSubscriber = d;
    class h extends r {
        constructor(x, a) {
            super(x, ["logs", a]);
            he(this, c);
            Q(this, c, JSON.stringify(a))
        }
        get logFilter() {
            return JSON.parse(j(this, c))
        }
        async _emit(x, a) {
            x.emit(this.logFilter, x._wrapLog(a, x._network))
        }
    }
    c = new WeakMap,
    mt.SocketEventSubscriber = h;
    class m extends s.JsonRpcApiProvider {
        constructor(x, a) {
            const E = Object.assign({}, a ?? {});
            (0,
            t.assertArgument)(E.batchMaxCount == null || E.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", a),
            E.batchMaxCount = 1,
            E.staticNetwork == null && (E.staticNetwork = !0);
            super(x, E);
            he(this, u);
            he(this, g);
            he(this, P);
            Q(this, u, new Map),
            Q(this, g, new Map),
            Q(this, P, new Map)
        }
        _getSubscriber(x) {
            switch (x.type) {
            case "close":
                return new e.UnmanagedSubscriber("close");
            case "block":
                return new n(this);
            case "pending":
                return new d(this);
            case "event":
                return new h(this,x.filter);
            case "orphan":
                if (x.filter.orphan === "drop-log")
                    return new e.UnmanagedSubscriber("drop-log")
            }
            return super._getSubscriber(x)
        }
        _register(x, a) {
            j(this, g).set(x, a);
            const E = j(this, P).get(x);
            if (E) {
                for (const w of E)
                    a._handleMessage(w);
                j(this, P).delete(x)
            }
        }
        async _send(x) {
            (0,
            t.assertArgument)(!Array.isArray(x), "WebSocket does not support batch send", "payload", x);
            const a = new Promise( (E, w) => {
                j(this, u).set(x.id, {
                    payload: x,
                    resolve: E,
                    reject: w
                })
            }
            );
            return await this._waitUntilReady(),
            await this._write(JSON.stringify(x)),
            [await a]
        }
        async _processMessage(x) {
            const a = JSON.parse(x);
            if (a && typeof a == "object" && "id"in a) {
                const E = j(this, u).get(a.id);
                if (E == null) {
                    this.emit("error", (0,
                    t.makeError)("received result for unknown id", "UNKNOWN_ERROR", {
                        reasonCode: "UNKNOWN_ID",
                        result: a
                    }));
                    return
                }
                j(this, u).delete(a.id),
                E.resolve(a)
            } else if (a && a.method === "eth_subscription") {
                const E = a.params.subscription
                  , w = j(this, g).get(E);
                if (w)
                    w._handleMessage(a.params.result);
                else {
                    let S = j(this, P).get(E);
                    S == null && (S = [],
                    j(this, P).set(E, S)),
                    S.push(a.params.result)
                }
            } else {
                this.emit("error", (0,
                t.makeError)("received unexpected message", "UNKNOWN_ERROR", {
                    reasonCode: "UNEXPECTED_MESSAGE",
                    result: a
                }));
                return
            }
        }
        async _write(x) {
            throw new Error("sub-classes must override this")
        }
    }
    return u = new WeakMap,
    g = new WeakMap,
    P = new WeakMap,
    mt.SocketProvider = m,
    mt
}
var xc;
function Xi() {
    var r, n;
    if (xc)
        return _n;
    xc = 1,
    Object.defineProperty(_n, "__esModule", {
        value: !0
    }),
    _n.WebSocketProvider = void 0;
    const e = yf()
      , t = Ti();
    class s extends t.SocketProvider {
        constructor(m, f, i) {
            super(f, i);
            he(this, r);
            he(this, n);
            typeof m == "string" ? (Q(this, r, () => new e.WebSocket(m)),
            Q(this, n, j(this, r).call(this))) : typeof m == "function" ? (Q(this, r, m),
            Q(this, n, m())) : (Q(this, r, null),
            Q(this, n, m)),
            this.websocket.onopen = async () => {
                try {
                    await this._start(),
                    this.resume()
                } catch (l) {
                    console.log("failed to start WebsocketProvider", l)
                }
            }
            ,
            this.websocket.onmessage = l => {
                this._processMessage(l.data)
            }
        }
        get websocket() {
            if (j(this, n) == null)
                throw new Error("websocket closed");
            return j(this, n)
        }
        async _write(m) {
            this.websocket.send(m)
        }
        async destroy() {
            j(this, n) != null && (j(this, n).close(),
            Q(this, n, null)),
            super.destroy()
        }
    }
    return r = new WeakMap,
    n = new WeakMap,
    _n.WebSocketProvider = s,
    _n
}
var wc;
function ll() {
    if (wc)
        return wr;
    wc = 1,
    Object.defineProperty(wr, "__esModule", {
        value: !0
    }),
    wr.InfuraProvider = wr.InfuraWebSocketProvider = void 0;
    const e = Be()
      , t = Vt()
      , s = dt()
      , r = wt()
      , n = Xi()
      , d = "84842078b09946638c03157f83405213";
    function h(i) {
        switch (i) {
        case "mainnet":
            return "mainnet.infura.io";
        case "goerli":
            return "goerli.infura.io";
        case "sepolia":
            return "sepolia.infura.io";
        case "arbitrum":
            return "arbitrum-mainnet.infura.io";
        case "arbitrum-goerli":
            return "arbitrum-goerli.infura.io";
        case "arbitrum-sepolia":
            return "arbitrum-sepolia.infura.io";
        case "base":
            return "base-mainnet.infura.io";
        case "base-goerlia":
        case "base-goerli":
            return "base-goerli.infura.io";
        case "base-sepolia":
            return "base-sepolia.infura.io";
        case "bnb":
            return "bsc-mainnet.infura.io";
        case "bnbt":
            return "bsc-testnet.infura.io";
        case "linea":
            return "linea-mainnet.infura.io";
        case "linea-goerli":
            return "linea-goerli.infura.io";
        case "linea-sepolia":
            return "linea-sepolia.infura.io";
        case "matic":
            return "polygon-mainnet.infura.io";
        case "matic-amoy":
            return "polygon-amoy.infura.io";
        case "matic-mumbai":
            return "polygon-mumbai.infura.io";
        case "optimism":
            return "optimism-mainnet.infura.io";
        case "optimism-goerli":
            return "optimism-goerli.infura.io";
        case "optimism-sepolia":
            return "optimism-sepolia.infura.io"
        }
        (0,
        e.assertArgument)(!1, "unsupported network", "network", i)
    }
    class m extends n.WebSocketProvider {
        constructor(p, o) {
            const c = new f(p,o)
              , u = c._getConnection();
            (0,
            e.assert)(!u.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", {
                operation: "InfuraProvider.getWebSocketProvider()"
            });
            const g = u.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
            super(g, c._network);
            ue(this, "projectId");
            ue(this, "projectSecret");
            (0,
            e.defineProperties)(this, {
                projectId: c.projectId,
                projectSecret: c.projectSecret
            })
        }
        isCommunityResource() {
            return this.projectId === d
        }
    }
    wr.InfuraWebSocketProvider = m;
    class f extends r.JsonRpcProvider {
        constructor(p, o, c) {
            p == null && (p = "mainnet");
            const u = s.Network.from(p);
            o == null && (o = d),
            c == null && (c = null);
            const g = f.getRequest(u, o, c);
            super(g, u, {
                staticNetwork: u
            });
            ue(this, "projectId");
            ue(this, "projectSecret");
            (0,
            e.defineProperties)(this, {
                projectId: o,
                projectSecret: c
            })
        }
        _getProvider(p) {
            try {
                return new f(p,this.projectId,this.projectSecret)
            } catch {}
            return super._getProvider(p)
        }
        isCommunityResource() {
            return this.projectId === d
        }
        static getWebSocketProvider(p, o) {
            return new m(p,o)
        }
        static getRequest(p, o, c) {
            o == null && (o = d),
            c == null && (c = null);
            const u = new e.FetchRequest(`https://${h(p.name)}/v3/${o}`);
            return u.allowGzip = !0,
            c && u.setCredentials("", c),
            o === d && (u.retryFunc = async (g, P, v) => ((0,
            t.showThrottleMessage)("InfuraProvider"),
            !0)),
            u
        }
    }
    return wr.InfuraProvider = f,
    wr
}
var On = {}, Ac;
function dl() {
    if (Ac)
        return On;
    Ac = 1,
    Object.defineProperty(On, "__esModule", {
        value: !0
    }),
    On.QuickNodeProvider = void 0;
    const e = Be()
      , t = Vt()
      , s = dt()
      , r = wt()
      , n = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
    function d(m) {
        switch (m) {
        case "mainnet":
            return "ethers.quiknode.pro";
        case "goerli":
            return "ethers.ethereum-goerli.quiknode.pro";
        case "sepolia":
            return "ethers.ethereum-sepolia.quiknode.pro";
        case "holesky":
            return "ethers.ethereum-holesky.quiknode.pro";
        case "arbitrum":
            return "ethers.arbitrum-mainnet.quiknode.pro";
        case "arbitrum-goerli":
            return "ethers.arbitrum-goerli.quiknode.pro";
        case "arbitrum-sepolia":
            return "ethers.arbitrum-sepolia.quiknode.pro";
        case "base":
            return "ethers.base-mainnet.quiknode.pro";
        case "base-goerli":
            return "ethers.base-goerli.quiknode.pro";
        case "base-spolia":
            return "ethers.base-sepolia.quiknode.pro";
        case "bnb":
            return "ethers.bsc.quiknode.pro";
        case "bnbt":
            return "ethers.bsc-testnet.quiknode.pro";
        case "matic":
            return "ethers.matic.quiknode.pro";
        case "matic-mumbai":
            return "ethers.matic-testnet.quiknode.pro";
        case "optimism":
            return "ethers.optimism.quiknode.pro";
        case "optimism-goerli":
            return "ethers.optimism-goerli.quiknode.pro";
        case "optimism-sepolia":
            return "ethers.optimism-sepolia.quiknode.pro";
        case "xdai":
            return "ethers.xdai.quiknode.pro"
        }
        (0,
        e.assertArgument)(!1, "unsupported network", "network", m)
    }
    class h extends r.JsonRpcProvider {
        constructor(i, l) {
            i == null && (i = "mainnet");
            const p = s.Network.from(i);
            l == null && (l = n);
            const o = h.getRequest(p, l);
            super(o, p, {
                staticNetwork: p
            });
            ue(this, "token");
            (0,
            e.defineProperties)(this, {
                token: l
            })
        }
        _getProvider(i) {
            try {
                return new h(i,this.token)
            } catch {}
            return super._getProvider(i)
        }
        isCommunityResource() {
            return this.token === n
        }
        static getRequest(i, l) {
            l == null && (l = n);
            const p = new e.FetchRequest(`https://${d(i.name)}/${l}`);
            return p.allowGzip = !0,
            l === n && (p.retryFunc = async (o, c, u) => ((0,
            t.showThrottleMessage)("QuickNodeProvider"),
            !0)),
            p
        }
    }
    return On.QuickNodeProvider = h,
    On
}
var Bn = {}, vc;
function bl() {
    var x, a, E, w, fl, Oi, hl, pl, Bi;
    if (vc)
        return Bn;
    vc = 1,
    Object.defineProperty(Bn, "__esModule", {
        value: !0
    }),
    Bn.FallbackProvider = void 0;
    const e = Be()
      , t = cs()
      , s = dt()
      , r = BigInt("1")
      , n = BigInt("2");
    function d(R) {
        for (let y = R.length - 1; y > 0; y--) {
            const k = Math.floor(Math.random() * (y + 1))
              , _ = R[y];
            R[y] = R[k],
            R[k] = _
        }
    }
    function h(R) {
        return new Promise(y => {
            setTimeout(y, R)
        }
        )
    }
    function m() {
        return new Date().getTime()
    }
    function f(R) {
        return JSON.stringify(R, (y, k) => typeof k == "bigint" ? {
            type: "bigint",
            value: k.toString()
        } : k)
    }
    const i = {
        stallTimeout: 400,
        priority: 1,
        weight: 1
    }
      , l = {
        blockNumber: -2,
        requests: 0,
        lateResponses: 0,
        errorResponses: 0,
        outOfSync: -1,
        unsupportedEvents: 0,
        rollingDuration: 0,
        score: 0,
        _network: null,
        _updateNumber: null,
        _totalTime: 0,
        _lastFatalError: null,
        _lastFatalErrorTimestamp: 0
    };
    async function p(R, y) {
        for (; (R.blockNumber < 0 || R.blockNumber < y) && (R._updateNumber || (R._updateNumber = (async () => {
            try {
                const k = await R.provider.getBlockNumber();
                k > R.blockNumber && (R.blockNumber = k)
            } catch (k) {
                R.blockNumber = -2,
                R._lastFatalError = k,
                R._lastFatalErrorTimestamp = m()
            }
            R._updateNumber = null
        }
        )()),
        await R._updateNumber,
        R.outOfSync++,
        !R._lastFatalError); )
            ;
    }
    function o(R) {
        if (R == null)
            return "null";
        if (Array.isArray(R))
            return "[" + R.map(o).join(",") + "]";
        if (typeof R == "object" && typeof R.toJSON == "function")
            return o(R.toJSON());
        switch (typeof R) {
        case "boolean":
        case "symbol":
            return R.toString();
        case "bigint":
        case "number":
            return BigInt(R).toString();
        case "string":
            return JSON.stringify(R);
        case "object":
            {
                const y = Object.keys(R);
                return y.sort(),
                "{" + y.map(k => `${JSON.stringify(k)}:${o(R[k])}`).join(",") + "}"
            }
        }
        throw console.log("Could not serialize", R),
        new Error("Hmm...")
    }
    function c(R, y) {
        if ("error"in y) {
            const _ = y.error;
            let O;
            return (0,
            e.isError)(_, "CALL_EXCEPTION") ? O = o(Object.assign({}, _, {
                shortMessage: void 0,
                reason: void 0,
                info: void 0
            })) : O = o(_),
            {
                tag: O,
                value: _
            }
        }
        const k = y.result;
        return {
            tag: o(k),
            value: k
        }
    }
    function u(R, y) {
        const k = new Map;
        for (const {value: O, tag: L, weight: U} of y) {
            const $ = k.get(L) || {
                value: O,
                weight: 0
            };
            $.weight += U,
            k.set(L, $)
        }
        let _ = null;
        for (const O of k.values())
            O.weight >= R && (!_ || O.weight > _.weight) && (_ = O);
        if (_)
            return _.value
    }
    function g(R, y) {
        let k = 0;
        const _ = new Map;
        let O = null;
        const L = [];
        for (const {value: $, tag: B, weight: I} of y)
            if ($ instanceof Error) {
                const F = _.get(B) || {
                    value: $,
                    weight: 0
                };
                F.weight += I,
                _.set(B, F),
                (O == null || F.weight > O.weight) && (O = F)
            } else
                L.push(BigInt($)),
                k += I;
        if (k < R)
            return O && O.weight >= R ? O.value : void 0;
        L.sort( ($, B) => $ < B ? -1 : B > $ ? 1 : 0);
        const U = Math.floor(L.length / 2);
        return L.length % 2 ? L[U] : (L[U - 1] + L[U] + r) / n
    }
    function P(R, y) {
        const k = u(R, y);
        if (k !== void 0)
            return k;
        for (const _ of y)
            if (_.value)
                return _.value
    }
    function v(R, y) {
        if (R === 1)
            return (0,
            e.getNumber)(g(R, y), "%internal");
        const k = new Map
          , _ = (U, $) => {
            const B = k.get(U) || {
                result: U,
                weight: 0
            };
            B.weight += $,
            k.set(U, B)
        }
        ;
        for (const {weight: U, value: $} of y) {
            const B = (0,
            e.getNumber)($);
            _(B - 1, U),
            _(B, U),
            _(B + 1, U)
        }
        let O = 0, L;
        for (const {weight: U, result: $} of k.values())
            U >= R && (U > O || L != null && U === O && $ > L) && (O = U,
            L = $);
        return L
    }
    class b extends t.AbstractProvider {
        constructor(k, _, O) {
            super(_, O);
            he(this, w);
            ue(this, "quorum");
            ue(this, "eventQuorum");
            ue(this, "eventWorkers");
            he(this, x);
            he(this, a);
            he(this, E);
            Q(this, x, k.map(L => L instanceof t.AbstractProvider ? Object.assign({
                provider: L
            }, i, l) : Object.assign({}, i, L, l))),
            Q(this, a, -2),
            Q(this, E, null),
            O && O.quorum != null ? this.quorum = O.quorum : this.quorum = Math.ceil(j(this, x).reduce( (L, U) => (L += U.weight,
            L), 0) / 2),
            this.eventQuorum = 1,
            this.eventWorkers = 1,
            (0,
            e.assertArgument)(this.quorum <= j(this, x).reduce( (L, U) => L + U.weight, 0), "quorum exceed provider weight", "quorum", this.quorum)
        }
        get providerConfigs() {
            return j(this, x).map(k => {
                const _ = Object.assign({}, k);
                for (const O in _)
                    O[0] === "_" && delete _[O];
                return _
            }
            )
        }
        async _detectNetwork() {
            return s.Network.from((0,
            e.getBigInt)(await this._perform({
                method: "chainId"
            })))
        }
        async _translatePerform(k, _) {
            switch (_.method) {
            case "broadcastTransaction":
                return await k.broadcastTransaction(_.signedTransaction);
            case "call":
                return await k.call(Object.assign({}, _.transaction, {
                    blockTag: _.blockTag
                }));
            case "chainId":
                return (await k.getNetwork()).chainId;
            case "estimateGas":
                return await k.estimateGas(_.transaction);
            case "getBalance":
                return await k.getBalance(_.address, _.blockTag);
            case "getBlock":
                {
                    const O = "blockHash"in _ ? _.blockHash : _.blockTag;
                    return await k.getBlock(O, _.includeTransactions)
                }
            case "getBlockNumber":
                return await k.getBlockNumber();
            case "getCode":
                return await k.getCode(_.address, _.blockTag);
            case "getGasPrice":
                return (await k.getFeeData()).gasPrice;
            case "getPriorityFee":
                return (await k.getFeeData()).maxPriorityFeePerGas;
            case "getLogs":
                return await k.getLogs(_.filter);
            case "getStorage":
                return await k.getStorage(_.address, _.position, _.blockTag);
            case "getTransaction":
                return await k.getTransaction(_.hash);
            case "getTransactionCount":
                return await k.getTransactionCount(_.address, _.blockTag);
            case "getTransactionReceipt":
                return await k.getTransactionReceipt(_.hash);
            case "getTransactionResult":
                return await k.getTransactionResult(_.hash)
            }
        }
        async _perform(k) {
            if (k.method === "broadcastTransaction") {
                const U = j(this, x).map(I => null)
                  , $ = j(this, x).map(async ({provider: I, weight: F}, z) => {
                    try {
                        const Y = await I._perform(k);
                        U[z] = Object.assign(c(k.method, {
                            result: Y
                        }), {
                            weight: F
                        })
                    } catch (Y) {
                        U[z] = Object.assign(c(k.method, {
                            error: Y
                        }), {
                            weight: F
                        })
                    }
                }
                );
                for (; ; ) {
                    const I = U.filter(Y => Y != null);
                    for (const {value: Y} of I)
                        if (!(Y instanceof Error))
                            return Y;
                    const F = u(this.quorum, U.filter(Y => Y != null));
                    if ((0,
                    e.isError)(F, "INSUFFICIENT_FUNDS"))
                        throw F;
                    const z = $.filter( (Y, ie) => U[ie] == null);
                    if (z.length === 0)
                        break;
                    await Promise.race(z)
                }
                const B = P(this.quorum, U);
                if ((0,
                e.assert)(B !== void 0, "problem multi-broadcasting", "SERVER_ERROR", {
                    request: "%sub-requests",
                    info: {
                        request: k,
                        results: U.map(f)
                    }
                }),
                B instanceof Error)
                    throw B;
                return B
            }
            await we(this, w, hl).call(this);
            const _ = new Set;
            let O = 0;
            for (; ; ) {
                const U = we(this, w, Oi).call(this, _, k);
                if (U == null || (O += U.config.weight,
                O >= this.quorum))
                    break
            }
            const L = await we(this, w, Bi).call(this, _, k);
            for (const U of _)
                U.perform && U.result == null && U.config.lateResponses++;
            return L
        }
        async destroy() {
            for (const {provider: k} of j(this, x))
                k.destroy();
            super.destroy()
        }
    }
    return x = new WeakMap,
    a = new WeakMap,
    E = new WeakMap,
    w = new WeakSet,
    fl = function(k) {
        const _ = Array.from(k).map(L => L.config)
          , O = j(this, x).slice();
        d(O),
        O.sort( (L, U) => L.priority - U.priority);
        for (const L of O)
            if (!L._lastFatalError && _.indexOf(L) === -1)
                return L;
        return null
    }
    ,
    Oi = function(k, _) {
        const O = we(this, w, fl).call(this, k);
        if (O == null)
            return null;
        const L = {
            config: O,
            result: null,
            didBump: !1,
            perform: null,
            staller: null
        }
          , U = m();
        return L.perform = (async () => {
            try {
                O.requests++;
                const B = await this._translatePerform(O.provider, _);
                L.result = {
                    result: B
                }
            } catch (B) {
                O.errorResponses++,
                L.result = {
                    error: B
                }
            }
            const $ = m() - U;
            O._totalTime += $,
            O.rollingDuration = .95 * O.rollingDuration + .05 * $,
            L.perform = null
        }
        )(),
        L.staller = (async () => {
            await h(O.stallTimeout),
            L.staller = null
        }
        )(),
        k.add(L),
        L
    }
    ,
    hl = async function() {
        let k = j(this, E);
        if (!k) {
            const _ = [];
            j(this, x).forEach(O => {
                _.push((async () => {
                    await p(O, 0),
                    O._lastFatalError || (O._network = await O.provider.getNetwork())
                }
                )())
            }
            ),
            Q(this, E, k = (async () => {
                await Promise.all(_);
                let O = null;
                for (const L of j(this, x)) {
                    if (L._lastFatalError)
                        continue;
                    const U = L._network;
                    O == null ? O = U.chainId : U.chainId !== O && (0,
                    e.assert)(!1, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
                        operation: "new FallbackProvider"
                    })
                }
            }
            )())
        }
        await k
    }
    ,
    pl = async function(k, _) {
        const O = [];
        for (const L of k)
            if (L.result != null) {
                const {tag: U, value: $} = c(_.method, L.result);
                O.push({
                    tag: U,
                    value: $,
                    weight: L.config.weight
                })
            }
        if (!(O.reduce( (L, U) => L + U.weight, 0) < this.quorum)) {
            switch (_.method) {
            case "getBlockNumber":
                {
                    j(this, a) === -2 && Q(this, a, Math.ceil((0,
                    e.getNumber)(g(this.quorum, j(this, x).filter(U => !U._lastFatalError).map(U => ({
                        value: U.blockNumber,
                        tag: (0,
                        e.getNumber)(U.blockNumber).toString(),
                        weight: U.weight
                    }))))));
                    const L = v(this.quorum, O);
                    return L === void 0 ? void 0 : (L > j(this, a) && Q(this, a, L),
                    j(this, a))
                }
            case "getGasPrice":
            case "getPriorityFee":
            case "estimateGas":
                return g(this.quorum, O);
            case "getBlock":
                return "blockTag"in _ && _.blockTag === "pending" ? P(this.quorum, O) : u(this.quorum, O);
            case "call":
            case "chainId":
            case "getBalance":
            case "getTransactionCount":
            case "getCode":
            case "getStorage":
            case "getTransaction":
            case "getTransactionReceipt":
            case "getLogs":
                return u(this.quorum, O);
            case "broadcastTransaction":
                return P(this.quorum, O)
            }
            (0,
            e.assert)(!1, "unsupported method", "UNSUPPORTED_OPERATION", {
                operation: `_perform(${f(_.method)})`
            })
        }
    }
    ,
    Bi = async function(k, _) {
        if (k.size === 0)
            throw new Error("no runners?!");
        const O = [];
        let L = 0;
        for (const $ of k) {
            if ($.perform && O.push($.perform),
            $.staller) {
                O.push($.staller);
                continue
            }
            $.didBump || ($.didBump = !0,
            L++)
        }
        const U = await we(this, w, pl).call(this, k, _);
        if (U !== void 0) {
            if (U instanceof Error)
                throw U;
            return U
        }
        for (let $ = 0; $ < L; $++)
            we(this, w, Oi).call(this, k, _);
        return (0,
        e.assert)(O.length > 0, "quorum not met", "SERVER_ERROR", {
            request: "%sub-requests",
            info: {
                request: _,
                results: Array.from(k).map($ => f($.result))
            }
        }),
        await Promise.race(O),
        await we(this, w, Bi).call(this, k, _)
    }
    ,
    Bn.FallbackProvider = b,
    Bn
}
var Ec;
function xf() {
    if (Ec)
        return An;
    Ec = 1,
    Object.defineProperty(An, "__esModule", {
        value: !0
    }),
    An.getDefaultProvider = void 0;
    const e = Be()
      , t = il()
      , s = ol()
      , r = al()
      , n = cl()
      , d = ul()
      , h = ll()
      , m = dl()
      , f = bl()
      , i = wt()
      , l = dt()
      , p = Xi();
    function o(g) {
        return g && typeof g.send == "function" && typeof g.close == "function"
    }
    const c = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
    function u(g, P) {
        P == null && (P = {});
        const v = E => P[E] === "-" ? !1 : typeof P.exclusive == "string" ? E === P.exclusive : Array.isArray(P.exclusive) ? P.exclusive.indexOf(E) !== -1 : !0;
        if (typeof g == "string" && g.match(/^https?:/))
            return new i.JsonRpcProvider(g);
        if (typeof g == "string" && g.match(/^wss?:/) || o(g))
            return new p.WebSocketProvider(g);
        let b = null;
        try {
            b = l.Network.from(g)
        } catch {}
        const x = [];
        if (v("publicPolygon") && b && (b.name === "matic" ? x.push(new i.JsonRpcProvider("https://polygon-rpc.com/",b,{
            staticNetwork: b
        })) : b.name === "matic-amoy" && x.push(new i.JsonRpcProvider("https://rpc-amoy.polygon.technology/",b,{
            staticNetwork: b
        }))),
        v("alchemy"))
            try {
                x.push(new s.AlchemyProvider(g,P.alchemy))
            } catch {}
        if (v("ankr") && P.ankr != null)
            try {
                x.push(new t.AnkrProvider(g,P.ankr))
            } catch {}
        if (v("chainstack"))
            try {
                x.push(new r.ChainstackProvider(g,P.chainstack))
            } catch {}
        if (v("cloudflare"))
            try {
                x.push(new n.CloudflareProvider(g))
            } catch {}
        if (v("etherscan"))
            try {
                x.push(new d.EtherscanProvider(g,P.etherscan))
            } catch {}
        if (v("infura"))
            try {
                let E = P.infura, w;
                typeof E == "object" && (w = E.projectSecret,
                E = E.projectId),
                x.push(new h.InfuraProvider(g,E,w))
            } catch {}
        if (v("quicknode"))
            try {
                let E = P.quicknode;
                x.push(new m.QuickNodeProvider(g,E))
            } catch {}
        if ((0,
        e.assert)(x.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
            operation: "getDefaultProvider"
        }),
        x.length === 1)
            return x[0];
        let a = Math.floor(x.length / 2);
        return a > 2 && (a = 2),
        b && c.indexOf(b.name) !== -1 && (a = 1),
        P && P.quorum && (a = P.quorum),
        new f.FallbackProvider(x,void 0,{
            quorum: a
        })
    }
    return An.getDefaultProvider = u,
    An
}
var Sn = {}, Pc;
function wf() {
    var r, n;
    if (Pc)
        return Sn;
    Pc = 1,
    Object.defineProperty(Sn, "__esModule", {
        value: !0
    }),
    Sn.NonceManager = void 0;
    const e = Be()
      , t = Zi()
      , d = class d extends t.AbstractSigner {
        constructor(f) {
            super(f.provider);
            ue(this, "signer");
            he(this, r);
            he(this, n);
            (0,
            e.defineProperties)(this, {
                signer: f
            }),
            Q(this, r, null),
            Q(this, n, 0)
        }
        async getAddress() {
            return this.signer.getAddress()
        }
        connect(f) {
            return new d(this.signer.connect(f))
        }
        async getNonce(f) {
            if (f === "pending") {
                j(this, r) == null && Q(this, r, super.getNonce("pending"));
                const i = j(this, n);
                return await j(this, r) + i
            }
            return super.getNonce(f)
        }
        increment() {
            Br(this, n)._++
        }
        reset() {
            Q(this, n, 0),
            Q(this, r, null)
        }
        async sendTransaction(f) {
            const i = this.getNonce("pending");
            return this.increment(),
            f = await this.signer.populateTransaction(f),
            f.nonce = await i,
            await this.signer.sendTransaction(f)
        }
        signTransaction(f) {
            return this.signer.signTransaction(f)
        }
        signMessage(f) {
            return this.signer.signMessage(f)
        }
        signTypedData(f, i, l) {
            return this.signer.signTypedData(f, i, l)
        }
    }
    ;
    r = new WeakMap,
    n = new WeakMap;
    let s = d;
    return Sn.NonceManager = s,
    Sn
}
var Cn = {}, kc;
function Af() {
    var r, n;
    if (kc)
        return Cn;
    kc = 1,
    Object.defineProperty(Cn, "__esModule", {
        value: !0
    }),
    Cn.BrowserProvider = void 0;
    const e = Be()
      , t = wt()
      , d = class d extends t.JsonRpcApiPollingProvider {
        constructor(f, i, l) {
            const p = Object.assign({}, l ?? {}, {
                batchMaxCount: 1
            });
            (0,
            e.assertArgument)(f && f.request, "invalid EIP-1193 provider", "ethereum", f);
            super(i, p);
            he(this, r);
            he(this, n);
            Q(this, n, null),
            l && l.providerInfo && Q(this, n, l.providerInfo),
            Q(this, r, async (o, c) => {
                const u = {
                    method: o,
                    params: c
                };
                this.emit("debug", {
                    action: "sendEip1193Request",
                    payload: u
                });
                try {
                    const g = await f.request(u);
                    return this.emit("debug", {
                        action: "receiveEip1193Result",
                        result: g
                    }),
                    g
                } catch (g) {
                    const P = new Error(g.message);
                    throw P.code = g.code,
                    P.data = g.data,
                    P.payload = u,
                    this.emit("debug", {
                        action: "receiveEip1193Error",
                        error: P
                    }),
                    P
                }
            }
            )
        }
        get providerInfo() {
            return j(this, n)
        }
        async send(f, i) {
            return await this._start(),
            await super.send(f, i)
        }
        async _send(f) {
            (0,
            e.assertArgument)(!Array.isArray(f), "EIP-1193 does not support batch request", "payload", f);
            try {
                const i = await j(this, r).call(this, f.method, f.params || []);
                return [{
                    id: f.id,
                    result: i
                }]
            } catch (i) {
                return [{
                    id: f.id,
                    error: {
                        code: i.code,
                        data: i.data,
                        message: i.message
                    }
                }]
            }
        }
        getRpcError(f, i) {
            switch (i = JSON.parse(JSON.stringify(i)),
            i.error.code || -1) {
            case 4001:
                i.error.message = `ethers-user-denied: ${i.error.message}`;
                break;
            case 4200:
                i.error.message = `ethers-unsupported: ${i.error.message}`;
                break
            }
            return super.getRpcError(f, i)
        }
        async hasSigner(f) {
            f == null && (f = 0);
            const i = await this.send("eth_accounts", []);
            return typeof f == "number" ? i.length > f : (f = f.toLowerCase(),
            i.filter(l => l.toLowerCase() === f).length !== 0)
        }
        async getSigner(f) {
            if (f == null && (f = 0),
            !await this.hasSigner(f))
                try {
                    await j(this, r).call(this, "eth_requestAccounts", [])
                } catch (i) {
                    const l = i.payload;
                    throw this.getRpcError(l, {
                        id: l.id,
                        error: i
                    })
                }
            return await super.getSigner(f)
        }
        static async discover(f) {
            if (f == null && (f = {}),
            f.provider)
                return new d(f.provider);
            const i = f.window ? f.window : typeof window < "u" ? window : null;
            if (i == null)
                return null;
            const l = f.anyProvider;
            if (l && i.ethereum)
                return new d(i.ethereum);
            if (!("addEventListener"in i && "dispatchEvent"in i && "removeEventListener"in i))
                return null;
            const p = f.timeout ? f.timeout : 300;
            return p === 0 ? null : await new Promise( (o, c) => {
                let u = [];
                const g = b => {
                    u.push(b.detail),
                    l && P()
                }
                  , P = () => {
                    if (clearTimeout(v),
                    u.length)
                        if (f && f.filter) {
                            const b = f.filter(u.map(x => Object.assign({}, x.info)));
                            if (b == null)
                                o(null);
                            else if (b instanceof d)
                                o(b);
                            else {
                                let x = null;
                                if (b.uuid && (x = u.filter(E => b.uuid === E.info.uuid)[0]),
                                x) {
                                    const {provider: a, info: E} = x;
                                    o(new d(a,void 0,{
                                        providerInfo: E
                                    }))
                                } else
                                    c((0,
                                    e.makeError)("filter returned unknown info", "UNSUPPORTED_OPERATION", {
                                        value: b
                                    }))
                            }
                        } else {
                            const {provider: b, info: x} = u[0];
                            o(new d(b,void 0,{
                                providerInfo: x
                            }))
                        }
                    else
                        o(null);
                    i.removeEventListener("eip6963:announceProvider", g)
                }
                  , v = setTimeout( () => {
                    P()
                }
                , p);
                i.addEventListener("eip6963:announceProvider", g),
                i.dispatchEvent(new Event("eip6963:requestProvider"))
            }
            )
        }
    }
    ;
    r = new WeakMap,
    n = new WeakMap;
    let s = d;
    return Cn.BrowserProvider = s,
    Cn
}
var Nn = {}, _c;
function vf() {
    if (_c)
        return Nn;
    _c = 1,
    Object.defineProperty(Nn, "__esModule", {
        value: !0
    }),
    Nn.BlockscoutProvider = void 0;
    const e = Be()
      , t = dt()
      , s = wt();
    function r(d) {
        switch (d) {
        case "mainnet":
            return "https://eth.blockscout.com/api/eth-rpc";
        case "sepolia":
            return "https://eth-sepolia.blockscout.com/api/eth-rpc";
        case "holesky":
            return "https://eth-holesky.blockscout.com/api/eth-rpc";
        case "classic":
            return "https://etc.blockscout.com/api/eth-rpc";
        case "arbitrum":
            return "https://arbitrum.blockscout.com/api/eth-rpc";
        case "base":
            return "https://base.blockscout.com/api/eth-rpc";
        case "base-sepolia":
            return "https://base-sepolia.blockscout.com/api/eth-rpc";
        case "matic":
            return "https://polygon.blockscout.com/api/eth-rpc";
        case "optimism":
            return "https://optimism.blockscout.com/api/eth-rpc";
        case "optimism-sepolia":
            return "https://optimism-sepolia.blockscout.com/api/eth-rpc";
        case "xdai":
            return "https://gnosis.blockscout.com/api/eth-rpc"
        }
        (0,
        e.assertArgument)(!1, "unsupported network", "network", d)
    }
    class n extends s.JsonRpcProvider {
        constructor(m, f) {
            m == null && (m = "mainnet");
            const i = t.Network.from(m);
            f == null && (f = null);
            const l = n.getRequest(i);
            super(l, i, {
                staticNetwork: i
            });
            ue(this, "apiKey");
            (0,
            e.defineProperties)(this, {
                apiKey: f
            })
        }
        _getProvider(m) {
            try {
                return new n(m,this.apiKey)
            } catch {}
            return super._getProvider(m)
        }
        isCommunityResource() {
            return this.apiKey === null
        }
        getRpcRequest(m) {
            const f = super.getRpcRequest(m);
            return f && f.method === "eth_estimateGas" && f.args.length == 1 && (f.args = f.args.slice(),
            f.args.push("latest")),
            f
        }
        getRpcError(m, f) {
            const i = f ? f.error : null;
            if (i && i.code === -32015 && !(0,
            e.isHexString)(i.data || "", !0)) {
                const l = {
                    "assert(false)": "01",
                    "arithmetic underflow or overflow": "11",
                    "division or modulo by zero": "12",
                    "out-of-bounds array access; popping on an empty array": "31",
                    "out-of-bounds access of an array or bytesN": "32"
                };
                let p = "";
                i.message === "VM execution error." ? p = l[i.data] || "" : l[i.message || ""] && (p = l[i.message || ""]),
                p && (i.message += ` (reverted: ${i.data})`,
                i.data = "0x4e487b7100000000000000000000000000000000000000000000000000000000000000" + p)
            } else
                i && i.code === -32e3 && i.message === "wrong transaction nonce" && (i.message += " (nonce too low)");
            return super.getRpcError(m, f)
        }
        static getRequest(m) {
            const f = new e.FetchRequest(r(m.name));
            return f.allowGzip = !0,
            f
        }
    }
    return Nn.BlockscoutProvider = n,
    Nn
}
var Rn = {}, Tc;
function Ef() {
    if (Tc)
        return Rn;
    Tc = 1,
    Object.defineProperty(Rn, "__esModule", {
        value: !0
    }),
    Rn.PocketProvider = void 0;
    const e = Be()
      , t = Vt()
      , s = dt()
      , r = wt()
      , n = "62e1ad51b37b8e00394bda3b";
    function d(m) {
        switch (m) {
        case "mainnet":
            return "eth-mainnet.gateway.pokt.network";
        case "goerli":
            return "eth-goerli.gateway.pokt.network";
        case "matic":
            return "poly-mainnet.gateway.pokt.network";
        case "matic-mumbai":
            return "polygon-mumbai-rpc.gateway.pokt.network"
        }
        (0,
        e.assertArgument)(!1, "unsupported network", "network", m)
    }
    class h extends r.JsonRpcProvider {
        constructor(i, l, p) {
            i == null && (i = "mainnet");
            const o = s.Network.from(i);
            l == null && (l = n),
            p == null && (p = null);
            const c = {
                staticNetwork: o
            }
              , u = h.getRequest(o, l, p);
            super(u, o, c);
            ue(this, "applicationId");
            ue(this, "applicationSecret");
            (0,
            e.defineProperties)(this, {
                applicationId: l,
                applicationSecret: p
            })
        }
        _getProvider(i) {
            try {
                return new h(i,this.applicationId,this.applicationSecret)
            } catch {}
            return super._getProvider(i)
        }
        static getRequest(i, l, p) {
            l == null && (l = n);
            const o = new e.FetchRequest(`https://${d(i.name)}/v1/lb/${l}`);
            return o.allowGzip = !0,
            p && o.setCredentials("", p),
            l === n && (o.retryFunc = async (c, u, g) => ((0,
            t.showThrottleMessage)("PocketProvider"),
            !0)),
            o
        }
        isCommunityResource() {
            return this.applicationId === n
        }
    }
    return Rn.PocketProvider = h,
    Rn
}
var In = {}, Oc;
function Pf() {
    if (Oc)
        return In;
    Oc = 1,
    Object.defineProperty(In, "__esModule", {
        value: !0
    }),
    In.IpcSocketProvider = void 0;
    const e = void 0;
    return In.IpcSocketProvider = e,
    In
}
var Bc;
function eo() {
    return Bc || (Bc = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.SocketEventSubscriber = e.SocketPendingSubscriber = e.SocketBlockSubscriber = e.SocketSubscriber = e.WebSocketProvider = e.SocketProvider = e.IpcSocketProvider = e.QuickNodeProvider = e.PocketProvider = e.InfuraWebSocketProvider = e.InfuraProvider = e.EtherscanPlugin = e.EtherscanProvider = e.ChainstackProvider = e.CloudflareProvider = e.AnkrProvider = e.BlockscoutProvider = e.AlchemyProvider = e.BrowserProvider = e.JsonRpcSigner = e.JsonRpcProvider = e.JsonRpcApiProvider = e.FallbackProvider = e.copyRequest = e.TransactionResponse = e.TransactionReceipt = e.Log = e.FeeData = e.Block = e.FetchUrlFeeDataNetworkPlugin = e.FeeDataNetworkPlugin = e.EnsPlugin = e.GasCostPlugin = e.NetworkPlugin = e.NonceManager = e.Network = e.MulticoinProviderPlugin = e.EnsResolver = e.getDefaultProvider = e.showThrottleMessage = e.VoidSigner = e.AbstractSigner = e.UnmanagedSubscriber = e.AbstractProvider = void 0;
        var t = cs();
        Object.defineProperty(e, "AbstractProvider", {
            enumerable: !0,
            get: function() {
                return t.AbstractProvider
            }
        }),
        Object.defineProperty(e, "UnmanagedSubscriber", {
            enumerable: !0,
            get: function() {
                return t.UnmanagedSubscriber
            }
        });
        var s = Zi();
        Object.defineProperty(e, "AbstractSigner", {
            enumerable: !0,
            get: function() {
                return s.AbstractSigner
            }
        }),
        Object.defineProperty(e, "VoidSigner", {
            enumerable: !0,
            get: function() {
                return s.VoidSigner
            }
        });
        var r = Vt();
        Object.defineProperty(e, "showThrottleMessage", {
            enumerable: !0,
            get: function() {
                return r.showThrottleMessage
            }
        });
        var n = xf();
        Object.defineProperty(e, "getDefaultProvider", {
            enumerable: !0,
            get: function() {
                return n.getDefaultProvider
            }
        });
        var d = nl();
        Object.defineProperty(e, "EnsResolver", {
            enumerable: !0,
            get: function() {
                return d.EnsResolver
            }
        }),
        Object.defineProperty(e, "MulticoinProviderPlugin", {
            enumerable: !0,
            get: function() {
                return d.MulticoinProviderPlugin
            }
        });
        var h = dt();
        Object.defineProperty(e, "Network", {
            enumerable: !0,
            get: function() {
                return h.Network
            }
        });
        var m = wf();
        Object.defineProperty(e, "NonceManager", {
            enumerable: !0,
            get: function() {
                return m.NonceManager
            }
        });
        var f = Wi();
        Object.defineProperty(e, "NetworkPlugin", {
            enumerable: !0,
            get: function() {
                return f.NetworkPlugin
            }
        }),
        Object.defineProperty(e, "GasCostPlugin", {
            enumerable: !0,
            get: function() {
                return f.GasCostPlugin
            }
        }),
        Object.defineProperty(e, "EnsPlugin", {
            enumerable: !0,
            get: function() {
                return f.EnsPlugin
            }
        }),
        Object.defineProperty(e, "FeeDataNetworkPlugin", {
            enumerable: !0,
            get: function() {
                return f.FeeDataNetworkPlugin
            }
        }),
        Object.defineProperty(e, "FetchUrlFeeDataNetworkPlugin", {
            enumerable: !0,
            get: function() {
                return f.FetchUrlFeeDataNetworkPlugin
            }
        });
        var i = as();
        Object.defineProperty(e, "Block", {
            enumerable: !0,
            get: function() {
                return i.Block
            }
        }),
        Object.defineProperty(e, "FeeData", {
            enumerable: !0,
            get: function() {
                return i.FeeData
            }
        }),
        Object.defineProperty(e, "Log", {
            enumerable: !0,
            get: function() {
                return i.Log
            }
        }),
        Object.defineProperty(e, "TransactionReceipt", {
            enumerable: !0,
            get: function() {
                return i.TransactionReceipt
            }
        }),
        Object.defineProperty(e, "TransactionResponse", {
            enumerable: !0,
            get: function() {
                return i.TransactionResponse
            }
        }),
        Object.defineProperty(e, "copyRequest", {
            enumerable: !0,
            get: function() {
                return i.copyRequest
            }
        });
        var l = bl();
        Object.defineProperty(e, "FallbackProvider", {
            enumerable: !0,
            get: function() {
                return l.FallbackProvider
            }
        });
        var p = wt();
        Object.defineProperty(e, "JsonRpcApiProvider", {
            enumerable: !0,
            get: function() {
                return p.JsonRpcApiProvider
            }
        }),
        Object.defineProperty(e, "JsonRpcProvider", {
            enumerable: !0,
            get: function() {
                return p.JsonRpcProvider
            }
        }),
        Object.defineProperty(e, "JsonRpcSigner", {
            enumerable: !0,
            get: function() {
                return p.JsonRpcSigner
            }
        });
        var o = Af();
        Object.defineProperty(e, "BrowserProvider", {
            enumerable: !0,
            get: function() {
                return o.BrowserProvider
            }
        });
        var c = ol();
        Object.defineProperty(e, "AlchemyProvider", {
            enumerable: !0,
            get: function() {
                return c.AlchemyProvider
            }
        });
        var u = vf();
        Object.defineProperty(e, "BlockscoutProvider", {
            enumerable: !0,
            get: function() {
                return u.BlockscoutProvider
            }
        });
        var g = il();
        Object.defineProperty(e, "AnkrProvider", {
            enumerable: !0,
            get: function() {
                return g.AnkrProvider
            }
        });
        var P = cl();
        Object.defineProperty(e, "CloudflareProvider", {
            enumerable: !0,
            get: function() {
                return P.CloudflareProvider
            }
        });
        var v = al();
        Object.defineProperty(e, "ChainstackProvider", {
            enumerable: !0,
            get: function() {
                return v.ChainstackProvider
            }
        });
        var b = ul();
        Object.defineProperty(e, "EtherscanProvider", {
            enumerable: !0,
            get: function() {
                return b.EtherscanProvider
            }
        }),
        Object.defineProperty(e, "EtherscanPlugin", {
            enumerable: !0,
            get: function() {
                return b.EtherscanPlugin
            }
        });
        var x = ll();
        Object.defineProperty(e, "InfuraProvider", {
            enumerable: !0,
            get: function() {
                return x.InfuraProvider
            }
        }),
        Object.defineProperty(e, "InfuraWebSocketProvider", {
            enumerable: !0,
            get: function() {
                return x.InfuraWebSocketProvider
            }
        });
        var a = Ef();
        Object.defineProperty(e, "PocketProvider", {
            enumerable: !0,
            get: function() {
                return a.PocketProvider
            }
        });
        var E = dl();
        Object.defineProperty(e, "QuickNodeProvider", {
            enumerable: !0,
            get: function() {
                return E.QuickNodeProvider
            }
        });
        const w = Pf();
        Object.defineProperty(e, "IpcSocketProvider", {
            enumerable: !0,
            get: function() {
                return w.IpcSocketProvider
            }
        });
        var S = Ti();
        Object.defineProperty(e, "SocketProvider", {
            enumerable: !0,
            get: function() {
                return S.SocketProvider
            }
        });
        var T = Xi();
        Object.defineProperty(e, "WebSocketProvider", {
            enumerable: !0,
            get: function() {
                return T.WebSocketProvider
            }
        });
        var C = Ti();
        Object.defineProperty(e, "SocketSubscriber", {
            enumerable: !0,
            get: function() {
                return C.SocketSubscriber
            }
        }),
        Object.defineProperty(e, "SocketBlockSubscriber", {
            enumerable: !0,
            get: function() {
                return C.SocketBlockSubscriber
            }
        }),
        Object.defineProperty(e, "SocketPendingSubscriber", {
            enumerable: !0,
            get: function() {
                return C.SocketPendingSubscriber
            }
        }),
        Object.defineProperty(e, "SocketEventSubscriber", {
            enumerable: !0,
            get: function() {
                return C.SocketEventSubscriber
            }
        })
    }(ci)),
    ci
}
var ui = {}, jn = {}, Sc;
function to() {
    var h;
    if (Sc)
        return jn;
    Sc = 1,
    Object.defineProperty(jn, "__esModule", {
        value: !0
    }),
    jn.BaseWallet = void 0;
    const e = tt()
      , t = qt()
      , s = eo()
      , r = lt()
      , n = Be()
      , m = class m extends s.AbstractSigner {
        constructor(l, p) {
            super(p);
            ue(this, "address");
            he(this, h);
            (0,
            n.assertArgument)(l && typeof l.sign == "function", "invalid private key", "privateKey", "[ REDACTED ]"),
            Q(this, h, l);
            const o = (0,
            r.computeAddress)(this.signingKey.publicKey);
            (0,
            n.defineProperties)(this, {
                address: o
            })
        }
        get signingKey() {
            return j(this, h)
        }
        get privateKey() {
            return this.signingKey.privateKey
        }
        async getAddress() {
            return this.address
        }
        connect(l) {
            return new m(j(this, h),l)
        }
        async signTransaction(l) {
            l = (0,
            s.copyRequest)(l);
            const {to: p, from: o} = await (0,
            n.resolveProperties)({
                to: l.to ? (0,
                e.resolveAddress)(l.to, this) : void 0,
                from: l.from ? (0,
                e.resolveAddress)(l.from, this) : void 0
            });
            p != null && (l.to = p),
            o != null && (l.from = o),
            l.from != null && ((0,
            n.assertArgument)((0,
            e.getAddress)(l.from) === this.address, "transaction from address mismatch", "tx.from", l.from),
            delete l.from);
            const c = r.Transaction.from(l);
            return c.signature = this.signingKey.sign(c.unsignedHash),
            c.serialized
        }
        async signMessage(l) {
            return this.signMessageSync(l)
        }
        signMessageSync(l) {
            return this.signingKey.sign((0,
            t.hashMessage)(l)).serialized
        }
        authorizeSync(l) {
            (0,
            n.assertArgument)(typeof l.address == "string", "invalid address for authorizeSync", "auth.address", l);
            const p = this.signingKey.sign((0,
            t.hashAuthorization)(l));
            return Object.assign({}, {
                address: (0,
                e.getAddress)(l.address),
                nonce: (0,
                n.getBigInt)(l.nonce || 0),
                chainId: (0,
                n.getBigInt)(l.chainId || 0)
            }, {
                signature: p
            })
        }
        async authorize(l) {
            return l = Object.assign({}, l, {
                address: await (0,
                e.resolveAddress)(l.address, this)
            }),
            this.authorizeSync(await this.populateAuthorization(l))
        }
        async signTypedData(l, p, o) {
            const c = await t.TypedDataEncoder.resolveNames(l, p, o, async u => {
                (0,
                n.assert)(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
                    operation: "resolveName",
                    info: {
                        name: u
                    }
                });
                const g = await this.provider.resolveName(u);
                return (0,
                n.assert)(g != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
                    value: u
                }),
                g
            }
            );
            return this.signingKey.sign(t.TypedDataEncoder.hash(c.domain, p, c.value)).serialized
        }
    }
    ;
    h = new WeakMap;
    let d = m;
    return jn.BaseWallet = d,
    jn
}
var li = {}, Mn = {}, Ln = {}, Ar = {}, Cc;
function gl() {
    if (Cc)
        return Ar;
    Cc = 1,
    Object.defineProperty(Ar, "__esModule", {
        value: !0
    }),
    Ar.decodeOwl = Ar.decode = void 0;
    const e = Be()
      , t = " !#$%&'()*+,-./<=>?@[]^_`{|}~"
      , s = /^[a-z]*$/i;
    function r(h, m) {
        let f = 97;
        return h.reduce( (i, l) => (l === m ? f++ : l.match(s) ? i.push(String.fromCharCode(f) + l) : (f = 97,
        i.push(l)),
        i), [])
    }
    function n(h, m) {
        for (let l = t.length - 1; l >= 0; l--)
            h = h.split(t[l]).join(m.substring(2 * l, 2 * l + 2));
        const f = []
          , i = h.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (l, p, o, c) => {
            if (o)
                for (let u = parseInt(o); u >= 0; u--)
                    f.push(";");
            else
                f.push(p.toLowerCase());
            return ""
        }
        );
        if (i)
            throw new Error(`leftovers: ${JSON.stringify(i)}`);
        return r(r(f, ";"), ":")
    }
    Ar.decode = n;
    function d(h) {
        return (0,
        e.assertArgument)(h[0] === "0", "unsupported auwl data", "data", h),
        n(h.substring(1 + 2 * t.length), h.substring(1, 1 + 2 * t.length))
    }
    return Ar.decodeOwl = d,
    Ar
}
var Un = {}, Nc;
function ml() {
    if (Nc)
        return Un;
    Nc = 1,
    Object.defineProperty(Un, "__esModule", {
        value: !0
    }),
    Un.Wordlist = void 0;
    const e = Be();
    class t {
        constructor(r) {
            ue(this, "locale");
            (0,
            e.defineProperties)(this, {
                locale: r
            })
        }
        split(r) {
            return r.toLowerCase().split(/\s+/g)
        }
        join(r) {
            return r.join(" ")
        }
    }
    return Un.Wordlist = t,
    Un
}
var Rc;
function ro() {
    var d, h, m, f, Si;
    if (Rc)
        return Ln;
    Rc = 1,
    Object.defineProperty(Ln, "__esModule", {
        value: !0
    }),
    Ln.WordlistOwl = void 0;
    const e = qt()
      , t = Be()
      , s = gl()
      , r = ml();
    class n extends r.Wordlist {
        constructor(o, c, u) {
            super(o);
            he(this, f);
            he(this, d);
            he(this, h);
            he(this, m);
            Q(this, d, c),
            Q(this, h, u),
            Q(this, m, null)
        }
        get _data() {
            return j(this, d)
        }
        _decodeWords() {
            return (0,
            s.decodeOwl)(j(this, d))
        }
        getWord(o) {
            const c = we(this, f, Si).call(this);
            return (0,
            t.assertArgument)(o >= 0 && o < c.length, `invalid word index: ${o}`, "index", o),
            c[o]
        }
        getWordIndex(o) {
            return we(this, f, Si).call(this).indexOf(o)
        }
    }
    return d = new WeakMap,
    h = new WeakMap,
    m = new WeakMap,
    f = new WeakSet,
    Si = function() {
        if (j(this, m) == null) {
            const o = this._decodeWords();
            if ((0,
            e.id)(o.join(`
`) + `
`) !== j(this, h))
                throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
            Q(this, m, o)
        }
        return j(this, m)
    }
    ,
    Ln.WordlistOwl = n,
    Ln
}
var Ic;
function Ns() {
    if (Ic)
        return Mn;
    Ic = 1,
    Object.defineProperty(Mn, "__esModule", {
        value: !0
    }),
    Mn.LangEn = void 0;
    const e = ro()
      , t = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO"
      , s = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
    let r = null;
    class n extends e.WordlistOwl {
        constructor() {
            super("en", t, s)
        }
        static wordlist() {
            return r == null && (r = new n),
            r
        }
    }
    return Mn.LangEn = n,
    Mn
}
var Fn = {}, jc;
function no() {
    if (jc)
        return Fn;
    jc = 1,
    Object.defineProperty(Fn, "__esModule", {
        value: !0
    }),
    Fn.Mnemonic = void 0;
    const e = st()
      , t = Be()
      , s = Ns();
    function r(i) {
        return (1 << i) - 1 << 8 - i & 255
    }
    function n(i) {
        return (1 << i) - 1 & 255
    }
    function d(i, l) {
        (0,
        t.assertNormalize)("NFKD"),
        l == null && (l = s.LangEn.wordlist());
        const p = l.split(i);
        (0,
        t.assertArgument)(p.length % 3 === 0 && p.length >= 12 && p.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
        const o = new Uint8Array(Math.ceil(11 * p.length / 8));
        let c = 0;
        for (let b = 0; b < p.length; b++) {
            let x = l.getWordIndex(p[b].normalize("NFKD"));
            (0,
            t.assertArgument)(x >= 0, `invalid mnemonic word at index ${b}`, "mnemonic", "[ REDACTED ]");
            for (let a = 0; a < 11; a++)
                x & 1 << 10 - a && (o[c >> 3] |= 1 << 7 - c % 8),
                c++
        }
        const u = 32 * p.length / 3
          , g = p.length / 3
          , P = r(g)
          , v = (0,
        t.getBytes)((0,
        e.sha256)(o.slice(0, u / 8)))[0] & P;
        return (0,
        t.assertArgument)(v === (o[o.length - 1] & P), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]"),
        (0,
        t.hexlify)(o.slice(0, u / 8))
    }
    function h(i, l) {
        (0,
        t.assertArgument)(i.length % 4 === 0 && i.length >= 16 && i.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]"),
        l == null && (l = s.LangEn.wordlist());
        const p = [0];
        let o = 11;
        for (let g = 0; g < i.length; g++)
            o > 8 ? (p[p.length - 1] <<= 8,
            p[p.length - 1] |= i[g],
            o -= 8) : (p[p.length - 1] <<= o,
            p[p.length - 1] |= i[g] >> 8 - o,
            p.push(i[g] & n(8 - o)),
            o += 3);
        const c = i.length / 4
          , u = parseInt((0,
        e.sha256)(i).substring(2, 4), 16) & r(c);
        return p[p.length - 1] <<= c,
        p[p.length - 1] |= u >> 8 - c,
        l.join(p.map(g => l.getWord(g)))
    }
    const m = {};
    class f {
        constructor(l, p, o, c, u) {
            ue(this, "phrase");
            ue(this, "password");
            ue(this, "wordlist");
            ue(this, "entropy");
            c == null && (c = ""),
            u == null && (u = s.LangEn.wordlist()),
            (0,
            t.assertPrivate)(l, m, "Mnemonic"),
            (0,
            t.defineProperties)(this, {
                phrase: o,
                password: c,
                wordlist: u,
                entropy: p
            })
        }
        computeSeed() {
            const l = (0,
            t.toUtf8Bytes)("mnemonic" + this.password, "NFKD");
            return (0,
            e.pbkdf2)((0,
            t.toUtf8Bytes)(this.phrase, "NFKD"), l, 2048, 64, "sha512")
        }
        static fromPhrase(l, p, o) {
            const c = d(l, o);
            return l = h((0,
            t.getBytes)(c), o),
            new f(m,c,l,p,o)
        }
        static fromEntropy(l, p, o) {
            const c = (0,
            t.getBytes)(l, "entropy")
              , u = h(c, o);
            return new f(m,(0,
            t.hexlify)(c),u,p,o)
        }
        static entropyToPhrase(l, p) {
            const o = (0,
            t.getBytes)(l, "entropy");
            return h(o, p)
        }
        static phraseToEntropy(l, p) {
            return d(l, p)
        }
        static isValidMnemonic(l, p) {
            try {
                return d(l, p),
                !0
            } catch {}
            return !1
        }
    }
    return Fn.Mnemonic = f,
    Fn
}
var yt = {}, di = {}, Dn = {}, Mc;
function yl() {
    if (Mc)
        return Dn;
    Mc = 1;
    /*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
    var e = He && He.__classPrivateFieldGet || function(S, T, C, N) {
        if (C === "a" && !N)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof T == "function" ? S !== T || !N : !T.has(S))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return C === "m" ? N : C === "a" ? N.call(S) : N ? N.value : T.get(S)
    }
    , t = He && He.__classPrivateFieldSet || function(S, T, C, N, A) {
        if (N === "m")
            throw new TypeError("Private method is not writable");
        if (N === "a" && !A)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof T == "function" ? S !== T || !A : !T.has(S))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return N === "a" ? A.call(S, C) : A ? A.value = C : T.set(S, C),
        C
    }
    , s, r, n;
    Object.defineProperty(Dn, "__esModule", {
        value: !0
    }),
    Dn.AES = void 0;
    const d = {
        16: 10,
        24: 12,
        32: 14
    }
      , h = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145]
      , m = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]
      , f = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]
      , i = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986]
      , l = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766]
      , p = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126]
      , o = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436]
      , c = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890]
      , u = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935]
      , g = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600]
      , P = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480]
      , v = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]
      , b = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855]
      , x = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150]
      , a = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function E(S) {
        const T = [];
        for (let C = 0; C < S.length; C += 4)
            T.push(S[C] << 24 | S[C + 1] << 16 | S[C + 2] << 8 | S[C + 3]);
        return T
    }
    class w {
        get key() {
            return e(this, s, "f").slice()
        }
        constructor(T) {
            if (s.set(this, void 0),
            r.set(this, void 0),
            n.set(this, void 0),
            !(this instanceof w))
                throw Error("AES must be instanitated with `new`");
            t(this, s, new Uint8Array(T), "f");
            const C = d[this.key.length];
            if (C == null)
                throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
            t(this, n, [], "f"),
            t(this, r, [], "f");
            for (let L = 0; L <= C; L++)
                e(this, n, "f").push([0, 0, 0, 0]),
                e(this, r, "f").push([0, 0, 0, 0]);
            const N = (C + 1) * 4
              , A = this.key.length / 4
              , R = E(this.key);
            let y;
            for (let L = 0; L < A; L++)
                y = L >> 2,
                e(this, n, "f")[y][L % 4] = R[L],
                e(this, r, "f")[C - y][L % 4] = R[L];
            let k = 0, _ = A, O;
            for (; _ < N; ) {
                if (O = R[A - 1],
                R[0] ^= m[O >> 16 & 255] << 24 ^ m[O >> 8 & 255] << 16 ^ m[O & 255] << 8 ^ m[O >> 24 & 255] ^ h[k] << 24,
                k += 1,
                A != 8)
                    for (let B = 1; B < A; B++)
                        R[B] ^= R[B - 1];
                else {
                    for (let B = 1; B < A / 2; B++)
                        R[B] ^= R[B - 1];
                    O = R[A / 2 - 1],
                    R[A / 2] ^= m[O & 255] ^ m[O >> 8 & 255] << 8 ^ m[O >> 16 & 255] << 16 ^ m[O >> 24 & 255] << 24;
                    for (let B = A / 2 + 1; B < A; B++)
                        R[B] ^= R[B - 1]
                }
                let L = 0, U, $;
                for (; L < A && _ < N; )
                    U = _ >> 2,
                    $ = _ % 4,
                    e(this, n, "f")[U][$] = R[L],
                    e(this, r, "f")[C - U][$] = R[L++],
                    _++
            }
            for (let L = 1; L < C; L++)
                for (let U = 0; U < 4; U++)
                    O = e(this, r, "f")[L][U],
                    e(this, r, "f")[L][U] = v[O >> 24 & 255] ^ b[O >> 16 & 255] ^ x[O >> 8 & 255] ^ a[O & 255]
        }
        encrypt(T) {
            if (T.length != 16)
                throw new TypeError("invalid plaintext size (must be 16 bytes)");
            const C = e(this, n, "f").length - 1
              , N = [0, 0, 0, 0];
            let A = E(T);
            for (let k = 0; k < 4; k++)
                A[k] ^= e(this, n, "f")[0][k];
            for (let k = 1; k < C; k++) {
                for (let _ = 0; _ < 4; _++)
                    N[_] = i[A[_] >> 24 & 255] ^ l[A[(_ + 1) % 4] >> 16 & 255] ^ p[A[(_ + 2) % 4] >> 8 & 255] ^ o[A[(_ + 3) % 4] & 255] ^ e(this, n, "f")[k][_];
                A = N.slice()
            }
            const R = new Uint8Array(16);
            let y = 0;
            for (let k = 0; k < 4; k++)
                y = e(this, n, "f")[C][k],
                R[4 * k] = (m[A[k] >> 24 & 255] ^ y >> 24) & 255,
                R[4 * k + 1] = (m[A[(k + 1) % 4] >> 16 & 255] ^ y >> 16) & 255,
                R[4 * k + 2] = (m[A[(k + 2) % 4] >> 8 & 255] ^ y >> 8) & 255,
                R[4 * k + 3] = (m[A[(k + 3) % 4] & 255] ^ y) & 255;
            return R
        }
        decrypt(T) {
            if (T.length != 16)
                throw new TypeError("invalid ciphertext size (must be 16 bytes)");
            const C = e(this, r, "f").length - 1
              , N = [0, 0, 0, 0];
            let A = E(T);
            for (let k = 0; k < 4; k++)
                A[k] ^= e(this, r, "f")[0][k];
            for (let k = 1; k < C; k++) {
                for (let _ = 0; _ < 4; _++)
                    N[_] = c[A[_] >> 24 & 255] ^ u[A[(_ + 3) % 4] >> 16 & 255] ^ g[A[(_ + 2) % 4] >> 8 & 255] ^ P[A[(_ + 1) % 4] & 255] ^ e(this, r, "f")[k][_];
                A = N.slice()
            }
            const R = new Uint8Array(16);
            let y = 0;
            for (let k = 0; k < 4; k++)
                y = e(this, r, "f")[C][k],
                R[4 * k] = (f[A[k] >> 24 & 255] ^ y >> 24) & 255,
                R[4 * k + 1] = (f[A[(k + 3) % 4] >> 16 & 255] ^ y >> 16) & 255,
                R[4 * k + 2] = (f[A[(k + 2) % 4] >> 8 & 255] ^ y >> 8) & 255,
                R[4 * k + 3] = (f[A[(k + 1) % 4] & 255] ^ y) & 255;
            return R
        }
    }
    return Dn.AES = w,
    s = new WeakMap,
    r = new WeakMap,
    n = new WeakMap,
    Dn
}
var Hn = {}, Lc;
function Lr() {
    if (Lc)
        return Hn;
    Lc = 1,
    Object.defineProperty(Hn, "__esModule", {
        value: !0
    }),
    Hn.ModeOfOperation = void 0;
    const e = yl();
    class t {
        constructor(r, n, d) {
            if (d && !(this instanceof d))
                throw new Error(`${r} must be instantiated with "new"`);
            Object.defineProperties(this, {
                aes: {
                    enumerable: !0,
                    value: new e.AES(n)
                },
                name: {
                    enumerable: !0,
                    value: r
                }
            })
        }
    }
    return Hn.ModeOfOperation = t,
    Hn
}
var Gn = {}, Uc;
function kf() {
    if (Uc)
        return Gn;
    Uc = 1;
    var e = He && He.__classPrivateFieldSet || function(h, m, f, i, l) {
        if (i === "m")
            throw new TypeError("Private method is not writable");
        if (i === "a" && !l)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof m == "function" ? h !== m || !l : !m.has(h))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return i === "a" ? l.call(h, f) : l ? l.value = f : m.set(h, f),
        f
    }
    , t = He && He.__classPrivateFieldGet || function(h, m, f, i) {
        if (f === "a" && !i)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof m == "function" ? h !== m || !i : !m.has(h))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return f === "m" ? i : f === "a" ? i.call(h) : i ? i.value : m.get(h)
    }
    , s, r;
    Object.defineProperty(Gn, "__esModule", {
        value: !0
    }),
    Gn.CBC = void 0;
    const n = Lr();
    class d extends n.ModeOfOperation {
        constructor(m, f) {
            if (super("ECC", m, d),
            s.set(this, void 0),
            r.set(this, void 0),
            f) {
                if (f.length % 16)
                    throw new TypeError("invalid iv size (must be 16 bytes)");
                e(this, s, new Uint8Array(f), "f")
            } else
                e(this, s, new Uint8Array(16), "f");
            e(this, r, this.iv, "f")
        }
        get iv() {
            return new Uint8Array(t(this, s, "f"))
        }
        encrypt(m) {
            if (m.length % 16)
                throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
            const f = new Uint8Array(m.length);
            for (let i = 0; i < m.length; i += 16) {
                for (let l = 0; l < 16; l++)
                    t(this, r, "f")[l] ^= m[i + l];
                e(this, r, this.aes.encrypt(t(this, r, "f")), "f"),
                f.set(t(this, r, "f"), i)
            }
            return f
        }
        decrypt(m) {
            if (m.length % 16)
                throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
            const f = new Uint8Array(m.length);
            for (let i = 0; i < m.length; i += 16) {
                const l = this.aes.decrypt(m.subarray(i, i + 16));
                for (let p = 0; p < 16; p++)
                    f[i + p] = l[p] ^ t(this, r, "f")[p],
                    t(this, r, "f")[p] = m[i + p]
            }
            return f
        }
    }
    return Gn.CBC = d,
    s = new WeakMap,
    r = new WeakMap,
    Gn
}
var $n = {}, Fc;
function _f() {
    if (Fc)
        return $n;
    Fc = 1;
    var e = He && He.__classPrivateFieldSet || function(f, i, l, p, o) {
        if (p === "m")
            throw new TypeError("Private method is not writable");
        if (p === "a" && !o)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof i == "function" ? f !== i || !o : !i.has(f))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return p === "a" ? o.call(f, l) : o ? o.value = l : i.set(f, l),
        l
    }
    , t = He && He.__classPrivateFieldGet || function(f, i, l, p) {
        if (l === "a" && !p)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof i == "function" ? f !== i || !p : !i.has(f))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return l === "m" ? p : l === "a" ? p.call(f) : p ? p.value : i.get(f)
    }
    , s, r, n, d;
    Object.defineProperty($n, "__esModule", {
        value: !0
    }),
    $n.CFB = void 0;
    const h = Lr();
    class m extends h.ModeOfOperation {
        constructor(i, l, p=8) {
            if (super("CFB", i, m),
            s.add(this),
            r.set(this, void 0),
            n.set(this, void 0),
            !Number.isInteger(p) || p % 8)
                throw new TypeError("invalid segmentSize");
            if (Object.defineProperties(this, {
                segmentSize: {
                    enumerable: !0,
                    value: p
                }
            }),
            l) {
                if (l.length % 16)
                    throw new TypeError("invalid iv size (must be 16 bytes)");
                e(this, r, new Uint8Array(l), "f")
            } else
                e(this, r, new Uint8Array(16), "f");
            e(this, n, this.iv, "f")
        }
        get iv() {
            return new Uint8Array(t(this, r, "f"))
        }
        encrypt(i) {
            if (8 * i.length % this.segmentSize)
                throw new TypeError("invalid plaintext size (must be multiple of segmentSize bytes)");
            const l = this.segmentSize / 8
              , p = new Uint8Array(i);
            for (let o = 0; o < p.length; o += l) {
                const c = this.aes.encrypt(t(this, n, "f"));
                for (let u = 0; u < l; u++)
                    p[o + u] ^= c[u];
                t(this, s, "m", d).call(this, p.subarray(o))
            }
            return p
        }
        decrypt(i) {
            if (8 * i.length % this.segmentSize)
                throw new TypeError("invalid ciphertext size (must be multiple of segmentSize bytes)");
            const l = this.segmentSize / 8
              , p = new Uint8Array(i);
            for (let o = 0; o < p.length; o += l) {
                const c = this.aes.encrypt(t(this, n, "f"));
                for (let u = 0; u < l; u++)
                    p[o + u] ^= c[u];
                t(this, s, "m", d).call(this, i.subarray(o))
            }
            return p
        }
    }
    return $n.CFB = m,
    r = new WeakMap,
    n = new WeakMap,
    s = new WeakSet,
    d = function(i) {
        const l = this.segmentSize / 8;
        t(this, n, "f").set(t(this, n, "f").subarray(l)),
        t(this, n, "f").set(i.subarray(0, l), 16 - l)
    }
    ,
    $n
}
var qn = {}, Dc;
function Tf() {
    if (Dc)
        return qn;
    Dc = 1;
    var e = He && He.__classPrivateFieldSet || function(m, f, i, l, p) {
        if (l === "m")
            throw new TypeError("Private method is not writable");
        if (l === "a" && !p)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof f == "function" ? m !== f || !p : !f.has(m))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return l === "a" ? p.call(m, i) : p ? p.value = i : f.set(m, i),
        i
    }
    , t = He && He.__classPrivateFieldGet || function(m, f, i, l) {
        if (i === "a" && !l)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof f == "function" ? m !== f || !l : !f.has(m))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return i === "m" ? l : i === "a" ? l.call(m) : l ? l.value : f.get(m)
    }
    , s, r, n;
    Object.defineProperty(qn, "__esModule", {
        value: !0
    }),
    qn.CTR = void 0;
    const d = Lr();
    class h extends d.ModeOfOperation {
        constructor(f, i) {
            super("CTR", f, h),
            s.set(this, void 0),
            r.set(this, void 0),
            n.set(this, void 0),
            e(this, n, new Uint8Array(16), "f"),
            t(this, n, "f").fill(0),
            e(this, s, t(this, n, "f"), "f"),
            e(this, r, 16, "f"),
            i == null && (i = 1),
            typeof i == "number" ? this.setCounterValue(i) : this.setCounterBytes(i)
        }
        get counter() {
            return new Uint8Array(t(this, n, "f"))
        }
        setCounterValue(f) {
            if (!Number.isInteger(f) || f < 0 || f > Number.MAX_SAFE_INTEGER)
                throw new TypeError("invalid counter initial integer value");
            for (let i = 15; i >= 0; --i)
                t(this, n, "f")[i] = f % 256,
                f = Math.floor(f / 256)
        }
        setCounterBytes(f) {
            if (f.length !== 16)
                throw new TypeError("invalid counter initial Uint8Array value length");
            t(this, n, "f").set(f)
        }
        increment() {
            for (let f = 15; f >= 0; f--)
                if (t(this, n, "f")[f] === 255)
                    t(this, n, "f")[f] = 0;
                else {
                    t(this, n, "f")[f]++;
                    break
                }
        }
        encrypt(f) {
var i, l;
            const p = new Uint8Array(f);
            for (let o = 0; o < p.length; o++)
                t(this, r, "f") === 16 && (e(this, s, this.aes.encrypt(t(this, n, "f")), "f"),
                e(this, r, 0, "f"),
                this.increment()),
                p[o] ^= t(this, s, "f")[e(this, r, (l = t(this, r, "f"),
                i = l++,
                l), "f"),
                i];
            return p
        }
        decrypt(f) {
            return this.encrypt(f)
        }
    }
    return qn.CTR = h,
    s = new WeakMap,
    r = new WeakMap,
    n = new WeakMap,
    qn
}
var zn = {}, Hc;
function Of() {
    if (Hc)
        return zn;
    Hc = 1,
    Object.defineProperty(zn, "__esModule", {
        value: !0
    }),
    zn.ECB = void 0;
    const e = Lr();
    class t extends e.ModeOfOperation {
        constructor(r) {
            super("ECB", r, t)
        }
        encrypt(r) {
            if (r.length % 16)
                throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
            const n = new Uint8Array(r.length);
            for (let d = 0; d < r.length; d += 16)
                n.set(this.aes.encrypt(r.subarray(d, d + 16)), d);
            return n
        }
        decrypt(r) {
            if (r.length % 16)
                throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
            const n = new Uint8Array(r.length);
            for (let d = 0; d < r.length; d += 16)
                n.set(this.aes.decrypt(r.subarray(d, d + 16)), d);
            return n
        }
    }
    return zn.ECB = t,
    zn
}
var Kn = {}, Gc;
function Bf() {
    if (Gc)
        return Kn;
    Gc = 1;
    var e = He && He.__classPrivateFieldSet || function(m, f, i, l, p) {
        if (l === "m")
            throw new TypeError("Private method is not writable");
        if (l === "a" && !p)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof f == "function" ? m !== f || !p : !f.has(m))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return l === "a" ? p.call(m, i) : p ? p.value = i : f.set(m, i),
        i
    }
    , t = He && He.__classPrivateFieldGet || function(m, f, i, l) {
        if (i === "a" && !l)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof f == "function" ? m !== f || !l : !f.has(m))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return i === "m" ? l : i === "a" ? l.call(m) : l ? l.value : f.get(m)
    }
    , s, r, n;
    Object.defineProperty(Kn, "__esModule", {
        value: !0
    }),
    Kn.OFB = void 0;
    const d = Lr();
    class h extends d.ModeOfOperation {
        constructor(f, i) {
            if (super("OFB", f, h),
            s.set(this, void 0),
            r.set(this, void 0),
            n.set(this, void 0),
            i) {
                if (i.length % 16)
                    throw new TypeError("invalid iv size (must be 16 bytes)");
                e(this, s, new Uint8Array(i), "f")
            } else
                e(this, s, new Uint8Array(16), "f");
            e(this, r, this.iv, "f"),
            e(this, n, 16, "f")
        }
        get iv() {
            return new Uint8Array(t(this, s, "f"))
        }
        encrypt(f) {
            var i, l;
            if (f.length % 16)
                throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
            const p = new Uint8Array(f);
            for (let o = 0; o < p.length; o++)
                t(this, n, "f") === 16 && (e(this, r, this.aes.encrypt(t(this, r, "f")), "f"),
                e(this, n, 0, "f")),
                p[o] ^= t(this, r, "f")[e(this, n, (l = t(this, n, "f"),
                i = l++,
                l), "f"),
                i];
            return p
        }
        decrypt(f) {
            if (f.length % 16)
                throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
            return this.encrypt(f)
        }
    }
    return Kn.OFB = h,
    s = new WeakMap,
    r = new WeakMap,
    n = new WeakMap,
    Kn
}
var vr = {}, $c;
function Sf() {
    if ($c)
        return vr;
    $c = 1,
    Object.defineProperty(vr, "__esModule", {
        value: !0
    }),
    vr.pkcs7Strip = vr.pkcs7Pad = void 0;
    function e(s) {
        const r = 16 - s.length % 16
          , n = new Uint8Array(s.length + r);
        n.set(s);
        for (let d = s.length; d < n.length; d++)
            n[d] = r;
        return n
    }
    vr.pkcs7Pad = e;
    function t(s) {
        if (s.length < 16)
            throw new TypeError("PKCS#7 invalid length");
        const r = s[s.length - 1];
        if (r > 16)
            throw new TypeError("PKCS#7 padding byte out of range");
        const n = s.length - r;
        for (let d = 0; d < r; d++)
            if (s[n + d] !== r)
                throw new TypeError("PKCS#7 invalid padding byte");
        return new Uint8Array(s.subarray(0, n))
    }
    return vr.pkcs7Strip = t,
    vr
}
var qc;
function xl() {
    return qc || (qc = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.pkcs7Strip = e.pkcs7Pad = e.OFB = e.ECB = e.CTR = e.CFB = e.CBC = e.ModeOfOperation = e.AES = void 0;
        var t = yl();
        Object.defineProperty(e, "AES", {
            enumerable: !0,
            get: function() {
                return t.AES
            }
        });
        var s = Lr();
        Object.defineProperty(e, "ModeOfOperation", {
            enumerable: !0,
            get: function() {
                return s.ModeOfOperation
            }
        });
        var r = kf();
        Object.defineProperty(e, "CBC", {
            enumerable: !0,
            get: function() {
                return r.CBC
            }
        });
        var n = _f();
        Object.defineProperty(e, "CFB", {
            enumerable: !0,
            get: function() {
                return n.CFB
            }
        });
        var d = Tf();
        Object.defineProperty(e, "CTR", {
            enumerable: !0,
            get: function() {
                return d.CTR
            }
        });
        var h = Of();
        Object.defineProperty(e, "ECB", {
            enumerable: !0,
            get: function() {
                return h.ECB
            }
        });
        var m = Bf();
        Object.defineProperty(e, "OFB", {
            enumerable: !0,
            get: function() {
                return m.OFB
            }
        });
        var f = Sf();
        Object.defineProperty(e, "pkcs7Pad", {
            enumerable: !0,
            get: function() {
                return f.pkcs7Pad
            }
        }),
        Object.defineProperty(e, "pkcs7Strip", {
            enumerable: !0,
            get: function() {
                return f.pkcs7Strip
            }
        })
    }(di)),
    di
}
var _t = {}, zc;
function wl() {
    if (zc)
        return _t;
    zc = 1,
    Object.defineProperty(_t, "__esModule", {
        value: !0
    }),
    _t.spelunk = _t.getPassword = _t.zpad = _t.looseArrayify = void 0;
    const e = Be();
    function t(d) {
        return typeof d == "string" && !d.startsWith("0x") && (d = "0x" + d),
        (0,
        e.getBytesCopy)(d)
    }
    _t.looseArrayify = t;
    function s(d, h) {
        for (d = String(d); d.length < h; )
            d = "0" + d;
        return d
    }
    _t.zpad = s;
    function r(d) {
        return typeof d == "string" ? (0,
        e.toUtf8Bytes)(d, "NFKC") : (0,
        e.getBytesCopy)(d)
    }
    _t.getPassword = r;
    function n(d, h) {
        const m = h.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
        (0,
        e.assertArgument)(m != null, "invalid path", "path", h);
        const f = m[1]
          , i = m[3]
          , l = m[4] === "!";
        let p = d;
        for (const o of f.toLowerCase().split(".")) {
            if (Array.isArray(p)) {
                if (!o.match(/^[0-9]+$/))
                    break;
                p = p[parseInt(o)]
            } else if (typeof p == "object") {
                let c = null;
                for (const u in p)
                    if (u.toLowerCase() === o) {
                        c = p[u];
                        break
                    }
                p = c
            } else
                p = null;
            if (p == null)
                break
        }
        if ((0,
        e.assertArgument)(!l || p != null, "missing required value", "path", f),
        i && p != null) {
            if (i === "int") {
                if (typeof p == "string" && p.match(/^-?[0-9]+$/))
                    return parseInt(p);
                if (Number.isSafeInteger(p))
                    return p
            }
            if (i === "number" && typeof p == "string" && p.match(/^-?[0-9.]*$/))
                return parseFloat(p);
            if (i === "data" && typeof p == "string")
                return t(p);
            if (i === "array" && Array.isArray(p) || i === typeof p)
                return p;
            (0,
            e.assertArgument)(!1, `wrong type found for ${i} `, "path", f)
        }
        return p
    }
    return _t.spelunk = n,
    _t
}
var Kc;
function so() {
    if (Kc)
        return yt;
    Kc = 1,
    Object.defineProperty(yt, "__esModule", {
        value: !0
    }),
    yt.encryptKeystoreJson = yt.encryptKeystoreJsonSync = yt.decryptKeystoreJson = yt.decryptKeystoreJsonSync = yt.isKeystoreJson = void 0;
    const e = xl()
      , t = tt()
      , s = st()
      , r = lt()
      , n = Be()
      , d = wl()
      , h = $i()
      , m = "m/44'/60'/0'/0/0";
    function f(x) {
        try {
            const a = JSON.parse(x);
            if ((a.version != null ? parseInt(a.version) : 0) === 3)
                return !0
        } catch {}
        return !1
    }
    yt.isKeystoreJson = f;
    function i(x, a, E) {
        if ((0,
        d.spelunk)(x, "crypto.cipher:string") === "aes-128-ctr") {
            const S = (0,
            d.spelunk)(x, "crypto.cipherparams.iv:data!")
              , T = new e.CTR(a,S);
            return (0,
            n.hexlify)(T.decrypt(E))
        }
        (0,
        n.assert)(!1, "unsupported cipher", "UNSUPPORTED_OPERATION", {
            operation: "decrypt"
        })
    }
    function l(x, a) {
        const E = (0,
        n.getBytes)(a)
          , w = (0,
        d.spelunk)(x, "crypto.ciphertext:data!")
          , S = (0,
        n.hexlify)((0,
        s.keccak256)((0,
        n.concat)([E.slice(16, 32), w]))).substring(2);
        (0,
        n.assertArgument)(S === (0,
        d.spelunk)(x, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
        const T = i(x, E.slice(0, 16), w)
          , C = (0,
        r.computeAddress)(T);
        if (x.address) {
            let R = x.address.toLowerCase();
            R.startsWith("0x") || (R = "0x" + R),
            (0,
            n.assertArgument)((0,
            t.getAddress)(R) === C, "keystore address/privateKey mismatch", "address", x.address)
        }
        const N = {
            address: C,
            privateKey: T
        };
        if ((0,
        d.spelunk)(x, "x-ethers.version:string") === "0.1") {
            const R = E.slice(32, 64)
              , y = (0,
            d.spelunk)(x, "x-ethers.mnemonicCiphertext:data!")
              , k = (0,
            d.spelunk)(x, "x-ethers.mnemonicCounter:data!")
              , _ = new e.CTR(R,k);
            N.mnemonic = {
                path: (0,
                d.spelunk)(x, "x-ethers.path:string") || m,
                locale: (0,
                d.spelunk)(x, "x-ethers.locale:string") || "en",
                entropy: (0,
                n.hexlify)((0,
                n.getBytes)(_.decrypt(y)))
            }
        }
        return N
    }
    function p(x) {
        const a = (0,
        d.spelunk)(x, "crypto.kdf:string");
        if (a && typeof a == "string") {
            if (a.toLowerCase() === "scrypt") {
                const E = (0,
                d.spelunk)(x, "crypto.kdfparams.salt:data!")
                  , w = (0,
                d.spelunk)(x, "crypto.kdfparams.n:int!")
                  , S = (0,
                d.spelunk)(x, "crypto.kdfparams.r:int!")
                  , T = (0,
                d.spelunk)(x, "crypto.kdfparams.p:int!");
                (0,
                n.assertArgument)(w > 0 && (w & w - 1) === 0, "invalid kdf.N", "kdf.N", w),
                (0,
                n.assertArgument)(S > 0 && T > 0, "invalid kdf", "kdf", a);
                const C = (0,
                d.spelunk)(x, "crypto.kdfparams.dklen:int!");
                return (0,
                n.assertArgument)(C === 32, "invalid kdf.dklen", "kdf.dflen", C),
                {
                    name: "scrypt",
                    salt: E,
                    N: w,
                    r: S,
                    p: T,
                    dkLen: 64
                }
            } else if (a.toLowerCase() === "pbkdf2") {
                const E = (0,
                d.spelunk)(x, "crypto.kdfparams.salt:data!")
                  , w = (0,
                d.spelunk)(x, "crypto.kdfparams.prf:string!")
                  , S = w.split("-").pop();
                (0,
                n.assertArgument)(S === "sha256" || S === "sha512", "invalid kdf.pdf", "kdf.pdf", w);
                const T = (0,
                d.spelunk)(x, "crypto.kdfparams.c:int!")
                  , C = (0,
                d.spelunk)(x, "crypto.kdfparams.dklen:int!");
                return (0,
                n.assertArgument)(C === 32, "invalid kdf.dklen", "kdf.dklen", C),
                {
                    name: "pbkdf2",
                    salt: E,
                    count: T,
                    dkLen: C,
                    algorithm: S
                }
            }
        }
        (0,
        n.assertArgument)(!1, "unsupported key-derivation function", "kdf", a)
    }
    function o(x, a) {
        const E = JSON.parse(x)
          , w = (0,
        d.getPassword)(a)
          , S = p(E);
        if (S.name === "pbkdf2") {
            const {salt: k, count: _, dkLen: O, algorithm: L} = S
              , U = (0,
            s.pbkdf2)(w, k, _, O, L);
            return l(E, U)
        }
        (0,
        n.assert)(S.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", {
            params: S
        });
        const {salt: T, N: C, r: N, p: A, dkLen: R} = S
          , y = (0,
        s.scryptSync)(w, T, C, N, A, R);
        return l(E, y)
    }
    yt.decryptKeystoreJsonSync = o;
    function c(x) {
        return new Promise(a => {
            setTimeout( () => {
                a()
            }
            , x)
        }
        )
    }
    async function u(x, a, E) {
        const w = JSON.parse(x)
          , S = (0,
        d.getPassword)(a)
          , T = p(w);
        if (T.name === "pbkdf2") {
            E && (E(0),
            await c(0));
            const {salt: _, count: O, dkLen: L, algorithm: U} = T
              , $ = (0,
            s.pbkdf2)(S, _, O, L, U);
            return E && (E(1),
            await c(0)),
            l(w, $)
        }
        (0,
        n.assert)(T.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", {
            params: T
        });
        const {salt: C, N, r: A, p: R, dkLen: y} = T
          , k = await (0,
        s.scrypt)(S, C, N, A, R, y, E);
        return l(w, k)
    }
    yt.decryptKeystoreJson = u;
    function g(x) {
        const a = x.salt != null ? (0,
        n.getBytes)(x.salt, "options.salt") : (0,
        s.randomBytes)(32);
        let E = 1 << 17
          , w = 8
          , S = 1;
        return x.scrypt && (x.scrypt.N && (E = x.scrypt.N),
        x.scrypt.r && (w = x.scrypt.r),
        x.scrypt.p && (S = x.scrypt.p)),
        (0,
        n.assertArgument)(typeof E == "number" && E > 0 && Number.isSafeInteger(E) && (BigInt(E) & BigInt(E - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", E),
        (0,
        n.assertArgument)(typeof w == "number" && w > 0 && Number.isSafeInteger(w), "invalid scrypt r parameter", "options.r", w),
        (0,
        n.assertArgument)(typeof S == "number" && S > 0 && Number.isSafeInteger(S), "invalid scrypt p parameter", "options.p", S),
        {
            name: "scrypt",
            dkLen: 32,
            salt: a,
            N: E,
            r: w,
            p: S
        }
    }
    function P(x, a, E, w) {
        const S = (0,
        n.getBytes)(E.privateKey, "privateKey")
          , T = w.iv != null ? (0,
        n.getBytes)(w.iv, "options.iv") : (0,
        s.randomBytes)(16);
        (0,
        n.assertArgument)(T.length === 16, "invalid options.iv length", "options.iv", w.iv);
        const C = w.uuid != null ? (0,
        n.getBytes)(w.uuid, "options.uuid") : (0,
        s.randomBytes)(16);
        (0,
        n.assertArgument)(C.length === 16, "invalid options.uuid length", "options.uuid", w.iv);
        const N = x.slice(0, 16)
          , A = x.slice(16, 32)
          , R = new e.CTR(N,T)
          , y = (0,
        n.getBytes)(R.encrypt(S))
          , k = (0,
        s.keccak256)((0,
        n.concat)([A, y]))
          , _ = {
            address: E.address.substring(2).toLowerCase(),
            id: (0,
            n.uuidV4)(C),
            version: 3,
            Crypto: {
                cipher: "aes-128-ctr",
                cipherparams: {
                    iv: (0,
                    n.hexlify)(T).substring(2)
                },
                ciphertext: (0,
                n.hexlify)(y).substring(2),
                kdf: "scrypt",
                kdfparams: {
                    salt: (0,
                    n.hexlify)(a.salt).substring(2),
                    n: a.N,
                    dklen: 32,
                    p: a.p,
                    r: a.r
                },
                mac: k.substring(2)
            }
        };
        if (E.mnemonic) {
            const O = w.client != null ? w.client : `ethers/${h.version}`
              , L = E.mnemonic.path || m
              , U = E.mnemonic.locale || "en"
              , $ = x.slice(32, 64)
              , B = (0,
            n.getBytes)(E.mnemonic.entropy, "account.mnemonic.entropy")
              , I = (0,
            s.randomBytes)(16)
              , F = new e.CTR($,I)
              , z = (0,
            n.getBytes)(F.encrypt(B))
              , Y = new Date
              , ne = "UTC--" + (Y.getUTCFullYear() + "-" + (0,
            d.zpad)(Y.getUTCMonth() + 1, 2) + "-" + (0,
            d.zpad)(Y.getUTCDate(), 2) + "T" + (0,
            d.zpad)(Y.getUTCHours(), 2) + "-" + (0,
            d.zpad)(Y.getUTCMinutes(), 2) + "-" + (0,
            d.zpad)(Y.getUTCSeconds(), 2) + ".0Z") + "--" + _.address;
            _["x-ethers"] = {
                client: O,
                gethFilename: ne,
                path: L,
                locale: U,
                mnemonicCounter: (0,
                n.hexlify)(I).substring(2),
                mnemonicCiphertext: (0,
                n.hexlify)(z).substring(2),
                version: "0.1"
            }
        }
        return JSON.stringify(_)
    }
    function v(x, a, E) {
        E == null && (E = {});
        const w = (0,
        d.getPassword)(a)
          , S = g(E)
          , T = (0,
        s.scryptSync)(w, S.salt, S.N, S.r, S.p, 64);
        return P((0,
        n.getBytes)(T), S, x, E)
    }
    yt.encryptKeystoreJsonSync = v;
    async function b(x, a, E) {
        E == null && (E = {});
        const w = (0,
        d.getPassword)(a)
          , S = g(E)
          , T = await (0,
        s.scrypt)(w, S.salt, S.N, S.r, S.p, 64, E.progressCallback);
        return P((0,
        n.getBytes)(T), S, x, E)
    }
    return yt.encryptKeystoreJson = b,
    yt
}
var Vc;
function Al() {
    return Vc || (Vc = 1,
    function(e) {
        var w, Ci, T, rs;
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.getIndexedAccountPath = e.getAccountPath = e.HDNodeVoidWallet = e.HDNodeWallet = e.defaultPath = void 0;
        const t = st()
          , s = eo()
          , r = lt()
          , n = Be()
          , d = Ns()
          , h = to()
          , m = no()
          , f = so();
        e.defaultPath = "m/44'/60'/0'/0/0";
        const i = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100])
          , l = 2147483648
          , p = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
          , o = "0123456789abcdef";
        function c(A, R) {
            let y = "";
            for (; A; )
                y = o[A % 16] + y,
                A = Math.trunc(A / 16);
            for (; y.length < R * 2; )
                y = "0" + y;
            return "0x" + y
        }
        function u(A) {
            const R = (0,
            n.getBytes)(A)
              , y = (0,
            n.dataSlice)((0,
            t.sha256)((0,
            t.sha256)(R)), 0, 4)
              , k = (0,
            n.concat)([R, y]);
            return (0,
            n.encodeBase58)(k)
        }
        const g = {};
        function P(A, R, y, k) {
            const _ = new Uint8Array(37);
            A & l ? ((0,
            n.assert)(k != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
                operation: "deriveChild"
            }),
            _.set((0,
            n.getBytes)(k), 1)) : _.set((0,
            n.getBytes)(y));
            for (let L = 24; L >= 0; L -= 8)
                _[33 + (L >> 3)] = A >> 24 - L & 255;
            const O = (0,
            n.getBytes)((0,
            t.computeHmac)("sha512", R, _));
            return {
                IL: O.slice(0, 32),
                IR: O.slice(32)
            }
        }
        function v(A, R) {
            const y = R.split("/");
            (0,
            n.assertArgument)(y.length > 0, "invalid path", "path", R),
            y[0] === "m" && ((0,
            n.assertArgument)(A.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${A.depth}`, "path", R),
            y.shift());
            let k = A;
            for (let _ = 0; _ < y.length; _++) {
                const O = y[_];
                if (O.match(/^[0-9]+'$/)) {
                    const L = parseInt(O.substring(0, O.length - 1));
                    (0,
                    n.assertArgument)(L < l, "invalid path index", `path[${_}]`, O),
                    k = k.deriveChild(l + L)
                } else if (O.match(/^[0-9]+$/)) {
                    const L = parseInt(O);
                    (0,
                    n.assertArgument)(L < l, "invalid path index", `path[${_}]`, O),
                    k = k.deriveChild(L)
                } else
                    (0,
                    n.assertArgument)(!1, "invalid path component", `path[${_}]`, O)
            }
            return k
        }
        const N = class N extends h.BaseWallet {
            constructor(y, k, _, O, L, U, $, B, I) {
                super(k, I);
                he(this, w);
                ue(this, "publicKey");
                ue(this, "fingerprint");
                ue(this, "parentFingerprint");
                ue(this, "mnemonic");
                ue(this, "chainCode");
                ue(this, "path");
                ue(this, "index");
                ue(this, "depth");
                (0,
                n.assertPrivate)(y, g, "HDNodeWallet"),
                (0,
                n.defineProperties)(this, {
                    publicKey: k.compressedPublicKey
                });
                const F = (0,
                n.dataSlice)((0,
                t.ripemd160)((0,
                t.sha256)(this.publicKey)), 0, 4);
                (0,
                n.defineProperties)(this, {
                    parentFingerprint: _,
                    fingerprint: F,
                    chainCode: O,
                    path: L,
                    index: U,
                    depth: $
                }),
                (0,
                n.defineProperties)(this, {
                    mnemonic: B
                })
            }
            connect(y) {
                return new N(g,this.signingKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.mnemonic,y)
            }
            async encrypt(y, k) {
                return await (0,
                f.encryptKeystoreJson)(we(this, w, Ci).call(this), y, {
                    progressCallback: k
                })
            }
            encryptSync(y) {
                return (0,
                f.encryptKeystoreJsonSync)(we(this, w, Ci).call(this), y)
            }
            get extendedKey() {
                return (0,
                n.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
                    operation: "extendedKey"
                }),
                u((0,
                n.concat)(["0x0488ADE4", c(this.depth, 1), this.parentFingerprint, c(this.index, 4), this.chainCode, (0,
                n.concat)(["0x00", this.privateKey])]))
            }
            hasPath() {
                return this.path != null
            }
            neuter() {
                return new x(g,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,this.provider)
            }
            deriveChild(y) {
                const k = (0,
                n.getNumber)(y, "index");
                (0,
                n.assertArgument)(k <= 4294967295, "invalid index", "index", k);
                let _ = this.path;
                _ && (_ += "/" + (k & 2147483647),
                k & l && (_ += "'"));
                const {IR: O, IL: L} = P(k, this.chainCode, this.publicKey, this.privateKey)
                  , U = new t.SigningKey((0,
                n.toBeHex)(((0,
                n.toBigInt)(L) + BigInt(this.privateKey)) % p, 32));
                return new N(g,U,this.fingerprint,(0,
                n.hexlify)(O),_,k,this.depth + 1,this.mnemonic,this.provider)
            }
            derivePath(y) {
                return v(this, y)
            }
            static fromExtendedKey(y) {
                const k = (0,
                n.toBeArray)((0,
                n.decodeBase58)(y));
                (0,
                n.assertArgument)(k.length === 82 || u(k.slice(0, 78)) === y, "invalid extended key", "extendedKey", "[ REDACTED ]");
                const _ = k[4]
                  , O = (0,
                n.hexlify)(k.slice(5, 9))
                  , L = parseInt((0,
                n.hexlify)(k.slice(9, 13)).substring(2), 16)
                  , U = (0,
                n.hexlify)(k.slice(13, 45))
                  , $ = k.slice(45, 78);
                switch ((0,
                n.hexlify)(k.slice(0, 4))) {
                case "0x0488b21e":
                case "0x043587cf":
                    {
                        const B = (0,
                        n.hexlify)($);
                        return new x(g,(0,
                        r.computeAddress)(B),B,O,U,null,L,_,null)
                    }
                case "0x0488ade4":
                case "0x04358394 ":
                    if ($[0] !== 0)
                        break;
                    return new N(g,new t.SigningKey($.slice(1)),O,U,null,L,_,null,null)
                }
                (0,
                n.assertArgument)(!1, "invalid extended key prefix", "extendedKey", "[ REDACTED ]")
            }
            static createRandom(y, k, _) {
                var L;
                y == null && (y = ""),
                k == null && (k = e.defaultPath),
                _ == null && (_ = d.LangEn.wordlist());
                const O = m.Mnemonic.fromEntropy((0,
                t.randomBytes)(16), y, _);
                return we(L = N, T, rs).call(L, O.computeSeed(), O).derivePath(k)
            }
            static fromMnemonic(y, k) {
                var _;
                return k || (k = e.defaultPath),
                we(_ = N, T, rs).call(_, y.computeSeed(), y).derivePath(k)
            }
            static fromPhrase(y, k, _, O) {
                var U;
                k == null && (k = ""),
                _ == null && (_ = e.defaultPath),
                O == null && (O = d.LangEn.wordlist());
                const L = m.Mnemonic.fromPhrase(y, k, O);
                return we(U = N, T, rs).call(U, L.computeSeed(), L).derivePath(_)
            }
            static fromSeed(y) {
                var k;
                return we(k = N, T, rs).call(k, y, null)
            }
        }
        ;
        w = new WeakSet,
        Ci = function() {
            const y = {
                address: this.address,
                privateKey: this.privateKey
            }
              , k = this.mnemonic;
            return this.path && k && k.wordlist.locale === "en" && k.password === "" && (y.mnemonic = {
                path: this.path,
                locale: "en",
                entropy: k.entropy
            }),
            y
        }
        ,
        T = new WeakSet,
        rs = function(y, k) {
            (0,
            n.assertArgument)((0,
            n.isBytesLike)(y), "invalid seed", "seed", "[REDACTED]");
            const _ = (0,
            n.getBytes)(y, "seed");
            (0,
            n.assertArgument)(_.length >= 16 && _.length <= 64, "invalid seed", "seed", "[REDACTED]");
            const O = (0,
            n.getBytes)((0,
            t.computeHmac)("sha512", i, _))
              , L = new t.SigningKey((0,
            n.hexlify)(O.slice(0, 32)));
            return new N(g,L,"0x00000000",(0,
            n.hexlify)(O.slice(32)),"m",0,0,k,null)
        }
        ,
        he(N, T);
        let b = N;
        e.HDNodeWallet = b;
        class x extends s.VoidSigner {
            constructor(y, k, _, O, L, U, $, B, I) {
                super(k, I);
                ue(this, "publicKey");
                ue(this, "fingerprint");
                ue(this, "parentFingerprint");
                ue(this, "chainCode");
                ue(this, "path");
                ue(this, "index");
                ue(this, "depth");
                (0,
                n.assertPrivate)(y, g, "HDNodeVoidWallet"),
                (0,
                n.defineProperties)(this, {
                    publicKey: _
                });
                const F = (0,
                n.dataSlice)((0,
                t.ripemd160)((0,
                t.sha256)(_)), 0, 4);
                (0,
                n.defineProperties)(this, {
                    publicKey: _,
                    fingerprint: F,
                    parentFingerprint: O,
                    chainCode: L,
                    path: U,
                    index: $,
                    depth: B
                })
            }
            connect(y) {
                return new x(g,this.address,this.publicKey,this.parentFingerprint,this.chainCode,this.path,this.index,this.depth,y)
            }
            get extendedKey() {
                return (0,
                n.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
                    operation: "extendedKey"
                }),
                u((0,
                n.concat)(["0x0488B21E", c(this.depth, 1), this.parentFingerprint, c(this.index, 4), this.chainCode, this.publicKey]))
            }
            hasPath() {
                return this.path != null
            }
            deriveChild(y) {
                const k = (0,
                n.getNumber)(y, "index");
                (0,
                n.assertArgument)(k <= 4294967295, "invalid index", "index", k);
                let _ = this.path;
                _ && (_ += "/" + (k & 2147483647),
                k & l && (_ += "'"));
                const {IR: O, IL: L} = P(k, this.chainCode, this.publicKey, null)
                  , U = t.SigningKey.addPoints(L, this.publicKey, !0)
                  , $ = (0,
                r.computeAddress)(U);
                return new x(g,$,U,this.fingerprint,(0,
                n.hexlify)(O),_,k,this.depth + 1,this.provider)
            }
            derivePath(y) {
                return v(this, y)
            }
        }
        e.HDNodeVoidWallet = x;
        function a(A) {
            const R = (0,
            n.getNumber)(A, "index");
            return (0,
            n.assertArgument)(R >= 0 && R < l, "invalid account index", "index", R),
            `m/44'/60'/${R}'/0/0`
        }
        e.getAccountPath = a;
        function E(A) {
            const R = (0,
            n.getNumber)(A, "index");
            return (0,
            n.assertArgument)(R >= 0 && R < l, "invalid account index", "index", R),
            `m/44'/60'/0'/0/${R}`
        }
        e.getIndexedAccountPath = E
    }(li)),
    li
}
var Er = {}, Jc;
function vl() {
    if (Jc)
        return Er;
    Jc = 1,
    Object.defineProperty(Er, "__esModule", {
        value: !0
    }),
    Er.decryptCrowdsaleJson = Er.isCrowdsaleJson = void 0;
    const e = xl()
      , t = tt()
      , s = st()
      , r = qt()
      , n = Be()
      , d = wl();
    function h(f) {
        try {
            if (JSON.parse(f).encseed)
                return !0
        } catch {}
        return !1
    }
    Er.isCrowdsaleJson = h;
    function m(f, i) {
        const l = JSON.parse(f)
          , p = (0,
        d.getPassword)(i)
          , o = (0,
        t.getAddress)((0,
        d.spelunk)(l, "ethaddr:string!"))
          , c = (0,
        d.looseArrayify)((0,
        d.spelunk)(l, "encseed:string!"));
        (0,
        n.assertArgument)(c && c.length % 16 === 0, "invalid encseed", "json", f);
        const u = (0,
        n.getBytes)((0,
        s.pbkdf2)(p, p, 2e3, 32, "sha256")).slice(0, 16)
          , g = c.slice(0, 16)
          , P = c.slice(16)
          , v = new e.CBC(u,g)
          , b = (0,
        e.pkcs7Strip)((0,
        n.getBytes)(v.decrypt(P)));
        let x = "";
        for (let a = 0; a < b.length; a++)
            x += String.fromCharCode(b[a]);
        return {
            address: o,
            privateKey: (0,
            r.id)(x)
        }
    }
    return Er.decryptCrowdsaleJson = m,
    Er
}
var Vn = {}, Qc;
function Cf() {
    var i, Ni;
    if (Qc)
        return Vn;
    Qc = 1,
    Object.defineProperty(Vn, "__esModule", {
        value: !0
    }),
    Vn.Wallet = void 0;
    const e = st()
      , t = Be()
      , s = to()
      , r = Al()
      , n = vl()
      , d = so()
      , h = no();
    function m(o) {
        return new Promise(c => {
            setTimeout( () => {
                c()
            }
            , o)
        }
        )
    }
    const p = class p extends s.BaseWallet {
        constructor(c, u) {
            typeof c == "string" && !c.startsWith("0x") && (c = "0x" + c);
            let g = typeof c == "string" ? new e.SigningKey(c) : c;
            super(g, u)
        }
        connect(c) {
            return new p(this.signingKey,c)
        }
        async encrypt(c, u) {
            const g = {
                address: this.address,
                privateKey: this.privateKey
            };
            return await (0,
            d.encryptKeystoreJson)(g, c, {
                progressCallback: u
            })
        }
        encryptSync(c) {
            const u = {
                address: this.address,
                privateKey: this.privateKey
            };
            return (0,
            d.encryptKeystoreJsonSync)(u, c)
        }
        static async fromEncryptedJson(c, u, g) {
            var v;
            let P = null;
            return (0,
            d.isKeystoreJson)(c) ? P = await (0,
            d.decryptKeystoreJson)(c, u, g) : (0,
            n.isCrowdsaleJson)(c) && (g && (g(0),
            await m(0)),
            P = (0,
            n.decryptCrowdsaleJson)(c, u),
            g && (g(1),
            await m(0))),
            we(v = p, i, Ni).call(v, P)
        }
        static fromEncryptedJsonSync(c, u) {
            var P;
            let g = null;
            return (0,
            d.isKeystoreJson)(c) ? g = (0,
            d.decryptKeystoreJsonSync)(c, u) : (0,
            n.isCrowdsaleJson)(c) ? g = (0,
            n.decryptCrowdsaleJson)(c, u) : (0,
            t.assertArgument)(!1, "invalid JSON wallet", "json", "[ REDACTED ]"),
            we(P = p, i, Ni).call(P, g)
        }
        static createRandom(c) {
            const u = r.HDNodeWallet.createRandom();
            return c ? u.connect(c) : u
        }
        static fromPhrase(c, u) {
            const g = r.HDNodeWallet.fromPhrase(c);
            return u ? g.connect(u) : g
        }
    }
    ;
    i = new WeakSet,
    Ni = function(c) {
        if ((0,
        t.assertArgument)(c, "invalid JSON wallet", "json", "[ REDACTED ]"),
        "mnemonic"in c && c.mnemonic && c.mnemonic.locale === "en") {
            const g = h.Mnemonic.fromEntropy(c.mnemonic.entropy)
              , P = r.HDNodeWallet.fromMnemonic(g, c.mnemonic.path);
            if (P.address === c.address && P.privateKey === c.privateKey)
                return P;
            console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key")
        }
        const u = new p(c.privateKey);
        return (0,
        t.assertArgument)(u.address === c.address, "address/privateKey mismatch", "json", "[ REDACTED ]"),
        u
    }
    ,
    he(p, i);
    let f = p;
    return Vn.Wallet = f,
    Vn
}
var Wc;
function Nf() {
    return Wc || (Wc = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.Wallet = e.Mnemonic = e.encryptKeystoreJsonSync = e.encryptKeystoreJson = e.decryptKeystoreJson = e.decryptKeystoreJsonSync = e.isKeystoreJson = e.decryptCrowdsaleJson = e.isCrowdsaleJson = e.HDNodeVoidWallet = e.HDNodeWallet = e.getIndexedAccountPath = e.getAccountPath = e.defaultPath = e.BaseWallet = void 0;
        var t = to();
        Object.defineProperty(e, "BaseWallet", {
            enumerable: !0,
            get: function() {
                return t.BaseWallet
            }
        });
        var s = Al();
        Object.defineProperty(e, "defaultPath", {
            enumerable: !0,
            get: function() {
                return s.defaultPath
            }
        }),
        Object.defineProperty(e, "getAccountPath", {
            enumerable: !0,
            get: function() {
                return s.getAccountPath
            }
        }),
        Object.defineProperty(e, "getIndexedAccountPath", {
            enumerable: !0,
            get: function() {
                return s.getIndexedAccountPath
            }
        }),
        Object.defineProperty(e, "HDNodeWallet", {
            enumerable: !0,
            get: function() {
                return s.HDNodeWallet
            }
        }),
        Object.defineProperty(e, "HDNodeVoidWallet", {
            enumerable: !0,
            get: function() {
                return s.HDNodeVoidWallet
            }
        });
        var r = vl();
        Object.defineProperty(e, "isCrowdsaleJson", {
            enumerable: !0,
            get: function() {
                return r.isCrowdsaleJson
            }
        }),
        Object.defineProperty(e, "decryptCrowdsaleJson", {
            enumerable: !0,
            get: function() {
                return r.decryptCrowdsaleJson
            }
        });
        var n = so();
        Object.defineProperty(e, "isKeystoreJson", {
            enumerable: !0,
            get: function() {
                return n.isKeystoreJson
            }
        }),
        Object.defineProperty(e, "decryptKeystoreJsonSync", {
            enumerable: !0,
            get: function() {
                return n.decryptKeystoreJsonSync
            }
        }),
        Object.defineProperty(e, "decryptKeystoreJson", {
            enumerable: !0,
            get: function() {
                return n.decryptKeystoreJson
            }
        }),
        Object.defineProperty(e, "encryptKeystoreJson", {
            enumerable: !0,
            get: function() {
                return n.encryptKeystoreJson
            }
        }),
        Object.defineProperty(e, "encryptKeystoreJsonSync", {
            enumerable: !0,
            get: function() {
                return n.encryptKeystoreJsonSync
            }
        });
        var d = no();
        Object.defineProperty(e, "Mnemonic", {
            enumerable: !0,
            get: function() {
                return d.Mnemonic
            }
        });
        var h = Cf();
        Object.defineProperty(e, "Wallet", {
            enumerable: !0,
            get: function() {
                return h.Wallet
            }
        })
    }(ui)),
    ui
}
var fi = {}, Jn = {}, Qn = {}, Wn = {}, Yc;
function Rf() {
    if (Yc)
        return Wn;
    Yc = 1,
    Object.defineProperty(Wn, "__esModule", {
        value: !0
    }),
    Wn.decodeBits = void 0;
    const e = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
    function t(s, r) {
        const n = (1 << s) - 1
          , d = [];
        let h = 0
          , m = 0
          , f = 0;
        for (let i = 0; i < r.length; i++)
            for (h = h << 6 | e.indexOf(r[i]),
            m += 6; m >= s; ) {
                const l = h >> m - s;
                h &= (1 << m - s) - 1,
                m -= s,
                l === 0 ? f += n : (d.push(l + f),
                f = 0)
            }
        return d
    }
    return Wn.decodeBits = t,
    Wn
}
var Zc;
function If() {
    if (Zc)
        return Qn;
    Zc = 1,
    Object.defineProperty(Qn, "__esModule", {
        value: !0
    }),
    Qn.decodeOwlA = void 0;
    const e = Be()
      , t = Rf()
      , s = gl();
    function r(n, d) {
        let h = (0,
        s.decodeOwl)(n).join(",");
        return d.split(/,/g).forEach(m => {
            const f = m.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
            (0,
            e.assertArgument)(f !== null, "internal error parsing accents", "accents", d);
            let i = 0;
            const l = (0,
            t.decodeBits)(parseInt(f[3]), f[4])
              , p = parseInt(f[2])
              , o = new RegExp(`([${f[1]}])`,"g");
            h = h.replace(o, (c, u) => (--l[i] === 0 && (u = String.fromCharCode(u.charCodeAt(0), p),
            i++),
            u))
        }
        ),
        h.split(",")
    }
    return Qn.decodeOwlA = r,
    Qn
}
var Xc;
function jf() {
    var r;
    if (Xc)
        return Jn;
    Xc = 1,
    Object.defineProperty(Jn, "__esModule", {
        value: !0
    }),
    Jn.WordlistOwlA = void 0;
    const e = ro()
      , t = If();
    class s extends e.WordlistOwl {
        constructor(h, m, f, i) {
            super(h, m, i);
            he(this, r);
            Q(this, r, f)
        }
        get _accent() {
            return j(this, r)
        }
        _decodeWords() {
            return (0,
            t.decodeOwlA)(this._data, this._accent)
        }
    }
    return r = new WeakMap,
    Jn.WordlistOwlA = s,
    Jn
}
var Yn = {}, eu;
function Mf() {
    if (eu)
        return Yn;
    eu = 1,
    Object.defineProperty(Yn, "__esModule", {
        value: !0
    }),
    Yn.wordlists = void 0;
    const e = Ns();
    return Yn.wordlists = {
        en: e.LangEn.wordlist()
    },
    Yn
}
var tu;
function Lf() {
    return tu || (tu = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.wordlists = e.WordlistOwlA = e.WordlistOwl = e.LangEn = e.Wordlist = void 0;
        var t = ml();
        Object.defineProperty(e, "Wordlist", {
            enumerable: !0,
            get: function() {
                return t.Wordlist
            }
        });
        var s = Ns();
        Object.defineProperty(e, "LangEn", {
            enumerable: !0,
            get: function() {
                return s.LangEn
            }
        });
        var r = ro();
        Object.defineProperty(e, "WordlistOwl", {
            enumerable: !0,
            get: function() {
                return r.WordlistOwl
            }
        });
        var n = jf();
        Object.defineProperty(e, "WordlistOwlA", {
            enumerable: !0,
            get: function() {
                return n.WordlistOwlA
            }
        });
        var d = Mf();
        Object.defineProperty(e, "wordlists", {
            enumerable: !0,
            get: function() {
                return d.wordlists
            }
        })
    }(fi)),
    fi
}
var ru;
function nu() {
    return ru || (ru = 1,
    function(e) {
        Object.defineProperty(e, "__esModule", {
            value: !0
        }),
        e.ripemd160 = e.keccak256 = e.randomBytes = e.computeHmac = e.UndecodedEventLog = e.EventLog = e.ContractUnknownEventPayload = e.ContractTransactionResponse = e.ContractTransactionReceipt = e.ContractEventPayload = e.ContractFactory = e.Contract = e.BaseContract = e.MessagePrefix = e.EtherSymbol = e.ZeroHash = e.N = e.MaxInt256 = e.MinInt256 = e.MaxUint256 = e.WeiPerEther = e.ZeroAddress = e.resolveAddress = e.isAddress = e.isAddressable = e.getCreate2Address = e.getCreateAddress = e.getIcapAddress = e.getAddress = e.Typed = e.TransactionDescription = e.Result = e.LogDescription = e.Interface = e.Indexed = e.ErrorDescription = e.checkResultErrors = e.StructFragment = e.ParamType = e.NamedFragment = e.FunctionFragment = e.FallbackFragment = e.Fragment = e.EventFragment = e.ErrorFragment = e.ConstructorFragment = e.AbiCoder = e.encodeBytes32String = e.decodeBytes32String = e.version = void 0,
        e.WebSocketProvider = e.SocketProvider = e.IpcSocketProvider = e.QuickNodeProvider = e.PocketProvider = e.InfuraWebSocketProvider = e.InfuraProvider = e.EtherscanProvider = e.CloudflareProvider = e.ChainstackProvider = e.BlockscoutProvider = e.AnkrProvider = e.AlchemyProvider = e.BrowserProvider = e.JsonRpcSigner = e.JsonRpcProvider = e.JsonRpcApiProvider = e.FallbackProvider = e.AbstractProvider = e.VoidSigner = e.NonceManager = e.AbstractSigner = e.TransactionResponse = e.TransactionReceipt = e.Log = e.FeeData = e.Block = e.getDefaultProvider = e.verifyTypedData = e.TypedDataEncoder = e.solidityPackedSha256 = e.solidityPackedKeccak256 = e.solidityPacked = e.verifyMessage = e.hashMessage = e.verifyAuthorization = e.hashAuthorization = e.dnsEncode = e.namehash = e.isValidName = e.ensNormalize = e.id = e.SigningKey = e.Signature = e.lock = e.scryptSync = e.scrypt = e.pbkdf2 = e.sha512 = e.sha256 = void 0,
        e.FetchCancelSignal = e.FetchResponse = e.FetchRequest = e.EventPayload = e.isError = e.isCallException = e.makeError = e.assertPrivate = e.assertNormalize = e.assertArgumentCount = e.assertArgument = e.assert = e.resolveProperties = e.defineProperties = e.zeroPadValue = e.zeroPadBytes = e.stripZerosLeft = e.isBytesLike = e.isHexString = e.hexlify = e.getBytesCopy = e.getBytes = e.dataSlice = e.dataLength = e.concat = e.encodeBase64 = e.decodeBase64 = e.encodeBase58 = e.decodeBase58 = e.Transaction = e.recoverAddress = e.computeAddress = e.authorizationify = e.accessListify = e.showThrottleMessage = e.copyRequest = e.UnmanagedSubscriber = e.SocketSubscriber = e.SocketPendingSubscriber = e.SocketEventSubscriber = e.SocketBlockSubscriber = e.MulticoinProviderPlugin = e.NetworkPlugin = e.GasCostPlugin = e.FetchUrlFeeDataNetworkPlugin = e.FeeDataNetworkPlugin = e.EtherscanPlugin = e.EnsPlugin = e.Network = e.EnsResolver = void 0,
        e.wordlists = e.WordlistOwlA = e.WordlistOwl = e.LangEn = e.Wordlist = e.encryptKeystoreJsonSync = e.encryptKeystoreJson = e.decryptKeystoreJson = e.decryptKeystoreJsonSync = e.decryptCrowdsaleJson = e.isKeystoreJson = e.isCrowdsaleJson = e.getIndexedAccountPath = e.getAccountPath = e.defaultPath = e.Wallet = e.HDNodeVoidWallet = e.HDNodeWallet = e.BaseWallet = e.Mnemonic = e.uuidV4 = e.encodeRlp = e.decodeRlp = e.Utf8ErrorFuncs = e.toUtf8String = e.toUtf8CodePoints = e.toUtf8Bytes = e.parseUnits = e.formatUnits = e.parseEther = e.formatEther = e.mask = e.toTwos = e.fromTwos = e.toQuantity = e.toNumber = e.toBeHex = e.toBigInt = e.toBeArray = e.getUint = e.getNumber = e.getBigInt = e.FixedNumber = void 0;
        var t = $i();
        Object.defineProperty(e, "version", {
            enumerable: !0,
            get: function() {
                return t.version
            }
        });
        var s = os();
        Object.defineProperty(e, "decodeBytes32String", {
            enumerable: !0,
            get: function() {
                return s.decodeBytes32String
            }
        }),
        Object.defineProperty(e, "encodeBytes32String", {
            enumerable: !0,
            get: function() {
                return s.encodeBytes32String
            }
        }),
        Object.defineProperty(e, "AbiCoder", {
            enumerable: !0,
            get: function() {
                return s.AbiCoder
            }
        }),
        Object.defineProperty(e, "ConstructorFragment", {
            enumerable: !0,
            get: function() {
                return s.ConstructorFragment
            }
        }),
        Object.defineProperty(e, "ErrorFragment", {
            enumerable: !0,
            get: function() {
                return s.ErrorFragment
            }
        }),
        Object.defineProperty(e, "EventFragment", {
            enumerable: !0,
            get: function() {
                return s.EventFragment
            }
        }),
        Object.defineProperty(e, "Fragment", {
            enumerable: !0,
            get: function() {
                return s.Fragment
            }
        }),
        Object.defineProperty(e, "FallbackFragment", {
            enumerable: !0,
            get: function() {
                return s.FallbackFragment
            }
        }),
        Object.defineProperty(e, "FunctionFragment", {
            enumerable: !0,
            get: function() {
                return s.FunctionFragment
            }
        }),
        Object.defineProperty(e, "NamedFragment", {
            enumerable: !0,
            get: function() {
                return s.NamedFragment
            }
        }),
        Object.defineProperty(e, "ParamType", {
            enumerable: !0,
            get: function() {
                return s.ParamType
            }
        }),
        Object.defineProperty(e, "StructFragment", {
            enumerable: !0,
            get: function() {
                return s.StructFragment
            }
        }),
        Object.defineProperty(e, "checkResultErrors", {
            enumerable: !0,
            get: function() {
                return s.checkResultErrors
            }
        }),
        Object.defineProperty(e, "ErrorDescription", {
            enumerable: !0,
            get: function() {
                return s.ErrorDescription
            }
        }),
        Object.defineProperty(e, "Indexed", {
            enumerable: !0,
            get: function() {
                return s.Indexed
            }
        }),
        Object.defineProperty(e, "Interface", {
            enumerable: !0,
            get: function() {
                return s.Interface
            }
        }),
        Object.defineProperty(e, "LogDescription", {
            enumerable: !0,
            get: function() {
                return s.LogDescription
            }
        }),
        Object.defineProperty(e, "Result", {
            enumerable: !0,
            get: function() {
                return s.Result
            }
        }),
        Object.defineProperty(e, "TransactionDescription", {
            enumerable: !0,
            get: function() {
                return s.TransactionDescription
            }
        }),
        Object.defineProperty(e, "Typed", {
            enumerable: !0,
            get: function() {
                return s.Typed
            }
        });
        var r = tt();
        Object.defineProperty(e, "getAddress", {
            enumerable: !0,
            get: function() {
                return r.getAddress
            }
        }),
        Object.defineProperty(e, "getIcapAddress", {
            enumerable: !0,
            get: function() {
                return r.getIcapAddress
            }
        }),
        Object.defineProperty(e, "getCreateAddress", {
            enumerable: !0,
            get: function() {
                return r.getCreateAddress
            }
        }),
        Object.defineProperty(e, "getCreate2Address", {
            enumerable: !0,
            get: function() {
                return r.getCreate2Address
            }
        }),
        Object.defineProperty(e, "isAddressable", {
            enumerable: !0,
            get: function() {
                return r.isAddressable
            }
        }),
        Object.defineProperty(e, "isAddress", {
            enumerable: !0,
            get: function() {
                return r.isAddress
            }
        }),
        Object.defineProperty(e, "resolveAddress", {
            enumerable: !0,
            get: function() {
                return r.resolveAddress
            }
        });
        var n = is();
        Object.defineProperty(e, "ZeroAddress", {
            enumerable: !0,
            get: function() {
                return n.ZeroAddress
            }
        }),
        Object.defineProperty(e, "WeiPerEther", {
            enumerable: !0,
            get: function() {
                return n.WeiPerEther
            }
        }),
        Object.defineProperty(e, "MaxUint256", {
            enumerable: !0,
            get: function() {
                return n.MaxUint256
            }
        }),
        Object.defineProperty(e, "MinInt256", {
            enumerable: !0,
            get: function() {
                return n.MinInt256
            }
        }),
        Object.defineProperty(e, "MaxInt256", {
            enumerable: !0,
            get: function() {
                return n.MaxInt256
            }
        }),
        Object.defineProperty(e, "N", {
            enumerable: !0,
            get: function() {
                return n.N
            }
        }),
        Object.defineProperty(e, "ZeroHash", {
            enumerable: !0,
            get: function() {
                return n.ZeroHash
            }
        }),
        Object.defineProperty(e, "EtherSymbol", {
            enumerable: !0,
            get: function() {
                return n.EtherSymbol
            }
        }),
        Object.defineProperty(e, "MessagePrefix", {
            enumerable: !0,
            get: function() {
                return n.MessagePrefix
            }
        });
        var d = Cs();
        Object.defineProperty(e, "BaseContract", {
            enumerable: !0,
            get: function() {
                return d.BaseContract
            }
        }),
        Object.defineProperty(e, "Contract", {
            enumerable: !0,
            get: function() {
                return d.Contract
            }
        }),
        Object.defineProperty(e, "ContractFactory", {
            enumerable: !0,
            get: function() {
                return d.ContractFactory
            }
        }),
        Object.defineProperty(e, "ContractEventPayload", {
            enumerable: !0,
            get: function() {
                return d.ContractEventPayload
            }
        }),
        Object.defineProperty(e, "ContractTransactionReceipt", {
            enumerable: !0,
            get: function() {
                return d.ContractTransactionReceipt
            }
        }),
        Object.defineProperty(e, "ContractTransactionResponse", {
            enumerable: !0,
            get: function() {
                return d.ContractTransactionResponse
            }
        }),
        Object.defineProperty(e, "ContractUnknownEventPayload", {
            enumerable: !0,
            get: function() {
                return d.ContractUnknownEventPayload
            }
        }),
        Object.defineProperty(e, "EventLog", {
            enumerable: !0,
            get: function() {
                return d.EventLog
            }
        }),
        Object.defineProperty(e, "UndecodedEventLog", {
            enumerable: !0,
            get: function() {
                return d.UndecodedEventLog
            }
        });
        var h = st();
        Object.defineProperty(e, "computeHmac", {
            enumerable: !0,
            get: function() {
                return h.computeHmac
            }
        }),
        Object.defineProperty(e, "randomBytes", {
            enumerable: !0,
            get: function() {
                return h.randomBytes
            }
        }),
        Object.defineProperty(e, "keccak256", {
            enumerable: !0,
            get: function() {
                return h.keccak256
            }
        }),
        Object.defineProperty(e, "ripemd160", {
            enumerable: !0,
            get: function() {
                return h.ripemd160
            }
        }),
        Object.defineProperty(e, "sha256", {
            enumerable: !0,
            get: function() {
                return h.sha256
            }
        }),
        Object.defineProperty(e, "sha512", {
            enumerable: !0,
            get: function() {
                return h.sha512
            }
        }),
        Object.defineProperty(e, "pbkdf2", {
            enumerable: !0,
            get: function() {
                return h.pbkdf2
            }
        }),
        Object.defineProperty(e, "scrypt", {
            enumerable: !0,
            get: function() {
                return h.scrypt
            }
        }),
        Object.defineProperty(e, "scryptSync", {
            enumerable: !0,
            get: function() {
                return h.scryptSync
            }
        }),
        Object.defineProperty(e, "lock", {
            enumerable: !0,
            get: function() {
                return h.lock
            }
        }),
        Object.defineProperty(e, "Signature", {
            enumerable: !0,
            get: function() {
                return h.Signature
            }
        }),
        Object.defineProperty(e, "SigningKey", {
            enumerable: !0,
            get: function() {
                return h.SigningKey
            }
        });
        var m = qt();
        Object.defineProperty(e, "id", {
            enumerable: !0,
            get: function() {
                return m.id
            }
        }),
        Object.defineProperty(e, "ensNormalize", {
            enumerable: !0,
            get: function() {
                return m.ensNormalize
            }
        }),
        Object.defineProperty(e, "isValidName", {
            enumerable: !0,
            get: function() {
                return m.isValidName
            }
        }),
        Object.defineProperty(e, "namehash", {
            enumerable: !0,
            get: function() {
                return m.namehash
            }
        }),
        Object.defineProperty(e, "dnsEncode", {
            enumerable: !0,
            get: function() {
                return m.dnsEncode
            }
        }),
        Object.defineProperty(e, "hashAuthorization", {
            enumerable: !0,
            get: function() {
                return m.hashAuthorization
            }
        }),
        Object.defineProperty(e, "verifyAuthorization", {
            enumerable: !0,
            get: function() {
                return m.verifyAuthorization
            }
        }),
        Object.defineProperty(e, "hashMessage", {
            enumerable: !0,
            get: function() {
                return m.hashMessage
            }
        }),
        Object.defineProperty(e, "verifyMessage", {
            enumerable: !0,
            get: function() {
                return m.verifyMessage
            }
        }),
        Object.defineProperty(e, "solidityPacked", {
            enumerable: !0,
            get: function() {
                return m.solidityPacked
            }
        }),
        Object.defineProperty(e, "solidityPackedKeccak256", {
            enumerable: !0,
            get: function() {
                return m.solidityPackedKeccak256
            }
        }),
        Object.defineProperty(e, "solidityPackedSha256", {
            enumerable: !0,
            get: function() {
                return m.solidityPackedSha256
            }
        }),
        Object.defineProperty(e, "TypedDataEncoder", {
            enumerable: !0,
            get: function() {
                return m.TypedDataEncoder
            }
        }),
        Object.defineProperty(e, "verifyTypedData", {
            enumerable: !0,
            get: function() {
                return m.verifyTypedData
            }
        });
        var f = eo();
        Object.defineProperty(e, "getDefaultProvider", {
            enumerable: !0,
            get: function() {
                return f.getDefaultProvider
            }
        }),
        Object.defineProperty(e, "Block", {
            enumerable: !0,
            get: function() {
                return f.Block
            }
        }),
        Object.defineProperty(e, "FeeData", {
            enumerable: !0,
            get: function() {
                return f.FeeData
            }
        }),
        Object.defineProperty(e, "Log", {
            enumerable: !0,
            get: function() {
                return f.Log
            }
        }),
        Object.defineProperty(e, "TransactionReceipt", {
            enumerable: !0,
            get: function() {
                return f.TransactionReceipt
            }
        }),
        Object.defineProperty(e, "TransactionResponse", {
            enumerable: !0,
            get: function() {
                return f.TransactionResponse
            }
        }),
        Object.defineProperty(e, "AbstractSigner", {
            enumerable: !0,
            get: function() {
                return f.AbstractSigner
            }
        }),
        Object.defineProperty(e, "NonceManager", {
            enumerable: !0,
            get: function() {
                return f.NonceManager
            }
        }),
        Object.defineProperty(e, "VoidSigner", {
            enumerable: !0,
            get: function() {
                return f.VoidSigner
            }
        }),
        Object.defineProperty(e, "AbstractProvider", {
            enumerable: !0,
            get: function() {
                return f.AbstractProvider
            }
        }),
        Object.defineProperty(e, "FallbackProvider", {
            enumerable: !0,
            get: function() {
                return f.FallbackProvider
            }
        }),
        Object.defineProperty(e, "JsonRpcApiProvider", {
            enumerable: !0,
            get: function() {
                return f.JsonRpcApiProvider
            }
        }),
        Object.defineProperty(e, "JsonRpcProvider", {
            enumerable: !0,
            get: function() {
                return f.JsonRpcProvider
            }
        }),
        Object.defineProperty(e, "JsonRpcSigner", {
            enumerable: !0,
            get: function() {
                return f.JsonRpcSigner
            }
        }),
        Object.defineProperty(e, "BrowserProvider", {
            enumerable: !0,
            get: function() {
                return f.BrowserProvider
            }
        }),
        Object.defineProperty(e, "AlchemyProvider", {
            enumerable: !0,
            get: function() {
                return f.AlchemyProvider
            }
        }),
        Object.defineProperty(e, "AnkrProvider", {
            enumerable: !0,
            get: function() {
                return f.AnkrProvider
            }
        }),
        Object.defineProperty(e, "BlockscoutProvider", {
            enumerable: !0,
            get: function() {
                return f.BlockscoutProvider
            }
        }),
        Object.defineProperty(e, "ChainstackProvider", {
            enumerable: !0,
            get: function() {
                return f.ChainstackProvider
            }
        }),
        Object.defineProperty(e, "CloudflareProvider", {
            enumerable: !0,
            get: function() {
                return f.CloudflareProvider
            }
        }),
        Object.defineProperty(e, "EtherscanProvider", {
            enumerable: !0,
            get: function() {
                return f.EtherscanProvider
            }
        }),
        Object.defineProperty(e, "InfuraProvider", {
            enumerable: !0,
            get: function() {
                return f.InfuraProvider
            }
        }),
        Object.defineProperty(e, "InfuraWebSocketProvider", {
            enumerable: !0,
            get: function() {
                return f.InfuraWebSocketProvider
            }
        }),
        Object.defineProperty(e, "PocketProvider", {
            enumerable: !0,
            get: function() {
                return f.PocketProvider
            }
        }),
        Object.defineProperty(e, "QuickNodeProvider", {
            enumerable: !0,
            get: function() {
                return f.QuickNodeProvider
            }
        }),
        Object.defineProperty(e, "IpcSocketProvider", {
            enumerable: !0,
            get: function() {
                return f.IpcSocketProvider
            }
        }),
        Object.defineProperty(e, "SocketProvider", {
            enumerable: !0,
            get: function() {
                return f.SocketProvider
            }
        }),
        Object.defineProperty(e, "WebSocketProvider", {
            enumerable: !0,
            get: function() {
                return f.WebSocketProvider
            }
        }),
        Object.defineProperty(e, "EnsResolver", {
            enumerable: !0,
            get: function() {
                return f.EnsResolver
            }
        }),
        Object.defineProperty(e, "Network", {
            enumerable: !0,
            get: function() {
                return f.Network
            }
        }),
        Object.defineProperty(e, "EnsPlugin", {
            enumerable: !0,
            get: function() {
                return f.EnsPlugin
            }
        }),
        Object.defineProperty(e, "EtherscanPlugin", {
            enumerable: !0,
            get: function() {
                return f.EtherscanPlugin
            }
        }),
        Object.defineProperty(e, "FeeDataNetworkPlugin", {
            enumerable: !0,
            get: function() {
                return f.FeeDataNetworkPlugin
            }
        }),
        Object.defineProperty(e, "FetchUrlFeeDataNetworkPlugin", {
            enumerable: !0,
            get: function() {
                return f.FetchUrlFeeDataNetworkPlugin
            }
        }),
        Object.defineProperty(e, "GasCostPlugin", {
            enumerable: !0,
            get: function() {
                return f.GasCostPlugin
            }
        }),
        Object.defineProperty(e, "NetworkPlugin", {
            enumerable: !0,
            get: function() {
                return f.NetworkPlugin
            }
        }),
        Object.defineProperty(e, "MulticoinProviderPlugin", {
            enumerable: !0,
            get: function() {
                return f.MulticoinProviderPlugin
            }
        }),
        Object.defineProperty(e, "SocketBlockSubscriber", {
            enumerable: !0,
            get: function() {
                return f.SocketBlockSubscriber
            }
        }),
        Object.defineProperty(e, "SocketEventSubscriber", {
            enumerable: !0,
            get: function() {
                return f.SocketEventSubscriber
            }
        }),
        Object.defineProperty(e, "SocketPendingSubscriber", {
            enumerable: !0,
            get: function() {
                return f.SocketPendingSubscriber
            }
        }),
        Object.defineProperty(e, "SocketSubscriber", {
            enumerable: !0,
            get: function() {
                return f.SocketSubscriber
            }
        }),
        Object.defineProperty(e, "UnmanagedSubscriber", {
            enumerable: !0,
            get: function() {
                return f.UnmanagedSubscriber
            }
        }),
        Object.defineProperty(e, "copyRequest", {
            enumerable: !0,
            get: function() {
                return f.copyRequest
            }
        }),
        Object.defineProperty(e, "showThrottleMessage", {
            enumerable: !0,
            get: function() {
                return f.showThrottleMessage
            }
        });
        var i = lt();
        Object.defineProperty(e, "accessListify", {
            enumerable: !0,
            get: function() {
                return i.accessListify
            }
        }),
        Object.defineProperty(e, "authorizationify", {
            enumerable: !0,
            get: function() {
                return i.authorizationify
            }
        }),
        Object.defineProperty(e, "computeAddress", {
            enumerable: !0,
            get: function() {
                return i.computeAddress
            }
        }),
        Object.defineProperty(e, "recoverAddress", {
            enumerable: !0,
            get: function() {
                return i.recoverAddress
            }
        }),
        Object.defineProperty(e, "Transaction", {
            enumerable: !0,
            get: function() {
                return i.Transaction
            }
        });
        var l = Be();
        Object.defineProperty(e, "decodeBase58", {
            enumerable: !0,
            get: function() {
                return l.decodeBase58
            }
        }),
        Object.defineProperty(e, "encodeBase58", {
            enumerable: !0,
            get: function() {
                return l.encodeBase58
            }
        }),
        Object.defineProperty(e, "decodeBase64", {
            enumerable: !0,
            get: function() {
                return l.decodeBase64
            }
        }),
        Object.defineProperty(e, "encodeBase64", {
            enumerable: !0,
            get: function() {
                return l.encodeBase64
            }
        }),
        Object.defineProperty(e, "concat", {
            enumerable: !0,
            get: function() {
                return l.concat
            }
        }),
        Object.defineProperty(e, "dataLength", {
            enumerable: !0,
            get: function() {
                return l.dataLength
            }
        }),
        Object.defineProperty(e, "dataSlice", {
            enumerable: !0,
            get: function() {
                return l.dataSlice
            }
        }),
        Object.defineProperty(e, "getBytes", {
            enumerable: !0,
            get: function() {
                return l.getBytes
            }
        }),
        Object.defineProperty(e, "getBytesCopy", {
            enumerable: !0,
            get: function() {
                return l.getBytesCopy
            }
        }),
        Object.defineProperty(e, "hexlify", {
            enumerable: !0,
            get: function() {
                return l.hexlify
            }
        }),
        Object.defineProperty(e, "isHexString", {
            enumerable: !0,
            get: function() {
                return l.isHexString
            }
        }),
        Object.defineProperty(e, "isBytesLike", {
            enumerable: !0,
            get: function() {
                return l.isBytesLike
            }
        }),
        Object.defineProperty(e, "stripZerosLeft", {
            enumerable: !0,
            get: function() {
                return l.stripZerosLeft
            }
        }),
        Object.defineProperty(e, "zeroPadBytes", {
            enumerable: !0,
            get: function() {
                return l.zeroPadBytes
            }
        }),
        Object.defineProperty(e, "zeroPadValue", {
            enumerable: !0,
            get: function() {
                return l.zeroPadValue
            }
        }),
        Object.defineProperty(e, "defineProperties", {
            enumerable: !0,
            get: function() {
                return l.defineProperties
            }
        }),
        Object.defineProperty(e, "resolveProperties", {
            enumerable: !0,
            get: function() {
                return l.resolveProperties
            }
        }),
        Object.defineProperty(e, "assert", {
            enumerable: !0,
            get: function() {
                return l.assert
            }
        }),
        Object.defineProperty(e, "assertArgument", {
            enumerable: !0,
            get: function() {
                return l.assertArgument
            }
        }),
        Object.defineProperty(e, "assertArgumentCount", {
            enumerable: !0,
            get: function() {
                return l.assertArgumentCount
            }
        }),
        Object.defineProperty(e, "assertNormalize", {
            enumerable: !0,
            get: function() {
                return l.assertNormalize
            }
        }),
        Object.defineProperty(e, "assertPrivate", {
            enumerable: !0,
            get: function() {
                return l.assertPrivate
            }
        }),
        Object.defineProperty(e, "makeError", {
            enumerable: !0,
            get: function() {
                return l.makeError
            }
        }),
        Object.defineProperty(e, "isCallException", {
            enumerable: !0,
            get: function() {
                return l.isCallException
            }
        }),
        Object.defineProperty(e, "isError", {
            enumerable: !0,
            get: function() {
                return l.isError
            }
        }),
        Object.defineProperty(e, "EventPayload", {
            enumerable: !0,
            get: function() {
                return l.EventPayload
            }
        }),
        Object.defineProperty(e, "FetchRequest", {
            enumerable: !0,
            get: function() {
                return l.FetchRequest
            }
        }),
        Object.defineProperty(e, "FetchResponse", {
            enumerable: !0,
            get: function() {
                return l.FetchResponse
            }
        }),
        Object.defineProperty(e, "FetchCancelSignal", {
            enumerable: !0,
            get: function() {
                return l.FetchCancelSignal
            }
        }),
        Object.defineProperty(e, "FixedNumber", {
            enumerable: !0,
            get: function() {
                return l.FixedNumber
            }
        }),
        Object.defineProperty(e, "getBigInt", {
            enumerable: !0,
            get: function() {
                return l.getBigInt
            }
        }),
        Object.defineProperty(e, "getNumber", {
            enumerable: !0,
            get: function() {
                return l.getNumber
            }
        }),
        Object.defineProperty(e, "getUint", {
            enumerable: !0,
            get: function() {
                return l.getUint
            }
        }),
        Object.defineProperty(e, "toBeArray", {
            enumerable: !0,
            get: function() {
                return l.toBeArray
            }
        }),
        Object.defineProperty(e, "toBigInt", {
            enumerable: !0,
            get: function() {
                return l.toBigInt
            }
        }),
        Object.defineProperty(e, "toBeHex", {
            enumerable: !0,
            get: function() {
                return l.toBeHex
            }
        }),
        Object.defineProperty(e, "toNumber", {
            enumerable: !0,
            get: function() {
                return l.toNumber
            }
        }),
        Object.defineProperty(e, "toQuantity", {
            enumerable: !0,
            get: function() {
                return l.toQuantity
            }
        }),
        Object.defineProperty(e, "fromTwos", {
            enumerable: !0,
            get: function() {
                return l.fromTwos
            }
        }),
        Object.defineProperty(e, "toTwos", {
            enumerable: !0,
            get: function() {
                return l.toTwos
            }
        }),
        Object.defineProperty(e, "mask", {
            enumerable: !0,
            get: function() {
                return l.mask
            }
        }),
        Object.defineProperty(e, "formatEther", {
            enumerable: !0,
            get: function() {
                return l.formatEther
            }
        }),
        Object.defineProperty(e, "parseEther", {
            enumerable: !0,
            get: function() {
                return l.parseEther
            }
        }),
        Object.defineProperty(e, "formatUnits", {
            enumerable: !0,
            get: function() {
                return l.formatUnits
            }
        }),
        Object.defineProperty(e, "parseUnits", {
            enumerable: !0,
            get: function() {
                return l.parseUnits
            }
        }),
        Object.defineProperty(e, "toUtf8Bytes", {
            enumerable: !0,
            get: function() {
                return l.toUtf8Bytes
            }
        }),
        Object.defineProperty(e, "toUtf8CodePoints", {
            enumerable: !0,
            get: function() {
                return l.toUtf8CodePoints
            }
        }),
        Object.defineProperty(e, "toUtf8String", {
            enumerable: !0,
            get: function() {
                return l.toUtf8String
            }
        }),
        Object.defineProperty(e, "Utf8ErrorFuncs", {
            enumerable: !0,
            get: function() {
                return l.Utf8ErrorFuncs
            }
        }),
        Object.defineProperty(e, "decodeRlp", {
            enumerable: !0,
            get: function() {
                return l.decodeRlp
            }
        }),
        Object.defineProperty(e, "encodeRlp", {
            enumerable: !0,
            get: function() {
                return l.encodeRlp
            }
        }),
        Object.defineProperty(e, "uuidV4", {
            enumerable: !0,
            get: function() {
                return l.uuidV4
            }
        });
        var p = Nf();
        Object.defineProperty(e, "Mnemonic", {
            enumerable: !0,
            get: function() {
                return p.Mnemonic
            }
        }),
        Object.defineProperty(e, "BaseWallet", {
            enumerable: !0,
            get: function() {
                return p.BaseWallet
            }
        }),
        Object.defineProperty(e, "HDNodeWallet", {
            enumerable: !0,
            get: function() {
                return p.HDNodeWallet
            }
        }),
        Object.defineProperty(e, "HDNodeVoidWallet", {
            enumerable: !0,
            get: function() {
                return p.HDNodeVoidWallet
            }
        }),
        Object.defineProperty(e, "Wallet", {
            enumerable: !0,
            get: function() {
                return p.Wallet
            }
        }),
        Object.defineProperty(e, "defaultPath", {
            enumerable: !0,
            get: function() {
                return p.defaultPath
            }
        }),
        Object.defineProperty(e, "getAccountPath", {
            enumerable: !0,
            get: function() {
                return p.getAccountPath
            }
        }),
        Object.defineProperty(e, "getIndexedAccountPath", {
            enumerable: !0,
            get: function() {
                return p.getIndexedAccountPath
            }
        }),
        Object.defineProperty(e, "isCrowdsaleJson", {
            enumerable: !0,
            get: function() {
                return p.isCrowdsaleJson
            }
        }),
        Object.defineProperty(e, "isKeystoreJson", {
            enumerable: !0,
            get: function() {
                return p.isKeystoreJson
            }
        }),
        Object.defineProperty(e, "decryptCrowdsaleJson", {
            enumerable: !0,
            get: function() {
                return p.decryptCrowdsaleJson
            }
        }),
        Object.defineProperty(e, "decryptKeystoreJsonSync", {
            enumerable: !0,
            get: function() {
                return p.decryptKeystoreJsonSync
            }
        }),
        Object.defineProperty(e, "decryptKeystoreJson", {
            enumerable: !0,
            get: function() {
                return p.decryptKeystoreJson
            }
        }),
        Object.defineProperty(e, "encryptKeystoreJson", {
            enumerable: !0,
            get: function() {
                return p.encryptKeystoreJson
            }
        }),
        Object.defineProperty(e, "encryptKeystoreJsonSync", {
            enumerable: !0,
            get: function() {
                return p.encryptKeystoreJsonSync
            }
        });
        var o = Lf();
        Object.defineProperty(e, "Wordlist", {
            enumerable: !0,
            get: function() {
                return o.Wordlist
            }
        }),
        Object.defineProperty(e, "LangEn", {
            enumerable: !0,
            get: function() {
                return o.LangEn
            }
        }),
        Object.defineProperty(e, "WordlistOwl", {
            enumerable: !0,
            get: function() {
                return o.WordlistOwl
            }
        }),
        Object.defineProperty(e, "WordlistOwlA", {
            enumerable: !0,
            get: function() {
                return o.WordlistOwlA
            }
        }),
        Object.defineProperty(e, "wordlists", {
            enumerable: !0,
            get: function() {
                return o.wordlists
            }
        })
    }(Ks)),
    Ks
}
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.ethers = void 0;
    const t = wd
      , s = t.__importStar(nu());
    e.ethers = s,
    t.__exportStar(nu(), e)
}
)(Hi);
Object.defineProperty(Gt, "__esModule", {
    value: !0
});
Gt.getAddress = Gt.hashMessage = Gt.verifyMessage = void 0;
const Sr = Hi;
let Ri = null
  , Ii = null
  , ji = null;
try {
    Ri = Sr.ethers.utils.verifyMessage,
    Ii = Sr.ethers.utils.hashMessage,
    ji = Sr.ethers.utils.getAddress
} catch {
    Ri = Sr.ethers.verifyMessage,
    Ii = Sr.ethers.hashMessage,
    ji = Sr.ethers.getAddress
}
Gt.verifyMessage = Ri;
Gt.hashMessage = Ii;
Gt.getAddress = ji;
var io = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.SiweErrorType = e.SiweError = e.VerifyOptsKeys = e.VerifyParamsKeys = void 0,
    e.VerifyParamsKeys = ["signature", "scheme", "domain", "nonce", "time"],
    e.VerifyOptsKeys = ["provider", "suppressExceptions", "verificationFallback"];
    class t {
        constructor(r, n, d) {
            this.type = r,
            this.expected = n,
            this.received = d
        }
    }
    e.SiweError = t,
    function(s) {
        s.EXPIRED_MESSAGE = "Expired message.",
        s.INVALID_DOMAIN = "Invalid domain.",
        s.SCHEME_MISMATCH = "Scheme does not match provided scheme for verification.",
        s.DOMAIN_MISMATCH = "Domain does not match provided domain for verification.",
        s.NONCE_MISMATCH = "Nonce does not match provided nonce for verification.",
        s.INVALID_ADDRESS = "Invalid address.",
        s.INVALID_URI = "URI does not conform to RFC 3986.",
        s.INVALID_NONCE = "Nonce size smaller then 8 characters or is not alphanumeric.",
        s.NOT_YET_VALID_MESSAGE = "Message is not valid yet.",
        s.INVALID_SIGNATURE = "Signature does not match address of the message.",
        s.INVALID_TIME_FORMAT = "Invalid time format.",
        s.INVALID_MESSAGE_VERSION = "Invalid message version.",
        s.UNABLE_TO_PARSE = "Unable to parse the message."
    }(e.SiweErrorType || (e.SiweErrorType = {}))
}
)(io);
var Tt = {}
  , El = {}
  , Rs = {}
  , Is = {};
Object.defineProperty(Is, "__esModule", {
    value: !0
});
Is.BrowserRandomSource = void 0;
const su = 65536;
class Uf {
    constructor() {
        this.isAvailable = !1,
        this.isInstantiated = !1;
        const t = typeof self < "u" ? self.crypto || self.msCrypto : null;
        t && t.getRandomValues !== void 0 && (this._crypto = t,
        this.isAvailable = !0,
        this.isInstantiated = !0)
    }
    randomBytes(t) {
        if (!this.isAvailable || !this._crypto)
            throw new Error("Browser random byte generator is not available.");
        const s = new Uint8Array(t);
        for (let r = 0; r < s.length; r += su)
            this._crypto.getRandomValues(s.subarray(r, r + Math.min(s.length - r, su)));
        return s
    }
}
Is.BrowserRandomSource = Uf;
var js = {}
  , Ms = {};
Object.defineProperty(Ms, "__esModule", {
    value: !0
});
function Ff(e) {
    for (var t = 0; t < e.length; t++)
        e[t] = 0;
    return e
}
Ms.wipe = Ff;
Object.defineProperty(js, "__esModule", {
    value: !0
});
js.NodeRandomSource = void 0;
const Df = Ms;
class Hf {
    constructor() {
        if (this.isAvailable = !1,
        this.isInstantiated = !1,
        typeof Ql < "u") {
            const t = Wl;
            t && t.randomBytes && (this._crypto = t,
            this.isAvailable = !0,
            this.isInstantiated = !0)
        }
    }
    randomBytes(t) {
        if (!this.isAvailable || !this._crypto)
            throw new Error("Node.js random byte generator is not available.");
        let s = this._crypto.randomBytes(t);
        if (s.length !== t)
            throw new Error("NodeRandomSource: got fewer bytes than requested");
        const r = new Uint8Array(t);
        for (let n = 0; n < r.length; n++)
            r[n] = s[n];
        return (0,
        Df.wipe)(s),
        r
    }
}
js.NodeRandomSource = Hf;
Object.defineProperty(Rs, "__esModule", {
    value: !0
});
Rs.SystemRandomSource = void 0;
const Gf = Is
  , $f = js;
class qf {
    constructor() {
        if (this.isAvailable = !1,
        this.name = "",
        this._source = new Gf.BrowserRandomSource,
        this._source.isAvailable) {
            this.isAvailable = !0,
            this.name = "Browser";
            return
        }
        if (this._source = new $f.NodeRandomSource,
        this._source.isAvailable) {
            this.isAvailable = !0,
            this.name = "Node";
            return
        }
    }
    randomBytes(t) {
        if (!this.isAvailable)
            throw new Error("System random byte generator is not available.");
        return this._source.randomBytes(t)
    }
}
Rs.SystemRandomSource = qf;
var Fe = {}
  , Pl = {};
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    });
    function t(m, f) {
        var i = m >>> 16 & 65535
          , l = m & 65535
          , p = f >>> 16 & 65535
          , o = f & 65535;
        return l * o + (i * o + l * p << 16 >>> 0) | 0
    }
    e.mul = Math.imul || t;
    function s(m, f) {
        return m + f | 0
    }
    e.add = s;
    function r(m, f) {
        return m - f | 0
    }
    e.sub = r;
    function n(m, f) {
        return m << f | m >>> 32 - f
    }
    e.rotl = n;
    function d(m, f) {
        return m << 32 - f | m >>> f
    }
    e.rotr = d;
    function h(m) {
        return typeof m == "number" && isFinite(m) && Math.floor(m) === m
    }
    e.isInteger = Number.isInteger || h,
    e.MAX_SAFE_INTEGER = 9007199254740991,
    e.isSafeInteger = function(m) {
        return e.isInteger(m) && m >= -e.MAX_SAFE_INTEGER && m <= e.MAX_SAFE_INTEGER
    }
}
)(Pl);
Object.defineProperty(Fe, "__esModule", {
    value: !0
});
var kl = Pl;
function zf(e, t) {
    return t === void 0 && (t = 0),
    (e[t + 0] << 8 | e[t + 1]) << 16 >> 16
}
Fe.readInt16BE = zf;
function Kf(e, t) {
    return t === void 0 && (t = 0),
    (e[t + 0] << 8 | e[t + 1]) >>> 0
}
Fe.readUint16BE = Kf;
function Vf(e, t) {
    return t === void 0 && (t = 0),
    (e[t + 1] << 8 | e[t]) << 16 >> 16
}
Fe.readInt16LE = Vf;
function Jf(e, t) {
    return t === void 0 && (t = 0),
    (e[t + 1] << 8 | e[t]) >>> 0
}
Fe.readUint16LE = Jf;
function _l(e, t, s) {
    return t === void 0 && (t = new Uint8Array(2)),
    s === void 0 && (s = 0),
    t[s + 0] = e >>> 8,
    t[s + 1] = e >>> 0,
    t
}
Fe.writeUint16BE = _l;
Fe.writeInt16BE = _l;
function Tl(e, t, s) {
    return t === void 0 && (t = new Uint8Array(2)),
    s === void 0 && (s = 0),
    t[s + 0] = e >>> 0,
    t[s + 1] = e >>> 8,
    t
}
Fe.writeUint16LE = Tl;
Fe.writeInt16LE = Tl;
function Mi(e, t) {
    return t === void 0 && (t = 0),
    e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]
}
Fe.readInt32BE = Mi;
function Li(e, t) {
    return t === void 0 && (t = 0),
    (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0
}
Fe.readUint32BE = Li;
function Ui(e, t) {
    return t === void 0 && (t = 0),
    e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]
}
Fe.readInt32LE = Ui;
function Fi(e, t) {
    return t === void 0 && (t = 0),
    (e[t + 3] << 24 | e[t + 2] << 16 | e[t + 1] << 8 | e[t]) >>> 0
}
Fe.readUint32LE = Fi;
function vs(e, t, s) {
    return t === void 0 && (t = new Uint8Array(4)),
    s === void 0 && (s = 0),
    t[s + 0] = e >>> 24,
    t[s + 1] = e >>> 16,
    t[s + 2] = e >>> 8,
    t[s + 3] = e >>> 0,
    t
}
Fe.writeUint32BE = vs;
Fe.writeInt32BE = vs;
function Es(e, t, s) {
    return t === void 0 && (t = new Uint8Array(4)),
    s === void 0 && (s = 0),
    t[s + 0] = e >>> 0,
    t[s + 1] = e >>> 8,
    t[s + 2] = e >>> 16,
    t[s + 3] = e >>> 24,
    t
}
Fe.writeUint32LE = Es;
Fe.writeInt32LE = Es;
function Qf(e, t) {
    t === void 0 && (t = 0);
    var s = Mi(e, t)
      , r = Mi(e, t + 4);
    return s * 4294967296 + r - (r >> 31) * 4294967296
}
Fe.readInt64BE = Qf;
function Wf(e, t) {
    t === void 0 && (t = 0);
    var s = Li(e, t)
      , r = Li(e, t + 4);
    return s * 4294967296 + r
}
Fe.readUint64BE = Wf;
function Yf(e, t) {
    t === void 0 && (t = 0);
    var s = Ui(e, t)
      , r = Ui(e, t + 4);
    return r * 4294967296 + s - (s >> 31) * 4294967296
}
Fe.readInt64LE = Yf;
function Zf(e, t) {
    t === void 0 && (t = 0);
    var s = Fi(e, t)
      , r = Fi(e, t + 4);
    return r * 4294967296 + s
}
Fe.readUint64LE = Zf;
function Ol(e, t, s) {
    return t === void 0 && (t = new Uint8Array(8)),
    s === void 0 && (s = 0),
    vs(e / 4294967296 >>> 0, t, s),
    vs(e >>> 0, t, s + 4),
    t
}
Fe.writeUint64BE = Ol;
Fe.writeInt64BE = Ol;
function Bl(e, t, s) {
    return t === void 0 && (t = new Uint8Array(8)),
    s === void 0 && (s = 0),
    Es(e >>> 0, t, s),
    Es(e / 4294967296 >>> 0, t, s + 4),
    t
}
Fe.writeUint64LE = Bl;
Fe.writeInt64LE = Bl;
function Xf(e, t, s) {
    if (s === void 0 && (s = 0),
    e % 8 !== 0)
        throw new Error("readUintBE supports only bitLengths divisible by 8");
    if (e / 8 > t.length - s)
        throw new Error("readUintBE: array is too short for the given bitLength");
    for (var r = 0, n = 1, d = e / 8 + s - 1; d >= s; d--)
        r += t[d] * n,
        n *= 256;
    return r
}
Fe.readUintBE = Xf;
function e0(e, t, s) {
    if (s === void 0 && (s = 0),
    e % 8 !== 0)
        throw new Error("readUintLE supports only bitLengths divisible by 8");
    if (e / 8 > t.length - s)
        throw new Error("readUintLE: array is too short for the given bitLength");
    for (var r = 0, n = 1, d = s; d < s + e / 8; d++)
        r += t[d] * n,
        n *= 256;
    return r
}
Fe.readUintLE = e0;
function t0(e, t, s, r) {
    if (s === void 0 && (s = new Uint8Array(e / 8)),
    r === void 0 && (r = 0),
    e % 8 !== 0)
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
    if (!kl.isSafeInteger(t))
        throw new Error("writeUintBE value must be an integer");
    for (var n = 1, d = e / 8 + r - 1; d >= r; d--)
        s[d] = t / n & 255,
        n *= 256;
    return s
}
Fe.writeUintBE = t0;
function r0(e, t, s, r) {
    if (s === void 0 && (s = new Uint8Array(e / 8)),
    r === void 0 && (r = 0),
    e % 8 !== 0)
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
    if (!kl.isSafeInteger(t))
        throw new Error("writeUintLE value must be an integer");
    for (var n = 1, d = r; d < r + e / 8; d++)
        s[d] = t / n & 255,
        n *= 256;
    return s
}
Fe.writeUintLE = r0;
function n0(e, t) {
    t === void 0 && (t = 0);
    var s = new DataView(e.buffer,e.byteOffset,e.byteLength);
    return s.getFloat32(t)
}
Fe.readFloat32BE = n0;
function s0(e, t) {
    t === void 0 && (t = 0);
    var s = new DataView(e.buffer,e.byteOffset,e.byteLength);
    return s.getFloat32(t, !0)
}
Fe.readFloat32LE = s0;
function i0(e, t) {
    t === void 0 && (t = 0);
    var s = new DataView(e.buffer,e.byteOffset,e.byteLength);
    return s.getFloat64(t)
}
Fe.readFloat64BE = i0;
function o0(e, t) {
    t === void 0 && (t = 0);
    var s = new DataView(e.buffer,e.byteOffset,e.byteLength);
    return s.getFloat64(t, !0)
}
Fe.readFloat64LE = o0;
function a0(e, t, s) {
    t === void 0 && (t = new Uint8Array(4)),
    s === void 0 && (s = 0);
    var r = new DataView(t.buffer,t.byteOffset,t.byteLength);
    return r.setFloat32(s, e),
    t
}
Fe.writeFloat32BE = a0;
function c0(e, t, s) {
    t === void 0 && (t = new Uint8Array(4)),
    s === void 0 && (s = 0);
    var r = new DataView(t.buffer,t.byteOffset,t.byteLength);
    return r.setFloat32(s, e, !0),
    t
}
Fe.writeFloat32LE = c0;
function u0(e, t, s) {
    t === void 0 && (t = new Uint8Array(8)),
    s === void 0 && (s = 0);
    var r = new DataView(t.buffer,t.byteOffset,t.byteLength);
    return r.setFloat64(s, e),
    t
}
Fe.writeFloat64BE = u0;
function l0(e, t, s) {
    t === void 0 && (t = new Uint8Array(8)),
    s === void 0 && (s = 0);
    var r = new DataView(t.buffer,t.byteOffset,t.byteLength);
    return r.setFloat64(s, e, !0),
    t
}
Fe.writeFloat64LE = l0;
(function(e) {
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    e.randomStringForEntropy = e.randomString = e.randomUint32 = e.randomBytes = e.defaultRandomSource = void 0;
    const t = Rs
      , s = Fe
      , r = Ms;
    e.defaultRandomSource = new t.SystemRandomSource;
    function n(i, l=e.defaultRandomSource) {
        return l.randomBytes(i)
    }
    e.randomBytes = n;
    function d(i=e.defaultRandomSource) {
        const l = n(4, i)
          , p = (0,
        s.readUint32LE)(l);
        return (0,
        r.wipe)(l),
        p
    }
    e.randomUint32 = d;
    const h = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function m(i, l=h, p=e.defaultRandomSource) {
        if (l.length < 2)
            throw new Error("randomString charset is too short");
        if (l.length > 256)
            throw new Error("randomString charset is too long");
        let o = "";
        const c = l.length
          , u = 256 - 256 % c;
        for (; i > 0; ) {
            const g = n(Math.ceil(i * 256 / u), p);
            for (let P = 0; P < g.length && i > 0; P++) {
                const v = g[P];
                v < u && (o += l.charAt(v % c),
                i--)
            }
            (0,
            r.wipe)(g)
        }
        return o
    }
    e.randomString = m;
    function f(i, l=h, p=e.defaultRandomSource) {
        const o = Math.ceil(i / (Math.log(l.length) / Math.LN2));
        return m(o, l, p)
    }
    e.randomStringForEntropy = f
}
)(El);
Object.defineProperty(Tt, "__esModule", {
    value: !0
});
Tt.checkInvalidKeys = Tt.isValidISO8601Date = Tt.generateNonce = Tt.checkContractWalletSignature = void 0;
const d0 = El
  , f0 = Hi
  , h0 = Gt
  , p0 = ["function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"]
  , b0 = "0x1626ba7e"
  , iu = /^(?<date>[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/
  , g0 = async (e, t, s) => {
    if (!s)
        return !1;
    const r = new f0.Contract(e.address,p0,s)
      , n = (0,
    h0.hashMessage)(e.prepareMessage());
    return await r.isValidSignature(n, t) === b0
}
;
Tt.checkContractWalletSignature = g0;
const m0 = () => {
    const e = (0,
    d0.randomStringForEntropy)(96);
    if (!e || e.length < 8)
        throw new Error("Error during nonce creation.");
    return e
}
;
Tt.generateNonce = m0;
const y0 = e => {
    const t = iu.exec(e);
    if (!t)
        return !1;
    const s = new Date(t.groups.date).toISOString()
      , r = iu.exec(s);
    return t.groups.date === r.groups.date
}
;
Tt.isValidISO8601Date = y0;
const x0 = (e, t) => {
    const s = [];
    return Object.keys(e).forEach(r => {
        t.includes(r) || s.push(r)
    }
    ),
    s
}
;
Tt.checkInvalidKeys = x0;
Object.defineProperty(Ps, "__esModule", {
    value: !0
});
Ps.SiweMessage = void 0;
const hi = au
  , w0 = Gt
  , ut = io
  , Zn = Tt;
class A0 {
    constructor(t) {
        if (typeof t == "string") {
            const s = new hi.ParsedMessage(t);
            this.scheme = s.scheme,
            this.domain = s.domain,
            this.address = s.address,
            this.statement = s.statement,
            this.uri = s.uri,
            this.version = s.version,
            this.nonce = s.nonce,
            this.issuedAt = s.issuedAt,
            this.expirationTime = s.expirationTime,
            this.notBefore = s.notBefore,
            this.requestId = s.requestId,
            this.chainId = s.chainId,
            this.resources = s.resources
        } else
            this.scheme = t == null ? void 0 : t.scheme,
            this.domain = t.domain,
            this.address = t.address,
            this.statement = t == null ? void 0 : t.statement,
            this.uri = t.uri,
            this.version = t.version,
            this.chainId = t.chainId,
            this.nonce = t.nonce,
            this.issuedAt = t == null ? void 0 : t.issuedAt,
            this.expirationTime = t == null ? void 0 : t.expirationTime,
            this.notBefore = t == null ? void 0 : t.notBefore,
            this.requestId = t == null ? void 0 : t.requestId,
            this.resources = t == null ? void 0 : t.resources,
            typeof this.chainId == "string" && (this.chainId = (0,
            hi.parseIntegerNumber)(this.chainId)),
            this.nonce = this.nonce || (0,
            Zn.generateNonce)(),
            new hi.ParsedMessage(this.prepareMessage())
    }
    toMessage() {
        const s = `${this.scheme ? `${this.scheme}://${this.domain}` : this.domain} wants you to sign in with your Ethereum account:`
          , r = `URI: ${this.uri}`;
        let n = [s, this.address].join(`
`);
        const d = `Version: ${this.version}`;
        this.nonce || (this.nonce = (0,
        Zn.generateNonce)());
        const h = "Chain ID: " + this.chainId || "1"
          , m = `Nonce: ${this.nonce}`
          , f = [r, d, h, m];
        if (this.issuedAt = this.issuedAt || new Date().toISOString(),
        f.push(`Issued At: ${this.issuedAt}`),
        this.expirationTime) {
            const l = `Expiration Time: ${this.expirationTime}`;
            f.push(l)
        }
        this.notBefore && f.push(`Not Before: ${this.notBefore}`),
        this.requestId && f.push(`Request ID: ${this.requestId}`),
        this.resources && f.push(["Resources:", ...this.resources.map(l => `- ${l}`)].join(`
`));
        const i = f.join(`
`);
        return n = [n, this.statement].join(`

`),
        this.statement !== void 0 && (n += `
`),
        [n, i].join(`
`)
    }
    prepareMessage() {
        let t;
        switch (this.version) {
        case "1":
            {
                t = this.toMessage();
                break
            }
        default:
            {
                t = this.toMessage();
                break
            }
        }
        return t
    }
    async verify(t, s={
        suppressExceptions: !1
    }) {
        return new Promise( (r, n) => {
            var d, h, m;
            const f = x => s.suppressExceptions ? r(x) : n(x)
              , i = (0,
            Zn.checkInvalidKeys)(t, ut.VerifyParamsKeys);
            i.length > 0 && f({
                success: !1,
                data: this,
                error: new Error(`${i.join(", ")} is/are not valid key(s) for VerifyParams.`)
            });
            const l = (0,
            Zn.checkInvalidKeys)(s, ut.VerifyOptsKeys);
            l.length > 0 && f({
                success: !1,
                data: this,
                error: new Error(`${l.join(", ")} is/are not valid key(s) for VerifyOpts.`)
            });
            const {signature: p, scheme: o, domain: c, nonce: u, time: g} = t;
            o && o !== this.scheme && f({
                success: !1,
                data: this,
                error: new ut.SiweError(ut.SiweErrorType.SCHEME_MISMATCH,o,this.scheme)
            }),
            c && c !== this.domain && f({
                success: !1,
                data: this,
                error: new ut.SiweError(ut.SiweErrorType.DOMAIN_MISMATCH,c,this.domain)
            }),
            u && u !== this.nonce && f({
                success: !1,
                data: this,
                error: new ut.SiweError(ut.SiweErrorType.NONCE_MISMATCH,u,this.nonce)
            });
            const P = new Date(g || new Date);
            if (this.expirationTime) {
                const x = new Date(this.expirationTime);
                P.getTime() >= x.getTime() && f({
                    success: !1,
                    data: this,
                    error: new ut.SiweError(ut.SiweErrorType.EXPIRED_MESSAGE,`${P.toISOString()} < ${x.toISOString()}`,`${P.toISOString()} >= ${x.toISOString()}`)
                })
            }
            if (this.notBefore) {
                const x = new Date(this.notBefore);
                P.getTime() < x.getTime() && f({
                    success: !1,
                    data: this,
                    error: new ut.SiweError(ut.SiweErrorType.NOT_YET_VALID_MESSAGE,`${P.toISOString()} >= ${x.toISOString()}`,`${P.toISOString()} < ${x.toISOString()}`)
                })
            }
            let v;
            try {
                v = this.prepareMessage()
            } catch (x) {
                f({
                    success: !1,
                    data: this,
                    error: x
                })
            }
            let b;
            try {
                b = (0,
                w0.verifyMessage)(v, p)
            } catch (x) {
                console.error(x)
            }
            if (b === this.address)
                return r({
                    success: !0,
                    data: this
                });
            {
                const x = (0,
                Zn.checkContractWalletSignature)(this, p, s.provider).then(a => a ? {
                    success: !0,
                    data: this
                } : {
                    success: !1,
                    data: this,
                    error: new ut.SiweError(ut.SiweErrorType.INVALID_SIGNATURE,b,`Resolved address to be ${this.address}`)
                }).catch(a => ({
                    success: !1,
                    data: this,
                    error: a
                }));
                Promise.all([x, (m = (h = (d = s == null ? void 0 : s.verificationFallback) === null || d === void 0 ? void 0 : d.call(s, t, s, this, x)) === null || h === void 0 ? void 0 : h.then(a => a)) === null || m === void 0 ? void 0 : m.catch(a => a)]).then( ([a,E]) => {
                    if (E) {
                        if (E.success)
                            return r(E);
                        f(E)
                    } else {
                        if (a.success)
                            return r(a);
                        f(a)
                    }
                }
                )
            }
        }
        )
    }
}
Ps.SiweMessage = A0;
(function(e) {
    var t = He && He.__createBinding || (Object.create ? function(r, n, d, h) {
        h === void 0 && (h = d);
        var m = Object.getOwnPropertyDescriptor(n, d);
        (!m || ("get"in m ? !n.__esModule : m.writable || m.configurable)) && (m = {
            enumerable: !0,
            get: function() {
                return n[d]
            }
        }),
        Object.defineProperty(r, h, m)
    }
    : function(r, n, d, h) {
        h === void 0 && (h = d),
        r[h] = n[d]
    }
    )
      , s = He && He.__exportStar || function(r, n) {
        for (var d in r)
            d !== "default" && !Object.prototype.hasOwnProperty.call(n, d) && t(n, r, d)
    }
    ;
    Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    s(Ps, e),
    s(io, e),
    s(Tt, e)
}
)(Di);
const v0 = Kl(Di)
  , O0 = Yl({
    __proto__: null,
    default: v0
}, [Di]);
export {Di as a, O0 as s};

